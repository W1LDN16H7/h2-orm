<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;H2-ORM&lt;/artifactId&gt;&#10;    &lt;version&gt;v0.0.1&lt;/version&gt;&#10;    &lt;packaging&gt;jar&lt;/packaging&gt;&#10;&#10;    &lt;name&gt;h2-orm&lt;/name&gt;&#10;    &lt;description&gt;Modern JPA-based database handler supporting H2, MySQL, PostgreSQL, and SQLite with advanced features&lt;/description&gt;&#10;    &lt;url&gt;https://github.com/W1LDN16H7/h2-orm.git&lt;/url&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;        &lt;maven.compiler.target&gt;24&lt;/maven.compiler.target&gt;&#10;        &lt;maven.compiler.source&gt;24&lt;/maven.compiler.source&gt;&#10;        &lt;junit.version&gt;5.13.2&lt;/junit.version&gt;&#10;&#10;        &lt;hibernate.version&gt;6.6.3.Final&lt;/hibernate.version&gt;&#10;        &lt;jakarta.persistence.version&gt;3.2.0&lt;/jakarta.persistence.version&gt;&#10;        &lt;hikaricp.version&gt;6.2.1&lt;/hikaricp.version&gt;&#10;        &lt;h2.version&gt;2.3.232&lt;/h2.version&gt;&#10;        &lt;mysql.version&gt;8.4.0&lt;/mysql.version&gt;&#10;        &lt;postgresql.version&gt;42.7.4&lt;/postgresql.version&gt;&#10;        &lt;sqlite.version&gt;3.46.1.3&lt;/sqlite.version&gt;&#10;        &lt;jackson.version&gt;2.19.0&lt;/jackson.version&gt;&#10;        &lt;poi.version&gt;5.4.1&lt;/poi.version&gt;&#10;        &lt;slf4j.version&gt;2.0.17&lt;/slf4j.version&gt;&#10;        &lt;logback.version&gt;1.5.18&lt;/logback.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- JPA &amp; Hibernate --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${jakarta.persistence.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-hikaricp&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Connection Pool --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;&#10;            &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;&#10;            &lt;version&gt;${hikaricp.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Database Drivers --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.h2database&lt;/groupId&gt;&#10;            &lt;artifactId&gt;h2&lt;/artifactId&gt;&#10;            &lt;version&gt;${h2.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.mysql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;&#10;            &lt;version&gt;9.4.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;            &lt;version&gt;${postgresql.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.xerial&lt;/groupId&gt;&#10;            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;&#10;            &lt;version&gt;${sqlite.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JSON Processing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Excel Export --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Logging --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${slf4j.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;&#10;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;&#10;            &lt;version&gt;${logback.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Testing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;&#10;            &lt;version&gt;5.11.4&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;!-- Compiler Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.13.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;17&lt;/source&gt;&#10;                    &lt;target&gt;17&lt;/target&gt;&#10;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Source Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.3.1&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-sources&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Javadoc Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.11.1&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;doclint&gt;none&lt;/doclint&gt;&#10;                    &lt;quiet&gt;true&lt;/quiet&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-javadocs&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Assembly Plugin for fat JAR --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.7.1&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;descriptorRefs&gt;&#10;                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;&#10;                    &lt;/descriptorRefs&gt;&#10;                    &lt;archive&gt;&#10;                        &lt;manifest&gt;&#10;                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;&#10;                        &lt;/manifest&gt;&#10;                    &lt;/archive&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;make-assembly&lt;/id&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;single&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Shade Plugin for uber JAR --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.6.0&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;shade&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                        &lt;configuration&gt;&#10;                            &lt;shadedArtifactAttached&gt;true&lt;/shadedArtifactAttached&gt;&#10;                            &lt;shadedClassifierName&gt;uber&lt;/shadedClassifierName&gt;&#10;                            &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;&#10;                            &lt;transformers&gt;&#10;                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;&#10;                                    &lt;manifestEntries&gt;&#10;                                        &lt;Built-By&gt;JPA Database Handler&lt;/Built-By&gt;&#10;                                        &lt;Implementation-Version&gt;${project.version}&lt;/Implementation-Version&gt;&#10;                                    &lt;/manifestEntries&gt;&#10;                                &lt;/transformer&gt;&#10;                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&gt;&#10;                            &lt;/transformers&gt;&#10;                        &lt;/configuration&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Test Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.5.2&lt;/version&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;    &lt;licenses&gt;&#10;        &lt;license&gt;&#10;            &lt;name&gt;MIT License&lt;/name&gt;&#10;            &lt;url&gt;https://opensource.org/licenses/MIT&lt;/url&gt;&#10;            &lt;distribution&gt;repo&lt;/distribution&gt;&#10;        &lt;/license&gt;&#10;    &lt;/licenses&gt;&#10;&#10;    &lt;developers&gt;&#10;        &lt;developer&gt;&#10;            &lt;id&gt;Kapil Kumar&lt;/id&gt;&#10;            &lt;name&gt;KP enterprise Team&lt;/name&gt;&#10;            &lt;email&gt;kapil.campus@gmail.com&lt;/email&gt;&#10;        &lt;/developer&gt;&#10;    &lt;/developers&gt;&#10;&#10;    &lt;scm&gt;&#10;        &lt;connection&gt;scm:git:git://github.com/W1LDN16H7/h2-orm.git&lt;/connection&gt;&#10;        &lt;developerConnection&gt;scm:git:ssh://github.com:W1LDN16H7/h2-orm.git&lt;/developerConnection&gt;&#10;        &lt;url&gt;https://github.com/W1LDN16H7/h2-orm.git/tree/main&lt;/url&gt;&#10;    &lt;/scm&gt;&#10;&#10;&lt;/project&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;packaging&gt;jar&lt;/packaging&gt;&#10;&#10;    &lt;name&gt;H2-ORM&lt;/name&gt;&#10;    &lt;description&gt;Modern Spring Boot-style ORM library supporting H2, MySQL, PostgreSQL, and SQLite with advanced backup/export features&lt;/description&gt;&#10;    &lt;url&gt;https://github.com/W1LDN16H7/h2-orm&lt;/url&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;        &lt;maven.compiler.target&gt;24&lt;/maven.compiler.target&gt;&#10;        &lt;maven.compiler.source&gt;24&lt;/maven.compiler.source&gt;&#10;        &lt;junit.version&gt;5.13.2&lt;/junit.version&gt;&#10;&#10;        &lt;hibernate.version&gt;6.6.3.Final&lt;/hibernate.version&gt;&#10;        &lt;jakarta.persistence.version&gt;3.2.0&lt;/jakarta.persistence.version&gt;&#10;        &lt;hikaricp.version&gt;6.2.1&lt;/hikaricp.version&gt;&#10;        &lt;h2.version&gt;2.3.232&lt;/h2.version&gt;&#10;        &lt;mysql.version&gt;8.4.0&lt;/mysql.version&gt;&#10;        &lt;postgresql.version&gt;42.7.4&lt;/postgresql.version&gt;&#10;        &lt;sqlite.version&gt;3.46.1.3&lt;/sqlite.version&gt;&#10;        &lt;jackson.version&gt;2.19.0&lt;/jackson.version&gt;&#10;        &lt;poi.version&gt;5.4.1&lt;/poi.version&gt;&#10;        &lt;slf4j.version&gt;2.0.17&lt;/slf4j.version&gt;&#10;        &lt;logback.version&gt;1.5.18&lt;/logback.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- JPA &amp; Hibernate --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${jakarta.persistence.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-hikaricp&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Connection Pool --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;&#10;            &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;&#10;            &lt;version&gt;${hikaricp.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Database Drivers --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.h2database&lt;/groupId&gt;&#10;            &lt;artifactId&gt;h2&lt;/artifactId&gt;&#10;            &lt;version&gt;${h2.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.mysql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;&#10;            &lt;version&gt;9.4.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;            &lt;version&gt;${postgresql.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.xerial&lt;/groupId&gt;&#10;            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;&#10;            &lt;version&gt;${sqlite.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JSON Processing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Excel Export --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Logging --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${slf4j.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;&#10;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;&#10;            &lt;version&gt;${logback.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Testing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;&#10;            &lt;version&gt;5.11.4&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;!-- Compiler Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.13.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;17&lt;/source&gt;&#10;                    &lt;target&gt;17&lt;/target&gt;&#10;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Source Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.3.1&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-sources&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Javadoc Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.11.1&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;doclint&gt;none&lt;/doclint&gt;&#10;                    &lt;quiet&gt;true&lt;/quiet&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-javadocs&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Assembly Plugin for fat JAR --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.7.1&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;descriptorRefs&gt;&#10;                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;&#10;                    &lt;/descriptorRefs&gt;&#10;                    &lt;archive&gt;&#10;                        &lt;manifest&gt;&#10;                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;&#10;                        &lt;/manifest&gt;&#10;                    &lt;/archive&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;make-assembly&lt;/id&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;single&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Shade Plugin for uber JAR --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.6.0&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;shade&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                        &lt;configuration&gt;&#10;                            &lt;shadedArtifactAttached&gt;true&lt;/shadedArtifactAttached&gt;&#10;                            &lt;shadedClassifierName&gt;uber&lt;/shadedClassifierName&gt;&#10;                            &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;&#10;                            &lt;transformers&gt;&#10;                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;&#10;                                    &lt;manifestEntries&gt;&#10;                                        &lt;Built-By&gt;JPA Database Handler&lt;/Built-By&gt;&#10;                                        &lt;Implementation-Version&gt;${project.version}&lt;/Implementation-Version&gt;&#10;                                    &lt;/manifestEntries&gt;&#10;                                &lt;/transformer&gt;&#10;                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&gt;&#10;                            &lt;/transformers&gt;&#10;                        &lt;/configuration&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Test Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.5.2&lt;/version&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;    &lt;licenses&gt;&#10;        &lt;license&gt;&#10;            &lt;name&gt;MIT License&lt;/name&gt;&#10;            &lt;url&gt;https://opensource.org/licenses/MIT&lt;/url&gt;&#10;            &lt;distribution&gt;repo&lt;/distribution&gt;&#10;        &lt;/license&gt;&#10;    &lt;/licenses&gt;&#10;&#10;    &lt;developers&gt;&#10;        &lt;developer&gt;&#10;            &lt;id&gt;h2orm-team&lt;/id&gt;&#10;            &lt;name&gt;H2-ORM Development Team&lt;/name&gt;&#10;            &lt;email&gt;team@h2orm.com&lt;/email&gt;&#10;        &lt;/developer&gt;&#10;    &lt;/developers&gt;&#10;&#10;    &lt;scm&gt;&#10;        &lt;connection&gt;scm:git:git://github.com/W1LDN16H7/h2-orm.git&lt;/connection&gt;&#10;        &lt;developerConnection&gt;scm:git:ssh://github.com/W1LDN16H7/h2-orm.git&lt;/developerConnection&gt;&#10;        &lt;url&gt;https://github.com/W1LDN16H7/h2-orm&lt;/url&gt;&#10;    &lt;/scm&gt;&#10;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/EntityManagerProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/EntityManagerProvider.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.config.DatabaseProperties;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Enhanced EntityManager Provider for H2-ORM library&#10; * Supports H2, SQLite, MySQL, PostgreSQL with advanced configuration management&#10; */&#10;public class EntityManagerProvider {&#10;    private static final Logger logger = LoggerFactory.getLogger(EntityManagerProvider.class);&#10;    private static final Map&lt;String, EntityManagerFactory&gt; factories = new ConcurrentHashMap&lt;&gt;();&#10;    private static final ThreadLocal&lt;EntityManager&gt; entityManagerThreadLocal = new ThreadLocal&lt;&gt;();&#10;    private static String defaultConfigName = &quot;default&quot;;&#10;    private static DatabaseConfiguration currentConfig;&#10;&#10;    /**&#10;     * Initialize with default configuration from properties&#10;     */&#10;    public static void initialize() {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromProperties();&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with custom properties file&#10;     */&#10;    public static void initialize(String propertiesFile) {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with specific configuration&#10;     */&#10;    public static void initialize(DatabaseConfiguration config) {&#10;        initialize(defaultConfigName, config);&#10;        currentConfig = config;&#10;    }&#10;&#10;    /**&#10;     * Initialize with named configuration for multi-database support&#10;     */&#10;    public static void initialize(String configName, DatabaseConfiguration config) {&#10;        EntityManagerFactory existingFactory = factories.get(configName);&#10;        if (existingFactory != null &amp;&amp; existingFactory.isOpen()) {&#10;            existingFactory.close();&#10;        }&#10;&#10;        try {&#10;            Map&lt;String, Object&gt; properties = buildJpaProperties(config);&#10;&#10;            logger.info(&quot;Initializing EntityManagerFactory for config: {} with database: {}&quot;,&#10;                    configName, config.getUrl());&#10;&#10;            EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;h2-orm-pu&quot;, properties);&#10;            factories.put(configName, factory);&#10;&#10;            logger.info(&quot;EntityManagerFactory initialized successfully for config: {}&quot;, configName);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to initialize EntityManagerFactory for config: {}&quot;, configName, e);&#10;            throw new RuntimeException(&quot;Failed to initialize database connection&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for default configuration&#10;     */&#10;    public static EntityManager getEntityManager() {&#10;        return getEntityManager(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for named configuration&#10;     */&#10;    public static EntityManager getEntityManager(String configName) {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em == null || !em.isOpen()) {&#10;            EntityManagerFactory factory = factories.get(configName);&#10;            if (factory == null) {&#10;                throw new IllegalStateException(&quot;EntityManagerFactory not initialized for config: &quot; + configName);&#10;            }&#10;            em = factory.createEntityManager();&#10;            entityManagerThreadLocal.set(em);&#10;        }&#10;        return em;&#10;    }&#10;&#10;    /**&#10;     * Close current thread's EntityManager&#10;     */&#10;    public static void closeEntityManager() {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em != null &amp;&amp; em.isOpen()) {&#10;            try {&#10;                if (em.getTransaction().isActive()) {&#10;                    em.getTransaction().rollback();&#10;                }&#10;                em.close();&#10;            } catch (Exception e) {&#10;                logger.warn(&quot;Error closing EntityManager&quot;, e);&#10;            } finally {&#10;                entityManagerThreadLocal.remove();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(TransactionCallback&lt;T&gt; callback) {&#10;        return executeInTransaction(defaultConfigName, callback);&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, TransactionCallback&lt;T&gt; callback) {&#10;        EntityManager em = getEntityManager(configName);&#10;        try {&#10;            em.getTransaction().begin();&#10;            T result = callback.execute(em);&#10;            em.getTransaction().commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;            }&#10;            throw new RuntimeException(&quot;Transaction failed&quot;, e);&#10;        } finally {&#10;            closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown all EntityManagerFactories&#10;     */&#10;    public static void shutdown() {&#10;        closeEntityManager();&#10;        factories.values().forEach(factory -&gt; {&#10;            if (factory.isOpen()) {&#10;                try {&#10;                    factory.close();&#10;                } catch (Exception e) {&#10;                    logger.warn(&quot;Error closing EntityManagerFactory&quot;, e);&#10;                }&#10;            }&#10;        });&#10;        factories.clear();&#10;        logger.info(&quot;All EntityManagerFactories shut down&quot;);&#10;    }&#10;&#10;    /**&#10;     * Check if provider is initialized&#10;     */&#10;    public static boolean isInitialized() {&#10;        return isInitialized(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Check if named configuration is initialized&#10;     */&#10;    public static boolean isInitialized(String configName) {&#10;        EntityManagerFactory factory = factories.get(configName);&#10;        return factory != null &amp;&amp; factory.isOpen();&#10;    }&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public static DatabaseConfiguration getCurrentConfiguration() {&#10;        return currentConfig;&#10;    }&#10;&#10;    private static Map&lt;String, Object&gt; buildJpaProperties(DatabaseConfiguration config) {&#10;        Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();&#10;&#10;        // Basic connection properties&#10;        properties.put(&quot;jakarta.persistence.jdbc.driver&quot;, config.getDriverClass());&#10;        properties.put(&quot;jakarta.persistence.jdbc.url&quot;, config.getUrl());&#10;        properties.put(&quot;jakarta.persistence.jdbc.user&quot;, config.getUsername());&#10;        properties.put(&quot;jakarta.persistence.jdbc.password&quot;, config.getPassword());&#10;&#10;        // Hibernate specific properties&#10;        properties.put(&quot;hibernate.dialect&quot;, config.getDialect());&#10;        properties.put(&quot;hibernate.hbm2ddl.auto&quot;, config.getDdlAuto());&#10;        properties.put(&quot;hibernate.show_sql&quot;, String.valueOf(config.isShowSql()));&#10;        properties.put(&quot;hibernate.format_sql&quot;, String.valueOf(config.isFormatSql()));&#10;        properties.put(&quot;hibernate.use_sql_comments&quot;, &quot;true&quot;);&#10;&#10;        // Connection pool settings (HikariCP)&#10;        properties.put(&quot;hibernate.connection.provider_class&quot;, &quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;);&#10;        properties.put(&quot;hibernate.hikari.maximumPoolSize&quot;, String.valueOf(config.getPoolSize()));&#10;        properties.put(&quot;hibernate.hikari.minimumIdle&quot;, String.valueOf(config.getMinimumIdle()));&#10;        properties.put(&quot;hibernate.hikari.connectionTimeout&quot;, String.valueOf(config.getConnectionTimeout()));&#10;        properties.put(&quot;hibernate.hikari.idleTimeout&quot;, String.valueOf(config.getIdleTimeout()));&#10;        properties.put(&quot;hibernate.hikari.maxLifetime&quot;, String.valueOf(config.getMaxLifetime()));&#10;        properties.put(&quot;hibernate.hikari.poolName&quot;, config.getPoolName());&#10;&#10;        // Performance settings&#10;        properties.put(&quot;hibernate.jdbc.batch_size&quot;, String.valueOf(config.getBatchSize()));&#10;        properties.put(&quot;hibernate.order_inserts&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.order_updates&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.jdbc.batch_versioned_data&quot;, &quot;true&quot;);&#10;&#10;        // Cache settings - Disable caching by default for simplicity&#10;        properties.put(&quot;hibernate.cache.use_second_level_cache&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.cache.use_query_cache&quot;, &quot;false&quot;);&#10;&#10;        if (config.isUseSecondLevelCache()) {&#10;            // Use Hibernate's built-in cache instead of JCache&#10;            properties.put(&quot;hibernate.cache.region.factory_class&quot;, &quot;org.hibernate.cache.internal.NoCacheRegionFactory&quot;);&#10;        }&#10;&#10;        // Additional optimizations&#10;        properties.put(&quot;hibernate.connection.autocommit&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.jdbc.lob.non_contextual_creation&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.temp.use_jdbc_metadata_defaults&quot;, &quot;false&quot;);&#10;&#10;        return properties;&#10;    }&#10;&#10;    /**&#10;     * Functional interface for transaction callbacks&#10;     */&#10;    @FunctionalInterface&#10;    public interface TransactionCallback&lt;T&gt; {&#10;        T execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.config.DatabaseProperties;&#10;import h2.orm.exception.DatabaseNotInitializedException;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Enhanced EntityManager Provider for H2-ORM library&#10; * Supports H2, SQLite, MySQL, PostgreSQL with advanced configuration management&#10; */&#10;public class EntityManagerProvider {&#10;    private static final Logger logger = LoggerFactory.getLogger(EntityManagerProvider.class);&#10;    private static final Map&lt;String, EntityManagerFactory&gt; factories = new ConcurrentHashMap&lt;&gt;();&#10;    private static final ThreadLocal&lt;EntityManager&gt; entityManagerThreadLocal = new ThreadLocal&lt;&gt;();&#10;    private static String defaultConfigName = &quot;default&quot;;&#10;    private static DatabaseConfiguration currentConfig;&#10;&#10;    /**&#10;     * Initialize with default configuration from properties&#10;     */&#10;    public static void initialize() {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromProperties();&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with custom properties file&#10;     */&#10;    public static void initialize(String propertiesFile) {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with specific configuration&#10;     */&#10;    public static void initialize(DatabaseConfiguration config) {&#10;        initialize(defaultConfigName, config);&#10;        currentConfig = config;&#10;    }&#10;&#10;    /**&#10;     * Initialize with named configuration for multi-database support&#10;     */&#10;    public static void initialize(String configName, DatabaseConfiguration config) {&#10;        EntityManagerFactory existingFactory = factories.get(configName);&#10;        if (existingFactory != null &amp;&amp; existingFactory.isOpen()) {&#10;            existingFactory.close();&#10;        }&#10;&#10;        try {&#10;            Map&lt;String, Object&gt; properties = buildJpaProperties(config);&#10;&#10;            logger.info(&quot;Initializing EntityManagerFactory for config: {} with database: {}&quot;,&#10;                    configName, config.getUrl());&#10;&#10;            EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;h2-orm-pu&quot;, properties);&#10;            factories.put(configName, factory);&#10;&#10;            logger.info(&quot;EntityManagerFactory initialized successfully for config: {}&quot;, configName);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to initialize EntityManagerFactory for config: {}&quot;, configName, e);&#10;            throw new RuntimeException(&quot;Failed to initialize database connection&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for default configuration&#10;     */&#10;    public static EntityManager getEntityManager() {&#10;        return getEntityManager(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for named configuration&#10;     */&#10;    public static EntityManager getEntityManager(String configName) {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em == null || !em.isOpen()) {&#10;            EntityManagerFactory factory = factories.get(configName);&#10;            if (factory == null) {&#10;                throw new DatabaseNotInitializedException();&#10;            }&#10;            em = factory.createEntityManager();&#10;            entityManagerThreadLocal.set(em);&#10;        }&#10;        return em;&#10;    }&#10;&#10;    /**&#10;     * Close current thread's EntityManager&#10;     */&#10;    public static void closeEntityManager() {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em != null &amp;&amp; em.isOpen()) {&#10;            try {&#10;                if (em.getTransaction().isActive()) {&#10;                    em.getTransaction().rollback();&#10;                }&#10;                em.close();&#10;            } catch (Exception e) {&#10;                logger.warn(&quot;Error closing EntityManager&quot;, e);&#10;            } finally {&#10;                entityManagerThreadLocal.remove();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(TransactionCallback&lt;T&gt; callback) {&#10;        return executeInTransaction(defaultConfigName, callback);&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, TransactionCallback&lt;T&gt; callback) {&#10;        EntityManager em = getEntityManager(configName);&#10;        try {&#10;            em.getTransaction().begin();&#10;            T result = callback.execute(em);&#10;            em.getTransaction().commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;            }&#10;            throw new RuntimeException(&quot;Transaction failed&quot;, e);&#10;        } finally {&#10;            closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown all EntityManagerFactories&#10;     */&#10;    public static void shutdown() {&#10;        closeEntityManager();&#10;        factories.values().forEach(factory -&gt; {&#10;            if (factory.isOpen()) {&#10;                try {&#10;                    factory.close();&#10;                } catch (Exception e) {&#10;                    logger.warn(&quot;Error closing EntityManagerFactory&quot;, e);&#10;                }&#10;            }&#10;        });&#10;        factories.clear();&#10;        logger.info(&quot;All EntityManagerFactories shut down&quot;);&#10;    }&#10;&#10;    /**&#10;     * Check if provider is initialized&#10;     */&#10;    public static boolean isInitialized() {&#10;        return isInitialized(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Check if named configuration is initialized&#10;     */&#10;    public static boolean isInitialized(String configName) {&#10;        EntityManagerFactory factory = factories.get(configName);&#10;        return factory != null &amp;&amp; factory.isOpen();&#10;    }&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public static DatabaseConfiguration getCurrentConfiguration() {&#10;        return currentConfig;&#10;    }&#10;&#10;    private static Map&lt;String, Object&gt; buildJpaProperties(DatabaseConfiguration config) {&#10;        Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();&#10;&#10;        // Basic connection properties&#10;        properties.put(&quot;jakarta.persistence.jdbc.driver&quot;, config.getDriverClass());&#10;        properties.put(&quot;jakarta.persistence.jdbc.url&quot;, config.getUrl());&#10;        properties.put(&quot;jakarta.persistence.jdbc.user&quot;, config.getUsername());&#10;        properties.put(&quot;jakarta.persistence.jdbc.password&quot;, config.getPassword());&#10;&#10;        // Hibernate specific properties&#10;        properties.put(&quot;hibernate.dialect&quot;, config.getDialect());&#10;        properties.put(&quot;hibernate.hbm2ddl.auto&quot;, config.getDdlAuto());&#10;        properties.put(&quot;hibernate.show_sql&quot;, String.valueOf(config.isShowSql()));&#10;        properties.put(&quot;hibernate.format_sql&quot;, String.valueOf(config.isFormatSql()));&#10;        properties.put(&quot;hibernate.use_sql_comments&quot;, &quot;true&quot;);&#10;&#10;        // Connection pool settings (HikariCP)&#10;        properties.put(&quot;hibernate.connection.provider_class&quot;, &quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;);&#10;        properties.put(&quot;hibernate.hikari.maximumPoolSize&quot;, String.valueOf(config.getPoolSize()));&#10;        properties.put(&quot;hibernate.hikari.minimumIdle&quot;, String.valueOf(config.getMinimumIdle()));&#10;        properties.put(&quot;hibernate.hikari.connectionTimeout&quot;, String.valueOf(config.getConnectionTimeout()));&#10;        properties.put(&quot;hibernate.hikari.idleTimeout&quot;, String.valueOf(config.getIdleTimeout()));&#10;        properties.put(&quot;hibernate.hikari.maxLifetime&quot;, String.valueOf(config.getMaxLifetime()));&#10;        properties.put(&quot;hibernate.hikari.poolName&quot;, config.getPoolName());&#10;&#10;        // Performance settings&#10;        properties.put(&quot;hibernate.jdbc.batch_size&quot;, String.valueOf(config.getBatchSize()));&#10;        properties.put(&quot;hibernate.order_inserts&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.order_updates&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.jdbc.batch_versioned_data&quot;, &quot;true&quot;);&#10;&#10;        // Cache settings - Disable caching by default for simplicity&#10;        properties.put(&quot;hibernate.cache.use_second_level_cache&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.cache.use_query_cache&quot;, &quot;false&quot;);&#10;&#10;        if (config.isUseSecondLevelCache()) {&#10;            // Use Hibernate's built-in cache instead of JCache&#10;            properties.put(&quot;hibernate.cache.region.factory_class&quot;, &quot;org.hibernate.cache.internal.NoCacheRegionFactory&quot;);&#10;        }&#10;&#10;        // Additional optimizations&#10;        properties.put(&quot;hibernate.connection.autocommit&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.jdbc.lob.non_contextual_creation&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.temp.use_jdbc_metadata_defaults&quot;, &quot;false&quot;);&#10;&#10;        return properties;&#10;    }&#10;&#10;    /**&#10;     * Functional interface for transaction callbacks&#10;     */&#10;    @FunctionalInterface&#10;    public interface TransactionCallback&lt;T&gt; {&#10;        T execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/JpaAdvancedDatabaseHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/JpaAdvancedDatabaseHandler.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.open.autobot.database.jpa.repository.AbstractRepository;&#10;import com.open.autobot.database.jpa.repository.Repository;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.Query;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Modern JPA-based Database Handler&#10; * High-performance replacement for the original H2DatabaseHandler&#10; * Supports H2, MySQL, PostgreSQL, SQLite and other JPA-compatible databases&#10; */&#10;public class JpaAdvancedDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(JpaAdvancedDatabaseHandler.class);&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;    private final Map&lt;Class&lt;?&gt;, Repository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Initialize the database with configuration&#10;     */&#10;    public void initialize(DatabaseConfig config) {&#10;        EntityManagerProvider.initialize(config);&#10;        logger.info(&quot;JPA Advanced Database Handler initialized successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Get or create repository for entity class&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T, ID extends Serializable&gt; Repository&lt;T, ID&gt; getRepository(Class&lt;T&gt; entityClass) {&#10;        return (Repository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, clazz -&gt;&#10;            new GenericRepository&lt;&gt;((Class&lt;T&gt;) clazz)&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        return repo.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save multiple entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return new ArrayList&lt;&gt;();&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        return repo.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findAll();&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findAll(offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByAttribute(Class&lt;T&gt; entityClass, String attributeName, Object value) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByAttribute(attributeName, value);&#10;    }&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByNativeQuery(Class&lt;T&gt; entityClass, String sqlQuery, Object... params) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByNativeQuery(sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByQuery(Class&lt;T&gt; entityClass, String jpqlQuery, Object... params) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByQuery(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.count();&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean existsById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.existsById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    public &lt;T&gt; boolean existsByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.existsByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        return repo.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        repo.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    public &lt;T&gt; void deleteAll(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteAll();&#10;    }&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    public &lt;T&gt; void deleteByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    public int executeUpdate(String jpqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            Query query = em.createQuery(jpqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            int result = query.executeUpdate();&#10;            tx.commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to execute update query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Execute update operation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    public int executeNativeUpdate(String sqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            Query query = em.createNativeQuery(sqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            int result = query.executeUpdate();&#10;            tx.commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to execute native update query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Execute native update operation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Batch insert entities for high performance&#10;     */&#10;    public &lt;T&gt; void batchInsert(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return;&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        repo.batchInsert(entities);&#10;    }&#10;&#10;    /**&#10;     * Batch update entities for high performance&#10;     */&#10;    public &lt;T&gt; void batchUpdate(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return;&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        repo.batchUpdate(entities);&#10;    }&#10;&#10;    /**&#10;     * Create database schema/tables&#10;     */&#10;    public void createSchema() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            // Schema creation is handled by JPA/Hibernate automatically&#10;            // based on the ddl-auto configuration&#10;            tx.commit();&#10;            logger.info(&quot;Database schema created/updated successfully&quot;);&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to create schema: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Schema creation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Drop all tables&#10;     */&#10;    public void dropSchema() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            em.createNativeQuery(&quot;DROP ALL OBJECTS&quot;).executeUpdate();&#10;            tx.commit();&#10;            logger.info(&quot;Database schema dropped successfully&quot;);&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to drop schema: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Schema drop failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get database version&#10;     */&#10;    public String getVersion() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(&quot;SELECT VERSION()&quot;);&#10;            Object result = query.getSingleResult();&#10;            return result != null ? result.toString() : &quot;Unknown&quot;;&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Could not retrieve database version: {}&quot;, e.getMessage());&#10;            return &quot;Unknown&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute custom SQL query and return raw results&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomQuery(String sqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            @SuppressWarnings(&quot;unchecked&quot;)&#10;            List&lt;Object[]&gt; results = query.getResultList();&#10;            return results;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to execute custom query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Custom query execution failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query and return raw results&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomJpql(String jpqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createQuery(jpqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            @SuppressWarnings(&quot;unchecked&quot;)&#10;            List&lt;Object[]&gt; results = query.getResultList();&#10;            return results;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to execute custom JPQL: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Custom JPQL execution failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown the database handler&#10;     */&#10;    public void shutdown() {&#10;        EntityManagerProvider.shutdown();&#10;        logger.info(&quot;JPA Advanced Database Handler shutdown completed&quot;);&#10;    }&#10;&#10;    /**&#10;     * Generic Repository Implementation&#10;     */&#10;    private static class GenericRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;&#10;        public GenericRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;&#10;        // getEntityClass() method is inherited from AbstractRepository&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import h2.orm.repository.AbstractRepository;&#10;import h2.orm.repository.Repository;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.Query;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Advanced JPA-based Database Handler for H2-ORM Standalone Library&#10; * High-performance replacement for traditional database handlers&#10; * Supports H2, MySQL, PostgreSQL, SQLite and other JPA-compatible databases&#10; */&#10;public class JpaAdvancedDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(JpaAdvancedDatabaseHandler.class);&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;    private final Map&lt;Class&lt;?&gt;, Repository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get or create repository for entity class&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T, ID extends Serializable&gt; Repository&lt;T, ID&gt; getRepository(Class&lt;T&gt; entityClass) {&#10;        return (Repository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, clazz -&gt;&#10;            new GenericRepository&lt;&gt;((Class&lt;T&gt;) clazz)&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            em.persist(entity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity saved: {}&quot;, entity.getClass().getSimpleName());&#10;            return entity;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Save all entities in batch&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        if (entities == null || entities.isEmpty()) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;            int batchSize = 20; // Default batch size&#10;            &#10;            for (int i = 0; i &lt; entities.size(); i++) {&#10;                T entity = entities.get(i);&#10;                em.persist(entity);&#10;                savedEntities.add(entity);&#10;                &#10;                if (i % batchSize == 0 &amp;&amp; i &gt; 0) {&#10;                    em.flush();&#10;                    em.clear();&#10;                }&#10;            }&#10;            &#10;            em.flush();&#10;            logger.debug(&quot;Batch saved {} entities&quot;, entities.size());&#10;            return savedEntities;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T updated = em.merge(entity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity updated: {}&quot;, entity.getClass().getSimpleName());&#10;            return updated;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Delete an entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;            em.remove(managedEntity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity deleted: {}&quot;, entity.getClass().getSimpleName());&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T entity = em.find(entityClass, id);&#10;            if (entity != null) {&#10;                em.remove(entity);&#10;                em.flush();&#10;                logger.debug(&quot;Entity deleted by ID: {} - {}&quot;, entityClass.getSimpleName(), id);&#10;            }&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            T entity = em.find(entityClass, id);&#10;            return Optional.ofNullable(entity);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find all entities of a given class&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(root);&#10;            &#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(root);&#10;            &#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            typedQuery.setFirstResult(offset);&#10;            typedQuery.setMaxResults(limit);&#10;            &#10;            return typedQuery.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Count entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;Long&gt; query = cb.createQuery(Long.class);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(cb.count(root));&#10;            &#10;            TypedQuery&lt;Long&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getSingleResult();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean exists(Class&lt;T&gt; entityClass, Object id) {&#10;        return findById(entityClass, id).isPresent();&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            TypedQuery&lt;T&gt; query = em.createQuery(jpql, resultClass);&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            TypedQuery&lt;T&gt; query = em.createQuery(jpql, resultClass);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sql, resultClass);&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query with parameters&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sql, resultClass);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute update query&#10;     */&#10;    public int executeUpdate(String jpql) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            Query query = em.createQuery(jpql);&#10;            return query.executeUpdate();&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute update query with parameters&#10;     */&#10;    public int executeUpdate(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            Query query = em.createQuery(jpql);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.executeUpdate();&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Clear entity manager cache&#10;     */&#10;    public void clearCache() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            em.clear();&#10;            logger.debug(&quot;Entity manager cache cleared&quot;);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Flush pending changes&#10;     */&#10;    public void flush() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            em.flush();&#10;            logger.debug(&quot;Entity manager flushed&quot;);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generic Repository Implementation&#10;     */&#10;    private static class GenericRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;        &#10;        public GenericRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;        &#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/ModernJpaDatabaseHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/ModernJpaDatabaseHandler.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import com.open.autobot.database.jpa.service.BackupService;&#10;import com.open.autobot.database.jpa.service.ChatService;&#10;import com.open.autobot.database.jpa.service.ExportService;&#10;import com.open.autobot.model.Conversation;&#10;import com.open.autobot.model.Message;&#10;import com.open.autobot.model.SenderRole;&#10;import jakarta.persistence.EntityManager;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Modern JPA Advanced Database Handler&#10; *&#10; * A complete replacement for H2DatabaseHandler with modern JPA architecture&#10; * Features:&#10; * - High-performance JPA operations with connection pooling&#10; * - Support for H2, MySQL, PostgreSQL, SQLite&#10; * - Comprehensive CRUD operations&#10; * - Chat system with conversations and messages&#10; * - Backup and restore functionality&#10; * - Export to CSV, Excel, JSON&#10; * - Batch operations for optimal performance&#10; * - Transaction management&#10; * - Query caching and optimization&#10; *&#10; * Usage:&#10; * 1. Initialize with database configuration&#10; * 2. Use save(), findAll(), findById() etc. for basic operations&#10; * 3. Use chat methods for conversation management&#10; * 4. Use backup methods for data protection&#10; * 5. Use export methods for data analysis&#10; */&#10;public class ModernJpaDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(ModernJpaDatabaseHandler.class);&#10;&#10;    private final JpaAdvancedDatabaseHandler coreHandler;&#10;    private final ChatService chatService;&#10;    private final BackupService backupService;&#10;    private final ExportService exportService;&#10;&#10;    /**&#10;     * Constructor - Initialize with H2 database (default)&#10;     */&#10;    public ModernJpaDatabaseHandler() {&#10;        this(DatabaseConfig.h2());&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with custom database configuration&#10;     */&#10;    public ModernJpaDatabaseHandler(DatabaseConfig config) {&#10;        this.coreHandler = new JpaAdvancedDatabaseHandler();&#10;        this.chatService = new ChatService();&#10;        this.backupService = new BackupService();&#10;        this.exportService = new ExportService();&#10;&#10;        // Initialize the database&#10;        this.coreHandler.initialize(config);&#10;&#10;        logger.info(&quot;Modern JPA Database Handler initialized with {}&quot;,&#10;                   config.getUrl().contains(&quot;h2&quot;) ? &quot;H2&quot; :&#10;                   config.getUrl().contains(&quot;mysql&quot;) ? &quot;MySQL&quot; :&#10;                   config.getUrl().contains(&quot;postgresql&quot;) ? &quot;PostgreSQL&quot; : &quot;Other database&quot;);&#10;    }&#10;&#10;    // =====================&#10;    // CORE CRUD OPERATIONS&#10;    // =====================&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return coreHandler.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save multiple entities with batch optimization&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        return coreHandler.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.findById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.findAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination (high performance for large datasets)&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        return coreHandler.findAll(entityClass, offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByAttribute(Class&lt;T&gt; entityClass, String attributeName, Object value) {&#10;        return coreHandler.findByAttribute(entityClass, attributeName, value);&#10;    }&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        return coreHandler.findByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByNativeQuery(Class&lt;T&gt; entityClass, String sqlQuery, Object... params) {&#10;        return coreHandler.findByNativeQuery(entityClass, sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByQuery(Class&lt;T&gt; entityClass, String jpqlQuery, Object... params) {&#10;        return coreHandler.findByQuery(entityClass, jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.count(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean existsById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.existsById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    public &lt;T&gt; boolean existsByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        return coreHandler.existsByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return coreHandler.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        coreHandler.deleteById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        coreHandler.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete all entities of a type&#10;     */&#10;    public &lt;T&gt; void deleteAll(Class&lt;T&gt; entityClass) {&#10;        coreHandler.deleteAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    public &lt;T&gt; void deleteByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        coreHandler.deleteByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Batch insert for high performance&#10;     */&#10;    public &lt;T&gt; void batchInsert(List&lt;T&gt; entities) {&#10;        coreHandler.batchInsert(entities);&#10;    }&#10;&#10;    /**&#10;     * Batch update for high performance&#10;     */&#10;    public &lt;T&gt; void batchUpdate(List&lt;T&gt; entities) {&#10;        coreHandler.batchUpdate(entities);&#10;    }&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    public int executeUpdate(String jpqlQuery, Object... params) {&#10;        return coreHandler.executeUpdate(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    public int executeNativeUpdate(String sqlQuery, Object... params) {&#10;        return coreHandler.executeNativeUpdate(sqlQuery, params);&#10;    }&#10;&#10;    // =====================&#10;    // CHAT SYSTEM METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Initialize chat system (called automatically)&#10;     */&#10;    public void initializeChatTables() {&#10;        chatService.initializeChatTables();&#10;    }&#10;&#10;    /**&#10;     * Start a new conversation&#10;     */&#10;    public String startNewConversation(String userId, String title) {&#10;        return chatService.startNewConversation(userId, title);&#10;    }&#10;&#10;    /**&#10;     * Add message to conversation&#10;     */&#10;    public void addMessage(String conversationId, SenderRole role, String content) {&#10;        chatService.addMessage(conversationId, role, content);&#10;    }&#10;&#10;    /**&#10;     * Get conversation history&#10;     */&#10;    public List&lt;Message&gt; getConversationHistory(String conversationId) {&#10;        return chatService.getConversationHistory(conversationId);&#10;    }&#10;&#10;    /**&#10;     * List user conversations&#10;     */&#10;    public List&lt;Conversation&gt; listUserConversations(String userId) {&#10;        return chatService.listUserConversations(userId);&#10;    }&#10;&#10;    /**&#10;     * Rename conversation&#10;     */&#10;    public void renameConversation(String conversationId, String newTitle) {&#10;        chatService.renameConversation(conversationId, newTitle);&#10;    }&#10;&#10;    /**&#10;     * Delete conversation&#10;     */&#10;    public void deleteConversation(String conversationId) {&#10;        chatService.deleteConversation(conversationId);&#10;    }&#10;&#10;    /**&#10;     * Add simple chat message (legacy compatibility)&#10;     */&#10;    public void addChatMessage(String message) {&#10;        chatService.addChatMessage(message);&#10;    }&#10;&#10;    /**&#10;     * Load simple chat history (legacy compatibility)&#10;     */&#10;    public List&lt;String&gt; loadChatHistory() {&#10;        return chatService.loadChatHistory();&#10;    }&#10;&#10;    /**&#10;     * Clear simple chat history (legacy compatibility)&#10;     */&#10;    public void clearChatHistory() {&#10;        chatService.clearChatHistory();&#10;    }&#10;&#10;    // =====================&#10;    // BACKUP &amp; RESTORE METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Create backup of a table&#10;     */&#10;    public String backup(String tableName) {&#10;        return backupService.backup(tableName);&#10;    }&#10;&#10;    /**&#10;     * Create backup of all tables&#10;     */&#10;    public List&lt;String&gt; backupAll() {&#10;        return backupService.backupAll();&#10;    }&#10;&#10;    /**&#10;     * List backup tables&#10;     */&#10;    public List&lt;String&gt; listBackups(String baseTableName) {&#10;        return backupService.listBackups(baseTableName);&#10;    }&#10;&#10;    /**&#10;     * Restore table from backup&#10;     */&#10;    public boolean restore(String backupTableName, String targetTableName) {&#10;        return backupService.restore(backupTableName, targetTableName);&#10;    }&#10;&#10;    /**&#10;     * Delete backup table&#10;     */&#10;    public boolean deleteBackup(String backupTableName) {&#10;        return backupService.deleteBackup(backupTableName);&#10;    }&#10;&#10;    /**&#10;     * Schedule periodic backup&#10;     */&#10;    public void schedulePeriodicBackup(String tableName, long intervalMinutes) {&#10;        backupService.schedulePeriodicBackup(tableName, intervalMinutes);&#10;    }&#10;&#10;    /**&#10;     * Schedule periodic backup for all tables&#10;     */&#10;    public void schedulePeriodicBackupAll(long intervalMinutes) {&#10;        backupService.schedulePeriodicBackupAll(intervalMinutes);&#10;    }&#10;&#10;    /**&#10;     * Create database dump&#10;     */&#10;    public String createDatabaseDump(String filePath) {&#10;        return backupService.createDatabaseDump(filePath);&#10;    }&#10;&#10;    /**&#10;     * Restore from database dump&#10;     */&#10;    public boolean restoreFromDump(String filePath) {&#10;        return backupService.restoreFromDump(filePath);&#10;    }&#10;&#10;    // =====================&#10;    // EXPORT METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Export table to CSV&#10;     */&#10;    public void exportToCSV(String tableName, String filePath) {&#10;        exportService.exportToCSV(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export table to Excel&#10;     */&#10;    public void exportToExcel(String tableName, String filePath) {&#10;        exportService.exportToExcel(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export table to JSON&#10;     */&#10;    public void exportToJSON(String tableName, String filePath) {&#10;        exportService.exportToJSON(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export query results to CSV&#10;     */&#10;    public void exportQueryToCSV(String sqlQuery, String filePath, Object... params) {&#10;        exportService.exportQueryToCSV(sqlQuery, filePath, params);&#10;    }&#10;&#10;    /**&#10;     * Export multiple tables to Excel&#10;     */&#10;    public void exportMultipleTablesToExcel(List&lt;String&gt; tableNames, String filePath) {&#10;        exportService.exportMultipleTablesToExcel(tableNames, filePath);&#10;    }&#10;&#10;    /**&#10;     * Get database statistics&#10;     */&#10;    public Map&lt;String, Object&gt; getDatabaseStatistics() {&#10;        return exportService.getDatabaseStatistics();&#10;    }&#10;&#10;    /**&#10;     * Export database statistics to JSON&#10;     */&#10;    public void exportStatisticsToJSON(String filePath) {&#10;        exportService.exportStatisticsToJSON(filePath);&#10;    }&#10;&#10;    // =====================&#10;    // UTILITY METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Get database version&#10;     */&#10;    public String getVersion() {&#10;        return coreHandler.getVersion();&#10;    }&#10;&#10;    /**&#10;     * Execute custom SQL query&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomQuery(String sqlQuery, Object... params) {&#10;        return coreHandler.executeCustomQuery(sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomJpql(String jpqlQuery, Object... params) {&#10;        return coreHandler.executeCustomJpql(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for advanced operations&#10;     */&#10;    public EntityManager getEntityManager() {&#10;        return EntityManagerProvider.getEntityManager();&#10;    }&#10;&#10;    /**&#10;     * Close current EntityManager&#10;     */&#10;    public void closeEntityManager() {&#10;        EntityManagerProvider.closeEntityManager();&#10;    }&#10;&#10;    /**&#10;     * Create database schema&#10;     */&#10;    public void createSchema() {&#10;        coreHandler.createSchema();&#10;    }&#10;&#10;    /**&#10;     * Drop database schema&#10;     */&#10;    public void dropSchema() {&#10;        coreHandler.dropSchema();&#10;    }&#10;&#10;    /**&#10;     * Shutdown the database handler&#10;     */&#10;    public void shutdown() {&#10;        try {&#10;            backupService.shutdown();&#10;            coreHandler.shutdown();&#10;            logger.info(&quot;Modern JPA Database Handler shutdown completed&quot;);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error during shutdown: {}&quot;, e.getMessage());&#10;        }&#10;    }&#10;&#10;    // =====================&#10;    // FACTORY METHODS FOR DIFFERENT DATABASES&#10;    // =====================&#10;&#10;    /**&#10;     * Create handler for H2 database&#10;     */&#10;    public static ModernJpaDatabaseHandler forH2() {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.h2());&#10;    }&#10;&#10;    /**&#10;     * Create handler for MySQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler forMySQL(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.mysql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Create handler for PostgreSQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler forPostgreSQL(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.postgresql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Create handler for SQLite database&#10;     */&#10;    public static ModernJpaDatabaseHandler forSQLite(String filePath) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.sqlite(filePath));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.service.BackupService;&#10;import h2.orm.service.ExportService;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.function.Consumer;&#10;&#10;/**&#10; * Modern JPA Database Handler for H2-ORM Standalone Library&#10; *&#10; * A complete JPA-based database handler with modern architecture&#10; * Features:&#10; * - High-performance JPA operations with connection pooling&#10; * - Support for H2, MySQL, PostgreSQL, SQLite&#10; * - Comprehensive CRUD operations&#10; * - Backup and restore functionality&#10; * - Export to CSV, Excel, JSON&#10; * - Batch operations for optimal performance&#10; * - Transaction management&#10; * - Query caching and optimization&#10; * - Easy integration as standalone library&#10; *&#10; * Usage:&#10; * 1. Initialize with database configuration&#10; * 2. Use save(), findAll(), findById() etc. for basic operations&#10; * 3. Use backup methods for data protection&#10; * 4. Use export methods for data analysis&#10; */&#10;public class ModernJpaDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(ModernJpaDatabaseHandler.class);&#10;&#10;    private final JpaAdvancedDatabaseHandler coreHandler;&#10;    private final BackupService backupService;&#10;    private final ExportService exportService;&#10;    private final DatabaseConfiguration configuration;&#10;&#10;    /**&#10;     * Constructor - Initialize with default H2 configuration&#10;     */&#10;    public ModernJpaDatabaseHandler() {&#10;        this(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with H2 file-based database&#10;     */&#10;    public ModernJpaDatabaseHandler(String databasePath) {&#10;        this(DatabaseConfiguration.h2File(databasePath));&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with custom configuration&#10;     */&#10;    public ModernJpaDatabaseHandler(DatabaseConfiguration config) {&#10;        this.configuration = config;&#10;&#10;        logger.info(&quot;Initializing ModernJpaDatabaseHandler with configuration: {}&quot;, config);&#10;&#10;        // Initialize EntityManager Provider&#10;        EntityManagerProvider.initialize(config);&#10;&#10;        // Initialize core components&#10;        this.coreHandler = new JpaAdvancedDatabaseHandler();&#10;        this.backupService = new BackupService();&#10;        this.exportService = new ExportService();&#10;&#10;        logger.info(&quot;ModernJpaDatabaseHandler initialized successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Factory method for H2 in-memory database&#10;     */&#10;    public static ModernJpaDatabaseHandler h2InMemory() {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Factory method for H2 file-based database&#10;     */&#10;    public static ModernJpaDatabaseHandler h2File(String path) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.h2File(path));&#10;    }&#10;&#10;    /**&#10;     * Factory method for SQLite database&#10;     */&#10;    public static ModernJpaDatabaseHandler sqlite(String path) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.sqlite(path));&#10;    }&#10;&#10;    /**&#10;     * Factory method for MySQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler mysql(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.mysql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Factory method for PostgreSQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler postgresql(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.postgresql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Factory method from properties file&#10;     */&#10;    public static ModernJpaDatabaseHandler fromProperties(String propertiesFile) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.fromPropertiesFile(propertiesFile));&#10;    }&#10;&#10;    // ===== CRUD Operations =====&#10;&#10;    /**&#10;     * Save entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return coreHandler.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save entity with validation&#10;     */&#10;    public &lt;T&gt; T save(T entity, Consumer&lt;T&gt; validator) {&#10;        if (validator != null) {&#10;            validator.accept(entity);&#10;        }&#10;        return save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        return coreHandler.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Update entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return coreHandler.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        coreHandler.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        coreHandler.deleteById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.findById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.findAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Find with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        return coreHandler.findAll(entityClass, offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Count entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.count(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists&#10;     */&#10;    public &lt;T&gt; boolean exists(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.exists(entityClass, id);&#10;    }&#10;&#10;    // ===== Query Operations =====&#10;&#10;    /**&#10;     * Execute JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass) {&#10;        return coreHandler.query(jpql, resultClass);&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.query(jpql, resultClass, parameters);&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass) {&#10;        return coreHandler.nativeQuery(sql, resultClass);&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.nativeQuery(sql, resultClass, parameters);&#10;    }&#10;&#10;    /**&#10;     * Execute update query&#10;     */&#10;    public int executeUpdate(String jpql) {&#10;        return coreHandler.executeUpdate(jpql);&#10;    }&#10;&#10;    /**&#10;     * Execute update query with parameters&#10;     */&#10;    public int executeUpdate(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.executeUpdate(jpql, parameters);&#10;    }&#10;&#10;    // ===== Criteria API =====&#10;&#10;    /**&#10;     * Create criteria query builder&#10;     */&#10;    public &lt;T&gt; CriteriaQueryBuilder&lt;T&gt; criteriaBuilder(Class&lt;T&gt; entityClass) {&#10;        return new CriteriaQueryBuilder&lt;&gt;(entityClass);&#10;    }&#10;&#10;    // ===== Transaction Management =====&#10;&#10;    /**&#10;     * Execute in transaction&#10;     */&#10;    public &lt;T&gt; T executeInTransaction(EntityManagerProvider.TransactionCallback&lt;T&gt; callback) {&#10;        return EntityManagerProvider.executeInTransaction(callback);&#10;    }&#10;&#10;    /**&#10;     * Execute without result in transaction&#10;     */&#10;    public void executeInTransaction(TransactionCallback callback) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            callback.execute(em);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    // ===== Export Operations =====&#10;&#10;    /**&#10;     * Export to CSV&#10;     */&#10;    public &lt;T&gt; void exportToCsv(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToCsv(data, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export to Excel&#10;     */&#10;    public &lt;T&gt; void exportToExcel(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToExcel(data, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export to JSON&#10;     */&#10;    public &lt;T&gt; void exportToJson(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToJson(data, filePath);&#10;    }&#10;&#10;    // ===== Backup Operations =====&#10;&#10;    /**&#10;     * Create database backup&#10;     */&#10;    public void backup(String backupPath) {&#10;        backupService.createBackup(backupPath);&#10;    }&#10;&#10;    /**&#10;     * Restore database from backup&#10;     */&#10;    public void restore(String backupPath) {&#10;        backupService.restoreBackup(backupPath);&#10;    }&#10;&#10;    // ===== Utility Methods =====&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public DatabaseConfiguration getConfiguration() {&#10;        return configuration;&#10;    }&#10;&#10;    /**&#10;     * Check if handler is initialized&#10;     */&#10;    public boolean isInitialized() {&#10;        return EntityManagerProvider.isInitialized();&#10;    }&#10;&#10;    /**&#10;     * Shutdown handler and cleanup resources&#10;     */&#10;    public void shutdown() {&#10;        logger.info(&quot;Shutting down ModernJpaDatabaseHandler&quot;);&#10;        EntityManagerProvider.shutdown();&#10;        logger.info(&quot;ModernJpaDatabaseHandler shutdown completed&quot;);&#10;    }&#10;&#10;    // ===== Inner Classes =====&#10;&#10;    /**&#10;     * Criteria Query Builder for type-safe queries&#10;     */&#10;    public class CriteriaQueryBuilder&lt;T&gt; {&#10;        private final Class&lt;T&gt; entityClass;&#10;        private final CriteriaBuilder criteriaBuilder;&#10;        private final CriteriaQuery&lt;T&gt; query;&#10;        private final Root&lt;T&gt; root;&#10;&#10;        public CriteriaQueryBuilder(Class&lt;T&gt; entityClass) {&#10;            this.entityClass = entityClass;&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            this.criteriaBuilder = em.getCriteriaBuilder();&#10;            this.query = criteriaBuilder.createQuery(entityClass);&#10;            this.root = query.from(entityClass);&#10;        }&#10;&#10;        public CriteriaQueryBuilder&lt;T&gt; where(String fieldName, Object value) {&#10;            query.where(criteriaBuilder.equal(root.get(fieldName), value));&#10;            return this;&#10;        }&#10;&#10;        public CriteriaQueryBuilder&lt;T&gt; orderBy(String fieldName, boolean ascending) {&#10;            if (ascending) {&#10;                query.orderBy(criteriaBuilder.asc(root.get(fieldName)));&#10;            } else {&#10;                query.orderBy(criteriaBuilder.desc(root.get(fieldName)));&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public List&lt;T&gt; getResultList() {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getResultList();&#10;        }&#10;&#10;        public List&lt;T&gt; getResultList(int maxResults) {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            typedQuery.setMaxResults(maxResults);&#10;            return typedQuery.getResultList();&#10;        }&#10;&#10;        public Optional&lt;T&gt; getSingleResult() {&#10;            List&lt;T&gt; results = getResultList(1);&#10;            return results.isEmpty() ? Optional.empty() : Optional.of(results.get(0));&#10;        }&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface TransactionCallback {&#10;        void execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/H2OrmExceptions.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/H2OrmExceptions.java" />
              <option name="updatedContent" value="package h2.orm.exception;&#10;&#10;/**&#10; * Exception thrown when database is not initialized&#10; */&#10;public class DatabaseNotInitializedException extends H2OrmException {&#10;    &#10;    public DatabaseNotInitializedException() {&#10;        super(&#10;            &quot;Database not initialized&quot;,&#10;            &quot;The H2-ORM database connection has not been initialized yet.&quot;,&#10;            &quot;Call EntityManagerProvider.initialize() before using repositories.&quot;&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when transaction is required but not active&#10; */&#10;class TransactionRequiredException extends H2OrmException {&#10;    &#10;    public TransactionRequiredException(String operation) {&#10;        super(&#10;            &quot;Transaction required for operation: &quot; + operation,&#10;            &quot;The operation '&quot; + operation + &quot;' requires an active transaction.&quot;,&#10;            &quot;This operation will be automatically wrapped in a transaction.&quot;&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when entity operation fails&#10; */&#10;class EntityOperationException extends H2OrmException {&#10;    &#10;    public EntityOperationException(String operation, Throwable cause) {&#10;        super(&#10;            &quot;Entity operation failed: &quot; + operation,&#10;            &quot;Failed to &quot; + operation.toLowerCase() + &quot; entity.&quot;,&#10;            &quot;Check if the entity is valid and database connection is working.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when unique constraint is violated&#10; */&#10;class UniqueConstraintException extends H2OrmException {&#10;    &#10;    public UniqueConstraintException(String field, Object value, Throwable cause) {&#10;        super(&#10;            &quot;Unique constraint violation&quot;,&#10;            &quot;A record with &quot; + field + &quot; = '&quot; + value + &quot;' already exists.&quot;,&#10;            &quot;Use a different value for &quot; + field + &quot; or update the existing record.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when configuration is invalid&#10; */&#10;class ConfigurationException extends H2OrmException {&#10;    &#10;    public ConfigurationException(String message, String suggestion) {&#10;        super(&#10;            &quot;Configuration error&quot;,&#10;            message,&#10;            suggestion&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when repository operation fails&#10; */&#10;class RepositoryException extends H2OrmException {&#10;    &#10;    public RepositoryException(String operation, Throwable cause) {&#10;        super(&#10;            &quot;Repository operation failed: &quot; + operation,&#10;            &quot;Failed to execute repository operation: &quot; + operation,&#10;            &quot;Check your entity configuration and database connection.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/package-info.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/package-info.java" />
              <option name="originalContent" value="/**&#10; * H2-ORM Main API Package&#10; *&#10; * &lt;p&gt;This package contains the main entry point and primary API for the H2-ORM library.&#10; * The library provides a Spring Boot-style ORM experience with automatic repository generation,&#10; * transaction management, and backup/export capabilities.&lt;/p&gt;&#10; *&#10; * &lt;h2&gt;Quick Start Example:&lt;/h2&gt;&#10; * &lt;pre&gt;{@code&#10; * // 1. Start the database&#10; * H2ORM.start(&quot;./data/myapp&quot;);&#10; *&#10; * // 2. Get repository (like Spring Boot @Autowired)&#10; * JpaRepository&lt;User, Long&gt; userRepo = H2ORM.repository(User.class);&#10; *&#10; * // 3. Use repository methods&#10; * User user = userRepo.save(new User(&quot;john&quot;, &quot;john@example.com&quot;));&#10; * List&lt;User&gt; users = userRepo.findAll();&#10; *&#10; * // 4. Export and backup&#10; * H2ORM.exportToCsv(User.class, &quot;./exports/users.csv&quot;);&#10; * H2ORM.backup(&quot;./backups/myapp_backup&quot;);&#10; *&#10; * // 5. Clean shutdown&#10; * H2ORM.stop();&#10; * }&lt;/pre&gt;&#10; *&#10; * &lt;h2&gt;Main Classes:&lt;/h2&gt;&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;{@link h2.orm.H2ORM} - Main entry point and API facade&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @author H2-ORM Team&#10; * @version 1.0.0&#10; * @since 1.0.0&#10; */&#10;@javax.annotation.ParametersAreNonnullByDefault&#10;package h2.orm;&#10;&#10;" />
              <option name="updatedContent" value="/**&#10; * H2-ORM Main API Package&#10; *&#10; * &lt;p&gt;This package contains the main entry point and primary API for the H2-ORM library.&#10; * The library provides a Spring Boot-style ORM experience with automatic repository generation,&#10; * transaction management, and backup/export capabilities.&lt;/p&gt;&#10; *&#10; * &lt;h2&gt;Quick Start Example:&lt;/h2&gt;&#10; * &lt;pre&gt;{@code&#10; * // 1. Start the database&#10; * H2ORM.start(&quot;./data/myapp&quot;);&#10; *&#10; * // 2. Get repository (like Spring Boot @Autowired)&#10; * JpaRepository&lt;User, Long&gt; userRepo = H2ORM.repository(User.class);&#10; *&#10; * // 3. Use repository methods&#10; * User user = userRepo.save(new User(&quot;john&quot;, &quot;john@example.com&quot;));&#10; * List&lt;User&gt; users = userRepo.findAll();&#10; *&#10; * // 4. Export and backup&#10; * H2ORM.exportToCsv(User.class, &quot;./exports/users.csv&quot;);&#10; * H2ORM.backup(&quot;./backups/myapp_backup&quot;);&#10; *&#10; * // 5. Clean shutdown&#10; * H2ORM.stop();&#10; * }&lt;/pre&gt;&#10; *&#10; * &lt;h2&gt;Main Classes:&lt;/h2&gt;&#10; * &lt;ul&gt;&#10; *   &lt;li&gt;{@link h2.orm.H2ORM} - Main entry point and API facade&lt;/li&gt;&#10; * &lt;/ul&gt;&#10; *&#10; * @author H2-ORM Team&#10; * @version 1.0.0&#10; * @since 1.0.0&#10; */&#10;package h2.orm;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/AbstractRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/AbstractRepository.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import h2.orm.core.MetadataManager;&#10;import h2.orm.core.TransactionManager;&#10;import h2.orm.exception.ExceptionHandler;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.lang.reflect.ParameterizedType;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Abstract JPA Repository implementation similar to Spring Data JPA&#10; * Provides automatic implementation of all repository methods with comprehensive exception handling&#10; * Now uses core classes for better performance and reliability&#10; */&#10;public abstract class AbstractRepository&lt;T, ID extends Serializable&gt; implements JpaRepository&lt;T, ID&gt; {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(AbstractRepository.class);&#10;&#10;    protected final Class&lt;T&gt; entityClass;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public AbstractRepository() {&#10;        this.entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass().getGenericSuperclass())&#10;                .getActualTypeArguments()[0];&#10;    }&#10;&#10;    protected AbstractRepository(Class&lt;T&gt; entityClass) {&#10;        this.entityClass = entityClass;&#10;    }&#10;&#10;    protected abstract EntityManager getEntityManager();&#10;&#10;    @Override&#10;    public T save(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                // Use MetadataManager for entity state detection&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    return entity;&#10;                } else {&#10;                    return em.merge(entity);&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                int batchSize = 20;&#10;                int count = 0;&#10;&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;&#10;                    if (++count % batchSize == 0) {&#10;                        em.flush();&#10;                        em.clear();&#10;                    }&#10;                }&#10;&#10;                em.flush(); // Final flush&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;T&gt; findById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;find entity by ID&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                T entity = em.find(entityClass, id);&#10;                return Optional.ofNullable(entity);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public boolean existsById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;check entity exists&quot;, () -&gt; {&#10;            return findById(id).isPresent();&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAll() {&#10;        return ExceptionHandler.safeExecute(&quot;find all entities&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                CriteriaBuilder cb = em.getCriteriaBuilder();&#10;                CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;                Root&lt;T&gt; root = query.from(entityClass);&#10;                query.select(root);&#10;&#10;                TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;                return typedQuery.getResultList();&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities by IDs&quot;, () -&gt; {&#10;            List&lt;T&gt; result = new ArrayList&lt;&gt;();&#10;            for (ID id : ids) {&#10;                findById(id).ifPresent(result::add);&#10;            }&#10;            return result;&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public long count() {&#10;        return ExceptionHandler.safeExecute(&quot;count entities&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                CriteriaBuilder cb = em.getCriteriaBuilder();&#10;                CriteriaQuery&lt;Long&gt; query = cb.createQuery(Long.class);&#10;                Root&lt;T&gt; root = query.from(entityClass);&#10;                query.select(cb.count(root));&#10;&#10;                TypedQuery&lt;Long&gt; typedQuery = em.createQuery(query);&#10;                return typedQuery.getSingleResult();&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteById(ID id) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity by ID&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T entity = em.find(entityClass, id);&#10;                if (entity != null) {&#10;                    em.remove(entity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void delete(T entity) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                em.remove(managedEntity);&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllById(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;                ids.forEach(idList::add);&#10;&#10;                if (!idList.isEmpty()) {&#10;                    String tableName = MetadataManager.getTableName(entityClass);&#10;                    em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;)&#10;                            .setParameter(&quot;ids&quot;, idList)&#10;                            .executeUpdate();&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName()).executeUpdate();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void flush() {&#10;        ExceptionHandler.safeExecute(&quot;flush changes&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.flush();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T saveAndFlush(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save and flush entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                T savedEntity;&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    savedEntity = entity;&#10;                } else {&#10;                    savedEntity = em.merge(entity);&#10;                }&#10;                em.flush();&#10;                return savedEntity;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all and flush entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;                }&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteInBatch(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllInBatch() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName()).executeUpdate();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;                ids.forEach(idList::add);&#10;&#10;                if (!idList.isEmpty()) {&#10;                    em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;)&#10;                            .setParameter(&quot;ids&quot;, idList)&#10;                            .executeUpdate();&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getOne(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;get entity reference&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                return em.getReference(entityClass, id);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getReferenceById(ID id) {&#10;        return getOne(id);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import h2.orm.core.MetadataManager;&#10;import h2.orm.core.QueryExecutor;&#10;import h2.orm.core.TransactionManager;&#10;import h2.orm.exception.ExceptionHandler;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.lang.reflect.ParameterizedType;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Abstract JPA Repository implementation similar to Spring Data JPA&#10; * Now uses QueryExecutor for optimized query performance&#10; */&#10;public abstract class AbstractRepository&lt;T, ID extends Serializable&gt; implements JpaRepository&lt;T, ID&gt; {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(AbstractRepository.class);&#10;&#10;    protected final Class&lt;T&gt; entityClass;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public AbstractRepository() {&#10;        this.entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass().getGenericSuperclass())&#10;                .getActualTypeArguments()[0];&#10;    }&#10;&#10;    protected AbstractRepository(Class&lt;T&gt; entityClass) {&#10;        this.entityClass = entityClass;&#10;    }&#10;&#10;    protected abstract EntityManager getEntityManager();&#10;&#10;    @Override&#10;    public T save(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    return entity;&#10;                } else {&#10;                    return em.merge(entity);&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                int batchSize = 20;&#10;                int count = 0;&#10;&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;&#10;                    if (++count % batchSize == 0) {&#10;                        em.flush();&#10;                        em.clear();&#10;                    }&#10;                }&#10;&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;T&gt; findById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;find entity by ID&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                T entity = em.find(entityClass, id);&#10;                return Optional.ofNullable(entity);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public boolean existsById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;check entity exists&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized exists check&#10;            String jpql = &quot;SELECT COUNT(e) FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id = :id&quot;;&#10;            Long count = QueryExecutor.executeSingleResultQuery(jpql, Long.class, Map.of(&quot;id&quot;, id));&#10;            return count &gt; 0;&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAll() {&#10;        return ExceptionHandler.safeExecute(&quot;find all entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized query execution&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executeQuery(jpql, entityClass);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities by IDs&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;            &#10;            if (idList.isEmpty()) {&#10;                return new ArrayList&lt;&gt;();&#10;            }&#10;            &#10;            // Use QueryExecutor for batch ID lookup&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;            return QueryExecutor.executeQuery(jpql, entityClass, Map.of(&quot;ids&quot;, idList));&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public long count() {&#10;        return ExceptionHandler.safeExecute(&quot;count entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized count query&#10;            String jpql = &quot;SELECT COUNT(e) FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executeSingleResultQuery(jpql, Long.class);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteById(ID id) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity by ID&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id = :id&quot;;&#10;            QueryExecutor.executeUpdate(jpql, Map.of(&quot;id&quot;, id));&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void delete(T entity) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                em.remove(managedEntity);&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllById(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;&#10;            if (!idList.isEmpty()) {&#10;                // Use QueryExecutor for batch delete&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, idList));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized bulk delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName();&#10;            QueryExecutor.executeUpdate(jpql);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void flush() {&#10;        ExceptionHandler.safeExecute(&quot;flush changes&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.flush();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T saveAndFlush(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save and flush entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                T savedEntity;&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    savedEntity = entity;&#10;                } else {&#10;                    savedEntity = em.merge(entity);&#10;                }&#10;                em.flush();&#10;                return savedEntity;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all and flush entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;                }&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteInBatch(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities in batch&quot;, () -&gt; {&#10;            // Extract IDs and use QueryExecutor for batch delete&#10;            List&lt;ID&gt; ids = new ArrayList&lt;&gt;();&#10;            for (T entity : entities) {&#10;                @SuppressWarnings(&quot;unchecked&quot;)&#10;                ID id = (ID) MetadataManager.getIdValue(entity);&#10;                if (id != null) {&#10;                    ids.add(id);&#10;                }&#10;            }&#10;            &#10;            if (!ids.isEmpty()) {&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, ids));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllInBatch() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities in batch&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized bulk delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName();&#10;            QueryExecutor.executeUpdate(jpql);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs in batch&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;&#10;            if (!idList.isEmpty()) {&#10;                // Use QueryExecutor for batch delete&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, idList));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getOne(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;get entity reference&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                return em.getReference(entityClass, id);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getReferenceById(ID id) {&#10;        return getOne(id);&#10;    }&#10;&#10;    // Additional utility methods using QueryExecutor&#10;&#10;    /**&#10;     * Find entities with pagination using QueryExecutor&#10;     */&#10;    public List&lt;T&gt; findAll(int offset, int limit) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities with pagination&quot;, () -&gt; {&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executePaginatedQuery(jpql, entityClass, null, offset, limit);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query&#10;     */&#10;    public List&lt;T&gt; findByJpql(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return ExceptionHandler.safeExecute(&quot;execute custom JPQL query&quot;, () -&gt; {&#10;            return QueryExecutor.executeQuery(jpql, entityClass, parameters);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute custom native SQL query&#10;     */&#10;    public List&lt;T&gt; findByNativeQuery(String sql, Map&lt;String, Object&gt; parameters) {&#10;        return ExceptionHandler.safeExecute(&quot;execute custom native query&quot;, () -&gt; {&#10;            return QueryExecutor.executeNativeQuery(sql, entityClass, parameters);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/JpaRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/JpaRepository.java" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;&#10;/**&#10; * JPA Repository interface similar to Spring Data JPA&#10; * Extends base Repository with additional JPA-specific methods&#10; */&#10;public interface JpaRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; {&#10;    &#10;    /**&#10;     * Flush changes to database&#10;     */&#10;    void flush();&#10;    &#10;    /**&#10;     * Save and flush entity&#10;     */&#10;    T saveAndFlush(T entity);&#10;    &#10;    /**&#10;     * Save all and flush entities&#10;     */&#10;    List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete entities in batch&#10;     */&#10;    void deleteInBatch(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete all entities in batch&#10;     */&#10;    void deleteAllInBatch();&#10;    &#10;    /**&#10;     * Delete all entities in batch by IDs&#10;     */&#10;    void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Get reference to entity (lazy loading)&#10;     */&#10;    T getOne(ID id);&#10;    &#10;    /**&#10;     * Get reference to entity (lazy loading) - JPA 3.0 style&#10;     */&#10;    T getReferenceById(ID id);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repositories.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repositories.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import jakarta.persistence.EntityManager;&#10;&#10;import java.io.Serializable;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Repository factory that creates JPA repositories automatically&#10; * Works exactly like Spring Data JPA - just call Repositories.of(EntityClass.class)&#10; */&#10;public class Repositories {&#10;&#10;    private static final Map&lt;Class&lt;?&gt;, JpaRepository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get repository for entity class - creates it automatically if needed&#10;     * Usage: UserRepository userRepo = Repositories.of(User.class);&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;T, ID extends Serializable&gt; JpaRepository&lt;T, ID&gt; of(Class&lt;T&gt; entityClass) {&#10;        return (JpaRepository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass,&#10;            clazz -&gt; new SimpleJpaRepository&lt;&gt;((Class&lt;T&gt;) clazz));&#10;    }&#10;&#10;    /**&#10;     * Clear repository cache&#10;     */&#10;    public static void clearCache() {&#10;        repositoryCache.clear();&#10;    }&#10;&#10;    /**&#10;     * Simple JPA Repository implementation&#10;     */&#10;    private static class SimpleJpaRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;&#10;        public SimpleJpaRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;&#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import jakarta.persistence.EntityManager;&#10;&#10;import java.io.Serializable;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Repository factory that creates JPA repositories automatically&#10; * Works exactly like Spring Data JPA - just call Repositories.of(EntityClass.class)&#10; * Now uses core EntityManagerProvider for better performance&#10; */&#10;public class Repositories {&#10;    &#10;    private static final Map&lt;Class&lt;?&gt;, JpaRepository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;    &#10;    /**&#10;     * Get repository for entity class - creates it automatically if needed&#10;     * Usage: UserRepository userRepo = Repositories.of(User.class);&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;T, ID extends Serializable&gt; JpaRepository&lt;T, ID&gt; of(Class&lt;T&gt; entityClass) {&#10;        return (JpaRepository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, &#10;            clazz -&gt; new SimpleJpaRepository&lt;&gt;((Class&lt;T&gt;) clazz));&#10;    }&#10;    &#10;    /**&#10;     * Clear repository cache&#10;     */&#10;    public static void clearCache() {&#10;        repositoryCache.clear();&#10;    }&#10;    &#10;    /**&#10;     * Simple JPA Repository implementation using core EntityManagerProvider&#10;     */&#10;    private static class SimpleJpaRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;        &#10;        public SimpleJpaRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;        &#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repository.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Generic Repository interface for basic CRUD operations&#10; * @param &lt;T&gt; Entity type&#10; * @param &lt;ID&gt; Primary key type&#10; */&#10;public interface Repository&lt;T, ID extends Serializable&gt; {&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    T save(T entity);&#10;&#10;    /**&#10;     * Save multiple entities&#10;     */&#10;    List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    Optional&lt;T&gt; findById(ID id);&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    List&lt;T&gt; findAll();&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    List&lt;T&gt; findAll(int offset, int limit);&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    List&lt;T&gt; findByAttribute(String attributeName, Object value);&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    List&lt;T&gt; findByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    List&lt;T&gt; findByNativeQuery(String sqlQuery, Object... params);&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    List&lt;T&gt; findByQuery(String jpqlQuery, Object... params);&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    long count();&#10;&#10;    /**&#10;     * Count entities by criteria&#10;     */&#10;    long countByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    boolean existsById(ID id);&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    boolean existsByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Update entity&#10;     */&#10;    T update(T entity);&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    void deleteById(ID id);&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    void delete(T entity);&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll();&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    void deleteByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    int executeUpdate(String jpqlQuery, Object... params);&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    int executeNativeUpdate(String sqlQuery, Object... params);&#10;&#10;    /**&#10;     * Batch insert entities&#10;     */&#10;    void batchInsert(List&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Batch update entities&#10;     */&#10;    void batchUpdate(List&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Get entity class&#10;     */&#10;    Class&lt;T&gt; getEntityClass();&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Base repository interface similar to Spring Data JPA&#10; * Provides standard CRUD operations for entities&#10; */&#10;public interface Repository&lt;T, ID extends Serializable&gt; {&#10;    &#10;    /**&#10;     * Save an entity&#10;     */&#10;    T save(T entity);&#10;    &#10;    /**&#10;     * Save all entities&#10;     */&#10;    List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    Optional&lt;T&gt; findById(ID id);&#10;    &#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    boolean existsById(ID id);&#10;    &#10;    /**&#10;     * Find all entities&#10;     */&#10;    List&lt;T&gt; findAll();&#10;    &#10;    /**&#10;     * Find all entities by IDs&#10;     */&#10;    List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Count all entities&#10;     */&#10;    long count();&#10;    &#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    void deleteById(ID id);&#10;    &#10;    /**&#10;     * Delete entity&#10;     */&#10;    void delete(T entity);&#10;    &#10;    /**&#10;     * Delete all entities by IDs&#10;     */&#10;    void deleteAllById(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/service/BackupService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/service/BackupService.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/service/ExportService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/service/ExportService.java" />
              <option name="updatedContent" value="package h2.orm.service;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.fasterxml.jackson.databind.SerializationFeature;&#10;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;&#10;import org.apache.poi.ss.usermodel.*;&#10;import org.apache.poi.xssf.usermodel.XSSFWorkbook;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.FileOutputStream;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.lang.reflect.Field;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;/**&#10; * Export service for converting data to various formats (CSV, Excel, JSON)&#10; */&#10;public class ExportService {&#10;    &#10;    private static final Logger logger = LoggerFactory.getLogger(ExportService.class);&#10;    private final ObjectMapper objectMapper;&#10;    &#10;    public ExportService() {&#10;        this.objectMapper = new ObjectMapper();&#10;        this.objectMapper.registerModule(new JavaTimeModule());&#10;        this.objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);&#10;        this.objectMapper.enable(SerializationFeature.INDENT_OUTPUT);&#10;    }&#10;    &#10;    /**&#10;     * Export data to CSV file&#10;     */&#10;    public &lt;T&gt; void exportToCsv(List&lt;T&gt; data, String filePath) {&#10;        if (data == null || data.isEmpty()) {&#10;            logger.warn(&quot;No data to export to CSV&quot;);&#10;            return;&#10;        }&#10;        &#10;        try (FileWriter writer = new FileWriter(filePath)) {&#10;            Class&lt;?&gt; clazz = data.get(0).getClass();&#10;            Field[] fields = clazz.getDeclaredFields();&#10;            &#10;            // Write header&#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                if (i &gt; 0) writer.append(&quot;,&quot;);&#10;                writer.append(fields[i].getName());&#10;            }&#10;            writer.append(&quot;\n&quot;);&#10;            &#10;            // Write data&#10;            for (T item : data) {&#10;                for (int i = 0; i &lt; fields.length; i++) {&#10;                    if (i &gt; 0) writer.append(&quot;,&quot;);&#10;                    &#10;                    fields[i].setAccessible(true);&#10;                    Object value = fields[i].get(item);&#10;                    String stringValue = value != null ? value.toString() : &quot;&quot;;&#10;                    &#10;                    // Escape commas and quotes in CSV&#10;                    if (stringValue.contains(&quot;,&quot;) || stringValue.contains(&quot;\&quot;&quot;)) {&#10;                        stringValue = &quot;\&quot;&quot; + stringValue.replace(&quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;) + &quot;\&quot;&quot;;&#10;                    }&#10;                    &#10;                    writer.append(stringValue);&#10;                }&#10;                writer.append(&quot;\n&quot;);&#10;            }&#10;            &#10;            logger.info(&quot;Data exported to CSV: {} ({} records)&quot;, filePath, data.size());&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to export to CSV&quot;, e);&#10;            throw new RuntimeException(&quot;CSV export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export data to Excel file&#10;     */&#10;    public &lt;T&gt; void exportToExcel(List&lt;T&gt; data, String filePath) {&#10;        if (data == null || data.isEmpty()) {&#10;            logger.warn(&quot;No data to export to Excel&quot;);&#10;            return;&#10;        }&#10;        &#10;        try (Workbook workbook = new XSSFWorkbook()) {&#10;            Sheet sheet = workbook.createSheet(&quot;Data&quot;);&#10;            &#10;            Class&lt;?&gt; clazz = data.get(0).getClass();&#10;            Field[] fields = clazz.getDeclaredFields();&#10;            &#10;            // Create header row&#10;            Row headerRow = sheet.createRow(0);&#10;            CellStyle headerStyle = workbook.createCellStyle();&#10;            Font headerFont = workbook.createFont();&#10;            headerFont.setBold(true);&#10;            headerStyle.setFont(headerFont);&#10;            &#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                Cell cell = headerRow.createCell(i);&#10;                cell.setCellValue(fields[i].getName());&#10;                cell.setCellStyle(headerStyle);&#10;            }&#10;            &#10;            // Create data rows&#10;            for (int rowIndex = 0; rowIndex &lt; data.size(); rowIndex++) {&#10;                Row row = sheet.createRow(rowIndex + 1);&#10;                T item = data.get(rowIndex);&#10;                &#10;                for (int colIndex = 0; colIndex &lt; fields.length; colIndex++) {&#10;                    Cell cell = row.createCell(colIndex);&#10;                    fields[colIndex].setAccessible(true);&#10;                    Object value = fields[colIndex].get(item);&#10;                    &#10;                    if (value != null) {&#10;                        if (value instanceof Number) {&#10;                            cell.setCellValue(((Number) value).doubleValue());&#10;                        } else if (value instanceof Boolean) {&#10;                            cell.setCellValue((Boolean) value);&#10;                        } else if (value instanceof LocalDate) {&#10;                            cell.setCellValue(value.toString());&#10;                        } else if (value instanceof LocalDateTime) {&#10;                            cell.setCellValue(value.toString());&#10;                        } else {&#10;                            cell.setCellValue(value.toString());&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            &#10;            // Auto-size columns&#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                sheet.autoSizeColumn(i);&#10;            }&#10;            &#10;            // Write to file&#10;            try (FileOutputStream fileOut = new FileOutputStream(filePath)) {&#10;                workbook.write(fileOut);&#10;            }&#10;            &#10;            logger.info(&quot;Data exported to Excel: {} ({} records)&quot;, filePath, data.size());&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to export to Excel&quot;, e);&#10;            throw new RuntimeException(&quot;Excel export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export data to JSON file&#10;     */&#10;    public &lt;T&gt; void exportToJson(List&lt;T&gt; data, String filePath) {&#10;        try {&#10;            objectMapper.writeValue(new java.io.File(filePath), data);&#10;            logger.info(&quot;Data exported to JSON: {} ({} records)&quot;, filePath, data != null ? data.size() : 0);&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Failed to export to JSON&quot;, e);&#10;            throw new RuntimeException(&quot;JSON export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export single object to JSON file&#10;     */&#10;    public &lt;T&gt; void exportToJson(T object, String filePath) {&#10;        try {&#10;            objectMapper.writeValue(new java.io.File(filePath), object);&#10;            logger.info(&quot;Object exported to JSON: {}&quot;, filePath);&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Failed to export to JSON&quot;, e);&#10;            throw new RuntimeException(&quot;JSON export failed&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>