<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/LIBRARY_SETUP_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/LIBRARY_SETUP_GUIDE.md" />
              <option name="originalContent" value="# H2-ORM Library Setup Guide&#10;&#10; **Modern Spring Boot-style ORM Library** supporting H2, MySQL, PostgreSQL, and SQLite with advanced backup/export features.&#10;&#10;##  Quick Navigation&#10;&#10;- [ Installation](#-installation)&#10;- [ Quick Start](#-quick-start)&#10;- [ Build from Source](#-build-from-source)&#10;- [ API Documentation](#-api-documentation)&#10;- [ Testing](#-testing)&#10;- [ Release Process](#-release-process)&#10;&#10;##  Installation&#10;&#10;### Maven Dependency&#10;&#10;```xml&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;```&#10;&#10;### Gradle Dependency&#10;&#10;```gradle&#10;implementation 'com.h2.orm:h2-orm:1.0.0'&#10;```&#10;&#10;### Manual Installation&#10;&#10;1. Download the latest release from [GitHub Releases](https://github.com/W1LDN16H7/h2-orm/releases)&#10;2. Add the JAR to your project classpath&#10;3. Include required dependencies (see `pom.xml` for full list)&#10;&#10;##  Quick Start&#10;&#10;### 1. Basic Setup&#10;&#10;```java&#10;import h2.orm.H2ORM;&#10;import h2.orm.core.repository.JpaRepository;&#10;&#10;// Start H2-ORM with in-memory database&#10;H2ORM.startInMemory();&#10;&#10;// Or with file-based database&#10;H2ORM.start(&quot;./data/myapp&quot;);&#10;&#10;// Get repository (just like Spring Data JPA)&#10;JpaRepository&lt;User, Long&gt; userRepo = H2ORM.repository(User.class);&#10;```&#10;&#10;### 2. Entity Definition&#10;&#10;```java&#10;import jakarta.persistence.*;&#10;&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false, unique = true)&#10;    private String username;&#10;    &#10;    @Column(nullable = false)&#10;    private String email;&#10;    &#10;    // constructors, getters, setters...&#10;}&#10;```&#10;&#10;### 3. Repository Operations&#10;&#10;```java&#10;// Save entities&#10;User user = new User(&quot;john_doe&quot;, &quot;john@example.com&quot;);&#10;userRepo.save(user);&#10;&#10;// Query entities&#10;List&lt;User&gt; allUsers = userRepo.findAll();&#10;Optional&lt;User&gt; user = userRepo.findById(1L);&#10;&#10;// Field-based queries (NEW!)&#10;List&lt;User&gt; johns = userRepo.findByField(&quot;username&quot;, &quot;john_doe&quot;);&#10;List&lt;User&gt; gmailUsers = userRepo.findByFieldContaining(&quot;email&quot;, &quot;@gmail.com&quot;);&#10;&#10;// Pagination and sorting&#10;Page&lt;User&gt; page = userRepo.findAll(&#10;    PageRequest.of(0, 10, Sort.by(&quot;username&quot;))&#10;);&#10;```&#10;&#10;### 4. Advanced Features&#10;&#10;```java&#10;// Export data&#10;H2ORM.exportToCsv(User.class, &quot;./exports/users.csv&quot;);&#10;H2ORM.exportToExcel(User.class, &quot;./exports/users.xlsx&quot;);&#10;H2ORM.exportToJson(User.class, &quot;./exports/users.json&quot;);&#10;&#10;// Database backup&#10;H2ORM.backup(&quot;./backups/daily_backup&quot;);&#10;H2ORM.backupCompressed(&quot;./backups/compressed_backup&quot;);&#10;&#10;// Table management&#10;H2ORM.createTable(User.class);&#10;H2ORM.truncateTable(User.class);&#10;long count = H2ORM.getTableRowCount(User.class);&#10;```&#10;&#10;##  Build from Source&#10;&#10;### Prerequisites&#10;&#10;- ☕ **Java 21+** - Required for building and running&#10;-  **Maven 3.6+** - For dependency management and building&#10;-  **Git** - For version control (optional)&#10;&#10;### Development Setup&#10;&#10;```bash&#10;# Clone the repository&#10;git clone https://github.com/W1LDN16H7/h2-orm.git&#10;cd h2-orm&#10;&#10;# Set up development environment&#10;./dev-tools.sh setup&#10;&#10;# Run tests&#10;./dev-tools.sh test&#10;&#10;# Build the project&#10;./build.sh&#10;&#10;# Or quick build (skip tests and docs)&#10;./build.sh --quick&#10;```&#10;&#10;### Build Scripts&#10;&#10;| Script | Platform | Purpose |&#10;|--------|----------|---------|&#10;| `build.sh` | Unix/Linux/macOS | Full build with tests and documentation |&#10;| `build.bat` | Windows | Windows equivalent of build.sh |&#10;| `release.sh` | Unix/Linux/macOS | Create release packages |&#10;| `dev-tools.sh` | Unix/Linux/macOS | Development utilities |&#10;&#10;### Build Options&#10;&#10;```bash&#10;# Full build (default)&#10;./build.sh&#10;&#10;# Skip tests&#10;./build.sh --skip-tests&#10;&#10;# Skip documentation generation&#10;./build.sh --skip-docs&#10;&#10;# Quick build (skip tests and docs)&#10;./build.sh --quick&#10;&#10;# Show help&#10;./build.sh --help&#10;```&#10;&#10;##  API Documentation&#10;&#10;### Generated Documentation&#10;&#10;After building, documentation is available at:&#10;- **Javadocs**: `dist/javadocs/index.html`&#10;- **Coverage Report**: `dist/coverage/index.html`&#10;&#10;### Key Packages&#10;&#10;| Package | Description |&#10;|---------|-------------|&#10;| `h2.orm` | Main entry point (`H2ORM` class) |&#10;| `h2.orm.core.repository` | Repository interfaces and implementations |&#10;| `h2.orm.core.service` | Backup, export, and table management services |&#10;| `h2.orm.config` | Database configuration |&#10;| `h2.orm.example` | Example entities and usage demonstrations |&#10;&#10;### Repository Methods&#10;&#10;#### Basic CRUD&#10;- `save(T entity)` - Save or update entity&#10;- `findById(ID id)` - Find entity by ID&#10;- `findAll()` - Find all entities&#10;- `delete(T entity)` - Delete entity&#10;- `count()` - Count entities&#10;&#10;#### Field-Based Queries&#10;- `findByField(String field, Object value)` - Find by single field&#10;- `findByFields(Map&lt;String, Object&gt; criteria)` - Find by multiple fields&#10;- `findByFieldContaining(String field, String value)` - Text search&#10;- `findByFieldBetween(String field, Object start, Object end)` - Range query&#10;- `findByFieldIn(String field, Collection&lt;?&gt; values)` - IN query&#10;&#10;#### Pagination &amp; Sorting&#10;- `findAll(Sort sort)` - Find with sorting&#10;- `findAll(Pageable pageable)` - Find with pagination&#10;- `findByField(String field, Object value, Pageable pageable)` - Field query with pagination&#10;&#10;##  Testing&#10;&#10;### Running Tests&#10;&#10;```bash&#10;# Run all tests&#10;mvn test&#10;&#10;# Run with coverage&#10;./dev-tools.sh test&#10;&#10;# Run specific test class&#10;mvn test -Dtest=H2ORMTest&#10;&#10;# Run integration tests&#10;mvn verify&#10;```&#10;&#10;### Test Categories&#10;&#10;- **Unit Tests**: `src/test/java/h2/orm/test/`&#10;- **Integration Tests**: `src/test/java/h2/orm/integration/`&#10;- **Example Tests**: `src/test/java/h2/orm/example/`&#10;&#10;### Test Coverage&#10;&#10;The project maintains high test coverage:&#10;- **Target**: &gt;80% line coverage&#10;- **Report**: Available at `target/site/jacoco/index.html`&#10;&#10;##  Release Process&#10;&#10;### Creating a Release&#10;&#10;```bash&#10;# 1. Build the project&#10;./build.sh&#10;&#10;# 2. Create release packages&#10;./release.sh&#10;&#10;# 3. Bump version (optional)&#10;./release.sh bump-patch  # or bump-minor, bump-major&#10;```&#10;&#10;### Release Artifacts&#10;&#10;After running the release script, you'll find:&#10;&#10;```&#10;releases/&#10;├── h2-orm-1.0.0-release.tar.gz     # Complete release package&#10;├── github-v1.0.0/                  # GitHub release assets&#10;│   ├── h2-orm-1.0.0.jar&#10;│   ├── h2-orm-1.0.0-sources.jar&#10;│   ├── h2-orm-1.0.0-javadoc.jar&#10;│   ├── h2-orm-1.0.0-complete.jar&#10;│   └── release-notes.md&#10;└── maven-deploy-commands.txt        # Maven deployment commands&#10;```&#10;&#10;### Publishing to Maven Central&#10;&#10;1. Set up GPG signing and OSSRH account&#10;2. Configure `~/.m2/settings.xml` with credentials&#10;3. Run: `mvn clean deploy -P release`&#10;&#10;### GitHub Release&#10;&#10;1. Tag the release: `git tag v1.0.0`&#10;2. Push tag: `git push origin v1.0.0`&#10;3. Upload assets from `releases/github-v1.0.0/`&#10;4. Use `release-notes.md` as release description&#10;&#10;## ️ Development Tools&#10;&#10;### Available Commands&#10;&#10;```bash&#10;./dev-tools.sh setup      # Setup development environment&#10;./dev-tools.sh test       # Run tests with coverage&#10;./dev-tools.sh format     # Format code&#10;./dev-tools.sh deps       # Check dependency updates&#10;./dev-tools.sh security   # Run security scan&#10;./dev-tools.sh stats      # Show project statistics&#10;./dev-tools.sh clean      # Deep clean&#10;./dev-tools.sh ide        # Setup IDE configuration&#10;./dev-tools.sh all        # Run all development tasks&#10;```&#10;&#10;### IDE Setup&#10;&#10;The project includes configuration for:&#10;- **IntelliJ IDEA**: `.idea/` directory&#10;- **VS Code**: `.vscode/` directory&#10;- **Eclipse**: Import as Maven project&#10;&#10;### Code Quality&#10;&#10;- **Formatting**: Google Java Format&#10;- **Static Analysis**: SpotBugs&#10;- **Security**: OWASP Dependency Check&#10;- **Coverage**: JaCoCo&#10;&#10;##  Links&#10;&#10;- **Repository**: https://github.com/W1LDN16H7/h2-orm&#10;- **Issues**: https://github.com/W1LDN16H7/h2-orm/issues&#10;- **Wiki**: https://github.com/W1LDN16H7/h2-orm/wiki&#10;- **Releases**: https://github.com/W1LDN16H7/h2-orm/releases&#10;&#10;##  License&#10;&#10;This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.&#10;&#10;##  Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch: `git checkout -b feature/amazing-feature`&#10;3. Run tests: `./dev-tools.sh test`&#10;4. Commit changes: `git commit -m 'Add amazing feature'`&#10;5. Push to branch: `git push origin feature/amazing-feature`&#10;6. Open a Pull Request&#10;&#10;##  Support&#10;&#10;- **Documentation**: Check the [Wiki](https://github.com/W1LDN16H7/h2-orm/wiki)&#10;- **Issues**: Report bugs or request features via [GitHub Issues](https://github.com/W1LDN16H7/h2-orm/issues)&#10;- **Discussions**: Join the conversation in [GitHub Discussions](https://github.com/W1LDN16H7/h2-orm/discussions)&#10;&#10;---&#10;&#10;**Built with ❤️ by W1LDN16H7** | **Version 1.0.0** | **© 2025**&#10;" />
              <option name="updatedContent" value="# H2-ORM Library Setup Guide&#10;&#10; **Modern Spring Boot-style ORM Library** supporting H2, MySQL, PostgreSQL, and SQLite with advanced backup/export features.&#10;&#10;##  Quick Navigation&#10;&#10;- [ Installation](#-installation)&#10;- [ Quick Start](#-quick-start)&#10;- [ Build from Source](#-build-from-source)&#10;- [ API Documentation](#-api-documentation)&#10;- [ Testing](#-testing)&#10;- [ Release Process](#-release-process)&#10;&#10;##  Installation&#10;&#10;### Maven Dependency&#10;&#10;```xml&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;```&#10;&#10;### Gradle Dependency&#10;&#10;```gradle&#10;implementation 'com.h2.orm:h2-orm:1.0.0'&#10;```&#10;&#10;### Manual Installation&#10;&#10;1. Download the latest JAR from [Releases](https://github.com/your-repo/h2-orm/releases)&#10;2. Add the JAR to your project's classpath&#10;3. Include required dependencies:&#10;   - H2 Database Engine&#10;   - SLF4J API&#10;   - Jackson Core (for JSON export)&#10;   - Apache POI (for Excel export)&#10;&#10;##  Quick Start&#10;&#10;### Basic Setup&#10;&#10;```java&#10;import com.h2.orm.DatabaseManager;&#10;import com.h2.orm.annotations.*;&#10;&#10;// 1. Define your entity&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(name = &quot;username&quot;, nullable = false, unique = true)&#10;    private String username;&#10;    &#10;    @Column(name = &quot;email&quot;)&#10;    private String email;&#10;    &#10;    @Column(name = &quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;    &#10;    // Constructors, getters, setters...&#10;}&#10;&#10;// 2. Initialize the database manager&#10;DatabaseManager dbManager = new DatabaseManager(&quot;jdbc:h2:./data/myapp&quot;);&#10;dbManager.createTablesFromEntities(User.class);&#10;&#10;// 3. Perform CRUD operations&#10;User user = new User(&quot;john_doe&quot;, &quot;john@example.com&quot;);&#10;dbManager.save(user);&#10;&#10;List&lt;User&gt; users = dbManager.findAll(User.class);&#10;User foundUser = dbManager.findById(User.class, 1L);&#10;```&#10;&#10;### Configuration Options&#10;&#10;```java&#10;// Database configuration&#10;DatabaseConfig config = DatabaseConfig.builder()&#10;    .url(&quot;jdbc:h2:./data/myapp&quot;)&#10;    .username(&quot;sa&quot;)&#10;    .password(&quot;&quot;)&#10;    .dialect(DatabaseDialect.H2)&#10;    .showSql(true)&#10;    .formatSql(true)&#10;    .build();&#10;&#10;DatabaseManager dbManager = new DatabaseManager(config);&#10;```&#10;&#10;### Supported Database Types&#10;&#10;| Database | JDBC URL Example | Driver Required |&#10;|----------|------------------|-----------------|&#10;| H2 (File) | `jdbc:h2:./data/myapp` | Built-in |&#10;| H2 (Memory) | `jdbc:h2:mem:testdb` | Built-in |&#10;| MySQL | `jdbc:mysql://localhost:3306/mydb` | mysql-connector-java |&#10;| PostgreSQL | `jdbc:postgresql://localhost:5432/mydb` | postgresql |&#10;| SQLite | `jdbc:sqlite:./data/myapp.db` | sqlite-jdbc |&#10;&#10;##  Build from Source&#10;&#10;### Prerequisites&#10;&#10;- Java 11 or higher&#10;- Maven 3.6+&#10;- Git&#10;&#10;### Build Steps&#10;&#10;```bash&#10;# Clone the repository&#10;git clone https://github.com/your-repo/h2-orm.git&#10;cd h2-orm&#10;&#10;# Build the project&#10;./mvnw clean compile&#10;&#10;# Run tests&#10;./mvnw test&#10;&#10;# Package the library&#10;./mvnw package&#10;&#10;# Install to local repository&#10;./mvnw install&#10;```&#10;&#10;### Development Tools&#10;&#10;```bash&#10;# Use the development tools script&#10;./dev-tools.sh&#10;&#10;# Available commands:&#10;# - clean: Clean build artifacts&#10;# - compile: Compile source code&#10;# - test: Run all tests&#10;# - package: Create JAR file&#10;# - install: Install to local Maven repository&#10;# - format: Format code using Google Java Format&#10;```&#10;&#10;##  API Documentation&#10;&#10;### Core Classes&#10;&#10;#### DatabaseManager&#10;The main class for database operations.&#10;&#10;```java&#10;// Basic CRUD operations&#10;&lt;T&gt; T save(T entity)&#10;&lt;T&gt; T update(T entity)&#10;&lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id)&#10;&lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass)&#10;&lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id)&#10;&#10;// Query operations&#10;&lt;T&gt; List&lt;T&gt; findByColumn(Class&lt;T&gt; entityClass, String columnName, Object value)&#10;&lt;T&gt; List&lt;T&gt; executeQuery(String sql, Class&lt;T&gt; resultClass, Object... params)&#10;&#10;// Schema operations&#10;void createTablesFromEntities(Class&lt;?&gt;... entityClasses)&#10;void dropTable(String tableName)&#10;```&#10;&#10;#### BackupManager&#10;Advanced backup and export functionality.&#10;&#10;```java&#10;// Backup operations&#10;void createBackup(String backupPath)&#10;void createCompressedBackup(String backupPath)&#10;void restoreFromBackup(String backupPath)&#10;&#10;// Export operations&#10;void exportToCSV(String tableName, String filePath)&#10;void exportToJSON(String tableName, String filePath)&#10;void exportToExcel(String tableName, String filePath)&#10;&#10;// Scheduled backups&#10;void scheduleBackup(Duration interval, String backupDirectory)&#10;```&#10;&#10;### Annotations&#10;&#10;#### @Entity&#10;Marks a class as a database entity.&#10;&#10;```java&#10;@Entity&#10;public class MyEntity { ... }&#10;```&#10;&#10;#### @Table&#10;Specifies table details.&#10;&#10;```java&#10;@Table(name = &quot;custom_table_name&quot;)&#10;public class MyEntity { ... }&#10;```&#10;&#10;#### @Id&#10;Marks the primary key field.&#10;&#10;```java&#10;@Id&#10;private Long id;&#10;```&#10;&#10;#### @GeneratedValue&#10;Configures auto-generation of primary key values.&#10;&#10;```java&#10;@GeneratedValue(strategy = GenerationType.IDENTITY)&#10;private Long id;&#10;```&#10;&#10;#### @Column&#10;Configures column properties.&#10;&#10;```java&#10;@Column(name = &quot;custom_name&quot;, nullable = false, unique = true, length = 100)&#10;private String name;&#10;```&#10;&#10;##  Testing&#10;&#10;### Running Tests&#10;&#10;```bash&#10;# Run all tests&#10;./mvnw test&#10;&#10;# Run specific test class&#10;./mvnw test -Dtest=DatabaseManagerTest&#10;&#10;# Run tests with coverage&#10;./mvnw jacoco:prepare-agent test jacoco:report&#10;```&#10;&#10;### Test Categories&#10;&#10;- **Unit Tests**: Core functionality testing&#10;- **Integration Tests**: Database integration testing&#10;- **Performance Tests**: Load and performance testing&#10;&#10;### Sample Test&#10;&#10;```java&#10;@Test&#10;public void testSaveAndFindUser() {&#10;    // Given&#10;    User user = new User(&quot;testuser&quot;, &quot;test@example.com&quot;);&#10;    &#10;    // When&#10;    User savedUser = dbManager.save(user);&#10;    Optional&lt;User&gt; foundUser = dbManager.findById(User.class, savedUser.getId());&#10;    &#10;    // Then&#10;    assertTrue(foundUser.isPresent());&#10;    assertEquals(&quot;testuser&quot;, foundUser.get().getUsername());&#10;}&#10;```&#10;&#10;##  Release Process&#10;&#10;### Version Management&#10;&#10;The project follows [Semantic Versioning](https://semver.org/):&#10;- **MAJOR**: Incompatible API changes&#10;- **MINOR**: Backwards-compatible functionality additions&#10;- **PATCH**: Backwards-compatible bug fixes&#10;&#10;### Release Steps&#10;&#10;1. **Update Version**&#10;   ```bash&#10;   ./mvnw versions:set -DnewVersion=1.1.0&#10;   ```&#10;&#10;2. **Run Full Test Suite**&#10;   ```bash&#10;   ./mvnw clean test&#10;   ```&#10;&#10;3. **Create Release Build**&#10;   ```bash&#10;   ./release.sh&#10;   ```&#10;&#10;4. **Tag Release**&#10;   ```bash&#10;   git tag -a v1.1.0 -m &quot;Release version 1.1.0&quot;&#10;   git push origin v1.1.0&#10;   ```&#10;&#10;### Build Artifacts&#10;&#10;The release process generates:&#10;- `h2-orm-{version}.jar` - Main library&#10;- `h2-orm-{version}-sources.jar` - Source code&#10;- `h2-orm-{version}-javadoc.jar` - API documentation&#10;&#10;##  Configuration&#10;&#10;### Database Configuration&#10;&#10;Create `h2-orm-config.xml` in your resources directory:&#10;&#10;```xml&#10;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;configuration&gt;&#10;    &lt;database&gt;&#10;        &lt;url&gt;jdbc:h2:./data/myapp&lt;/url&gt;&#10;        &lt;username&gt;sa&lt;/username&gt;&#10;        &lt;password&gt;&lt;/password&gt;&#10;        &lt;dialect&gt;H2&lt;/dialect&gt;&#10;        &lt;showSql&gt;true&lt;/showSql&gt;&#10;        &lt;formatSql&gt;true&lt;/formatSql&gt;&#10;    &lt;/database&gt;&#10;    &#10;    &lt;backup&gt;&#10;        &lt;autoBackup&gt;true&lt;/autoBackup&gt;&#10;        &lt;backupInterval&gt;24h&lt;/backupInterval&gt;&#10;        &lt;backupDirectory&gt;./backups&lt;/backupDirectory&gt;&#10;        &lt;compressionEnabled&gt;true&lt;/compressionEnabled&gt;&#10;        &lt;maxBackupFiles&gt;10&lt;/maxBackupFiles&gt;&#10;    &lt;/backup&gt;&#10;    &#10;    &lt;logging&gt;&#10;        &lt;level&gt;INFO&lt;/level&gt;&#10;        &lt;file&gt;./logs/h2-orm.log&lt;/file&gt;&#10;    &lt;/logging&gt;&#10;&lt;/configuration&gt;&#10;```&#10;&#10;### Environment Variables&#10;&#10;| Variable | Description | Default |&#10;|----------|-------------|---------|&#10;| `H2_ORM_DB_URL` | Database URL | `jdbc:h2:./data/default` |&#10;| `H2_ORM_DB_USER` | Database username | `sa` |&#10;| `H2_ORM_DB_PASSWORD` | Database password | (empty) |&#10;| `H2_ORM_SHOW_SQL` | Show SQL queries | `false` |&#10;| `H2_ORM_BACKUP_DIR` | Backup directory | `./backups` |&#10;&#10;##  Advanced Features&#10;&#10;### Backup and Export&#10;&#10;```java&#10;// Create backup manager&#10;BackupManager backupManager = new BackupManager(dbManager);&#10;&#10;// Manual backup&#10;backupManager.createBackup(&quot;./backups/manual_backup.sql&quot;);&#10;&#10;// Compressed backup&#10;backupManager.createCompressedBackup(&quot;./backups/compressed_backup.gz&quot;);&#10;&#10;// Export to different formats&#10;backupManager.exportToCSV(&quot;users&quot;, &quot;./exports/users.csv&quot;);&#10;backupManager.exportToJSON(&quot;users&quot;, &quot;./exports/users.json&quot;);&#10;backupManager.exportToExcel(&quot;users&quot;, &quot;./exports/users.xlsx&quot;);&#10;&#10;// Scheduled backups&#10;backupManager.scheduleBackup(Duration.ofHours(24), &quot;./backups&quot;);&#10;```&#10;&#10;### Query Builder&#10;&#10;```java&#10;// Build complex queries&#10;List&lt;User&gt; activeUsers = dbManager.queryBuilder(User.class)&#10;    .where(&quot;status&quot;, &quot;ACTIVE&quot;)&#10;    .and(&quot;created_at&quot;, &quot;&gt;&quot;, LocalDateTime.now().minusDays(30))&#10;    .orderBy(&quot;created_at&quot;, &quot;DESC&quot;)&#10;    .limit(100)&#10;    .execute();&#10;```&#10;&#10;### Transaction Management&#10;&#10;```java&#10;// Manual transaction management&#10;dbManager.executeInTransaction(() -&gt; {&#10;    User user = new User(&quot;john&quot;, &quot;john@example.com&quot;);&#10;    dbManager.save(user);&#10;    &#10;    Profile profile = new Profile(user.getId(), &quot;John Doe&quot;);&#10;    dbManager.save(profile);&#10;    &#10;    return null; // Transaction will be committed&#10;});&#10;```&#10;&#10;## ️ Troubleshooting&#10;&#10;### Common Issues&#10;&#10;1. **Database Connection Failed**&#10;   - Check database URL format&#10;   - Verify database server is running&#10;   - Check credentials&#10;&#10;2. **Table Not Found**&#10;   - Ensure entities are properly annotated&#10;   - Call `createTablesFromEntities()` before operations&#10;&#10;3. **Primary Key Errors**&#10;   - Verify `@Id` annotation is present&#10;   - Check `@GeneratedValue` configuration&#10;&#10;### Debug Logging&#10;&#10;Enable debug logging in your configuration:&#10;&#10;```xml&#10;&lt;logging&gt;&#10;    &lt;level&gt;DEBUG&lt;/level&gt;&#10;&lt;/logging&gt;&#10;```&#10;&#10;Or set environment variable:&#10;```bash&#10;export H2_ORM_LOG_LEVEL=DEBUG&#10;```&#10;&#10;##  Examples&#10;&#10;Check the `examples/` directory for complete working examples:&#10;- Basic CRUD operations&#10;- Advanced querying&#10;- Backup and export&#10;- Multiple database types&#10;- Spring Boot integration&#10;&#10;##  Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch&#10;3. Make your changes&#10;4. Add tests for new functionality&#10;5. Run the test suite&#10;6. Submit a pull request&#10;&#10;##  License&#10;&#10;This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.&#10;&#10;##  Support&#10;&#10;-  Email: support@h2-orm.com&#10;-  Discord: [H2-ORM Community](https://discord.gg/h2-orm)&#10;-  Issues: [GitHub Issues](https://github.com/your-repo/h2-orm/issues)&#10;-  Documentation: [Full Documentation](https://docs.h2-orm.com)&#10;&#10;---&#10;&#10;Made with ❤️ by the H2-ORM Team" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/LICENSE">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/LICENSE" />
              <option name="updatedContent" value="MIT License&#10;&#10;Copyright (c) 2025 H2-ORM Team&#10;&#10;Permission is hereby granted, free of charge, to any person obtaining a copy&#10;of this software and associated documentation files (the &quot;Software&quot;), to deal&#10;in the Software without restriction, including without limitation the rights&#10;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#10;copies of the Software, and to permit persons to whom the Software is&#10;furnished to do so, subject to the following conditions:&#10;&#10;The above copyright notice and this permission notice shall be included in all&#10;copies or substantial portions of the Software.&#10;&#10;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#10;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#10;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#10;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#10;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#10;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#10;SOFTWARE." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# H2-ORM Library Setup Guide&#10;&#10; **Modern Spring Boot-style ORM Library** supporting H2, MySQL, PostgreSQL, and SQLite with advanced backup/export features.&#10;&#10;##  Quick Navigation&#10;&#10;- [ Installation](#-installation)&#10;- [ Quick Start](#-quick-start)&#10;- [ Build from Source](#-build-from-source)&#10;- [ API Documentation](#-api-documentation)&#10;- [ Testing](#-testing)&#10;- [ Release Process](#-release-process)&#10;&#10;##  Installation&#10;&#10;### Maven Dependency&#10;&#10;```xml&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;```&#10;&#10;### Gradle Dependency&#10;&#10;```gradle&#10;implementation 'com.h2.orm:h2-orm:1.0.0'&#10;```&#10;&#10;### Manual Installation&#10;&#10;1. Download the latest JAR from [Releases](https://github.com/your-repo/h2-orm/releases)&#10;2. Add the JAR to your project's classpath&#10;3. Include required dependencies:&#10;   - H2 Database Engine&#10;   - SLF4J API&#10;   - Jackson Core (for JSON export)&#10;   - Apache POI (for Excel export)&#10;&#10;##  Quick Start&#10;&#10;### Basic Setup&#10;&#10;```java&#10;import com.h2.orm.DatabaseManager;&#10;import com.h2.orm.annotations.*;&#10;&#10;// 1. Define your entity&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(name = &quot;username&quot;, nullable = false, unique = true)&#10;    private String username;&#10;    &#10;    @Column(name = &quot;email&quot;)&#10;    private String email;&#10;    &#10;    @Column(name = &quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;    &#10;    // Constructors, getters, setters...&#10;}&#10;&#10;// 2. Initialize the database manager&#10;DatabaseManager dbManager = new DatabaseManager(&quot;jdbc:h2:./data/myapp&quot;);&#10;dbManager.createTablesFromEntities(User.class);&#10;&#10;// 3. Perform CRUD operations&#10;User user = new User(&quot;john_doe&quot;, &quot;john@example.com&quot;);&#10;dbManager.save(user);&#10;&#10;List&lt;User&gt; users = dbManager.findAll(User.class);&#10;User foundUser = dbManager.findById(User.class, 1L);&#10;```&#10;&#10;### Configuration Options&#10;&#10;```java&#10;// Database configuration&#10;DatabaseConfig config = DatabaseConfig.builder()&#10;    .url(&quot;jdbc:h2:./data/myapp&quot;)&#10;    .username(&quot;sa&quot;)&#10;    .password(&quot;&quot;)&#10;    .dialect(DatabaseDialect.H2)&#10;    .showSql(true)&#10;    .formatSql(true)&#10;    .build();&#10;&#10;DatabaseManager dbManager = new DatabaseManager(config);&#10;```&#10;&#10;### Supported Database Types&#10;&#10;| Database | JDBC URL Example | Driver Required |&#10;|----------|------------------|-----------------|&#10;| H2 (File) | `jdbc:h2:./data/myapp` | Built-in |&#10;| H2 (Memory) | `jdbc:h2:mem:testdb` | Built-in |&#10;| MySQL | `jdbc:mysql://localhost:3306/mydb` | mysql-connector-java |&#10;| PostgreSQL | `jdbc:postgresql://localhost:5432/mydb` | postgresql |&#10;| SQLite | `jdbc:sqlite:./data/myapp.db` | sqlite-jdbc |&#10;&#10;##  Build from Source&#10;&#10;### Prerequisites&#10;&#10;- Java 11 or higher&#10;- Maven 3.6+&#10;- Git&#10;&#10;### Build Steps&#10;&#10;```bash&#10;# Clone the repository&#10;git clone https://github.com/your-repo/h2-orm.git&#10;cd h2-orm&#10;&#10;# Build the project&#10;./mvnw clean compile&#10;&#10;# Run tests&#10;./mvnw test&#10;&#10;# Package the library&#10;./mvnw package&#10;&#10;# Install to local repository&#10;./mvnw install&#10;```&#10;&#10;### Development Tools&#10;&#10;```bash&#10;# Use the development tools script&#10;./dev-tools.sh&#10;&#10;# Available commands:&#10;# - clean: Clean build artifacts&#10;# - compile: Compile source code&#10;# - test: Run all tests&#10;# - package: Create JAR file&#10;# - install: Install to local Maven repository&#10;# - format: Format code using Google Java Format&#10;```&#10;&#10;##  API Documentation&#10;&#10;### Core Classes&#10;&#10;#### DatabaseManager&#10;The main class for database operations.&#10;&#10;```java&#10;// Basic CRUD operations&#10;&lt;T&gt; T save(T entity)&#10;&lt;T&gt; T update(T entity)&#10;&lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id)&#10;&lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass)&#10;&lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id)&#10;&#10;// Query operations&#10;&lt;T&gt; List&lt;T&gt; findByColumn(Class&lt;T&gt; entityClass, String columnName, Object value)&#10;&lt;T&gt; List&lt;T&gt; executeQuery(String sql, Class&lt;T&gt; resultClass, Object... params)&#10;&#10;// Schema operations&#10;void createTablesFromEntities(Class&lt;?&gt;... entityClasses)&#10;void dropTable(String tableName)&#10;```&#10;&#10;#### BackupManager&#10;Advanced backup and export functionality.&#10;&#10;```java&#10;// Backup operations&#10;void createBackup(String backupPath)&#10;void createCompressedBackup(String backupPath)&#10;void restoreFromBackup(String backupPath)&#10;&#10;// Export operations&#10;void exportToCSV(String tableName, String filePath)&#10;void exportToJSON(String tableName, String filePath)&#10;void exportToExcel(String tableName, String filePath)&#10;&#10;// Scheduled backups&#10;void scheduleBackup(Duration interval, String backupDirectory)&#10;```&#10;&#10;### Annotations&#10;&#10;#### @Entity&#10;Marks a class as a database entity.&#10;&#10;```java&#10;@Entity&#10;public class MyEntity { ... }&#10;```&#10;&#10;#### @Table&#10;Specifies table details.&#10;&#10;```java&#10;@Table(name = &quot;custom_table_name&quot;)&#10;public class MyEntity { ... }&#10;```&#10;&#10;#### @Id&#10;Marks the primary key field.&#10;&#10;```java&#10;@Id&#10;private Long id;&#10;```&#10;&#10;#### @GeneratedValue&#10;Configures auto-generation of primary key values.&#10;&#10;```java&#10;@GeneratedValue(strategy = GenerationType.IDENTITY)&#10;private Long id;&#10;```&#10;&#10;#### @Column&#10;Configures column properties.&#10;&#10;```java&#10;@Column(name = &quot;custom_name&quot;, nullable = false, unique = true, length = 100)&#10;private String name;&#10;```&#10;&#10;##  Testing&#10;&#10;### Running Tests&#10;&#10;```bash&#10;# Run all tests&#10;./mvnw test&#10;&#10;# Run specific test class&#10;./mvnw test -Dtest=DatabaseManagerTest&#10;&#10;# Run tests with coverage&#10;./mvnw jacoco:prepare-agent test jacoco:report&#10;```&#10;&#10;### Test Categories&#10;&#10;- **Unit Tests**: Core functionality testing&#10;- **Integration Tests**: Database integration testing&#10;- **Performance Tests**: Load and performance testing&#10;&#10;### Sample Test&#10;&#10;```java&#10;@Test&#10;public void testSaveAndFindUser() {&#10;    // Given&#10;    User user = new User(&quot;testuser&quot;, &quot;test@example.com&quot;);&#10;    &#10;    // When&#10;    User savedUser = dbManager.save(user);&#10;    Optional&lt;User&gt; foundUser = dbManager.findById(User.class, savedUser.getId());&#10;    &#10;    // Then&#10;    assertTrue(foundUser.isPresent());&#10;    assertEquals(&quot;testuser&quot;, foundUser.get().getUsername());&#10;}&#10;```&#10;&#10;##  Release Process&#10;&#10;### Version Management&#10;&#10;The project follows [Semantic Versioning](https://semver.org/):&#10;- **MAJOR**: Incompatible API changes&#10;- **MINOR**: Backwards-compatible functionality additions&#10;- **PATCH**: Backwards-compatible bug fixes&#10;&#10;### Release Steps&#10;&#10;1. **Update Version**&#10;   ```bash&#10;   ./mvnw versions:set -DnewVersion=1.1.0&#10;   ```&#10;&#10;2. **Run Full Test Suite**&#10;   ```bash&#10;   ./mvnw clean test&#10;   ```&#10;&#10;3. **Create Release Build**&#10;   ```bash&#10;   ./release.sh&#10;   ```&#10;&#10;4. **Tag Release**&#10;   ```bash&#10;   git tag -a v1.1.0 -m &quot;Release version 1.1.0&quot;&#10;   git push origin v1.1.0&#10;   ```&#10;&#10;### Build Artifacts&#10;&#10;The release process generates:&#10;- `h2-orm-{version}.jar` - Main library&#10;- `h2-orm-{version}-sources.jar` - Source code&#10;- `h2-orm-{version}-javadoc.jar` - API documentation&#10;&#10;##  Configuration&#10;&#10;### Database Configuration&#10;&#10;Create `h2-orm-config.xml` in your resources directory:&#10;&#10;```xml&#10;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;configuration&gt;&#10;    &lt;database&gt;&#10;        &lt;url&gt;jdbc:h2:./data/myapp&lt;/url&gt;&#10;        &lt;username&gt;sa&lt;/username&gt;&#10;        &lt;password&gt;&lt;/password&gt;&#10;        &lt;dialect&gt;H2&lt;/dialect&gt;&#10;        &lt;showSql&gt;true&lt;/showSql&gt;&#10;        &lt;formatSql&gt;true&lt;/formatSql&gt;&#10;    &lt;/database&gt;&#10;    &#10;    &lt;backup&gt;&#10;        &lt;autoBackup&gt;true&lt;/autoBackup&gt;&#10;        &lt;backupInterval&gt;24h&lt;/backupInterval&gt;&#10;        &lt;backupDirectory&gt;./backups&lt;/backupDirectory&gt;&#10;        &lt;compressionEnabled&gt;true&lt;/compressionEnabled&gt;&#10;        &lt;maxBackupFiles&gt;10&lt;/maxBackupFiles&gt;&#10;    &lt;/backup&gt;&#10;    &#10;    &lt;logging&gt;&#10;        &lt;level&gt;INFO&lt;/level&gt;&#10;        &lt;file&gt;./logs/h2-orm.log&lt;/file&gt;&#10;    &lt;/logging&gt;&#10;&lt;/configuration&gt;&#10;```&#10;&#10;### Environment Variables&#10;&#10;| Variable | Description | Default |&#10;|----------|-------------|---------|&#10;| `H2_ORM_DB_URL` | Database URL | `jdbc:h2:./data/default` |&#10;| `H2_ORM_DB_USER` | Database username | `sa` |&#10;| `H2_ORM_DB_PASSWORD` | Database password | (empty) |&#10;| `H2_ORM_SHOW_SQL` | Show SQL queries | `false` |&#10;| `H2_ORM_BACKUP_DIR` | Backup directory | `./backups` |&#10;&#10;##  Advanced Features&#10;&#10;### Backup and Export&#10;&#10;```java&#10;// Create backup manager&#10;BackupManager backupManager = new BackupManager(dbManager);&#10;&#10;// Manual backup&#10;backupManager.createBackup(&quot;./backups/manual_backup.sql&quot;);&#10;&#10;// Compressed backup&#10;backupManager.createCompressedBackup(&quot;./backups/compressed_backup.gz&quot;);&#10;&#10;// Export to different formats&#10;backupManager.exportToCSV(&quot;users&quot;, &quot;./exports/users.csv&quot;);&#10;backupManager.exportToJSON(&quot;users&quot;, &quot;./exports/users.json&quot;);&#10;backupManager.exportToExcel(&quot;users&quot;, &quot;./exports/users.xlsx&quot;);&#10;&#10;// Scheduled backups&#10;backupManager.scheduleBackup(Duration.ofHours(24), &quot;./backups&quot;);&#10;```&#10;&#10;### Query Builder&#10;&#10;```java&#10;// Build complex queries&#10;List&lt;User&gt; activeUsers = dbManager.queryBuilder(User.class)&#10;    .where(&quot;status&quot;, &quot;ACTIVE&quot;)&#10;    .and(&quot;created_at&quot;, &quot;&gt;&quot;, LocalDateTime.now().minusDays(30))&#10;    .orderBy(&quot;created_at&quot;, &quot;DESC&quot;)&#10;    .limit(100)&#10;    .execute();&#10;```&#10;&#10;### Transaction Management&#10;&#10;```java&#10;// Manual transaction management&#10;dbManager.executeInTransaction(() -&gt; {&#10;    User user = new User(&quot;john&quot;, &quot;john@example.com&quot;);&#10;    dbManager.save(user);&#10;    &#10;    Profile profile = new Profile(user.getId(), &quot;John Doe&quot;);&#10;    dbManager.save(profile);&#10;    &#10;    return null; // Transaction will be committed&#10;});&#10;```&#10;&#10;## ️ Troubleshooting&#10;&#10;### Common Issues&#10;&#10;1. **Database Connection Failed**&#10;   - Check database URL format&#10;   - Verify database server is running&#10;   - Check credentials&#10;&#10;2. **Table Not Found**&#10;   - Ensure entities are properly annotated&#10;   - Call `createTablesFromEntities()` before operations&#10;&#10;3. **Primary Key Errors**&#10;   - Verify `@Id` annotation is present&#10;   - Check `@GeneratedValue` configuration&#10;&#10;### Debug Logging&#10;&#10;Enable debug logging in your configuration:&#10;&#10;```xml&#10;&lt;logging&gt;&#10;    &lt;level&gt;DEBUG&lt;/level&gt;&#10;&lt;/logging&gt;&#10;```&#10;&#10;Or set environment variable:&#10;```bash&#10;export H2_ORM_LOG_LEVEL=DEBUG&#10;```&#10;&#10;##  Examples&#10;&#10;Check the `examples/` directory for complete working examples:&#10;- Basic CRUD operations&#10;- Advanced querying&#10;- Backup and export&#10;- Multiple database types&#10;- Spring Boot integration&#10;&#10;##  Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch&#10;3. Make your changes&#10;4. Add tests for new functionality&#10;5. Run the test suite&#10;6. Submit a pull request&#10;&#10;##  License&#10;&#10;This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.&#10;&#10;##  Support&#10;&#10;-  Email: support@h2-orm.com&#10;-  Discord: [H2-ORM Community](https://discord.gg/h2-orm)&#10;-  Issues: [GitHub Issues](https://github.com/your-repo/h2-orm/issues)&#10;-  Documentation: [Full Documentation](https://docs.h2-orm.com)&#10;&#10;---&#10;&#10;Made with ❤️ by the H2-ORM Team&#10;" />
              <option name="updatedContent" value="# H2-ORM Library Setup Guide&#10;&#10; **Modern Spring Boot-style ORM Library** supporting H2, MySQL, PostgreSQL, and SQLite with advanced backup/export features.&#10;&#10;##  Quick Navigation&#10;&#10;- [ Installation](#installation)&#10;- [ Quick Start](#quick-start)&#10;- [ Build from Source](#build-from-source)&#10;- [ API Documentation](#api-documentation)&#10;- [ Testing](#testing)&#10;- [ Release Process](#release-process)&#10;&#10;##  Installation&#10;&#10;### Maven Dependency&#10;&#10;```xml&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;```&#10;&#10;### Gradle Dependency&#10;&#10;```gradle&#10;implementation 'com.h2.orm:h2-orm:1.0.0'&#10;```&#10;&#10;### Manual Installation&#10;&#10;1. Download the latest JAR from releases&#10;2. Add the JAR to your project's classpath&#10;3. Include required dependencies:&#10;   - H2 Database Engine&#10;   - SLF4J API&#10;   - Jackson Core (for JSON export)&#10;   - Apache POI (for Excel export)&#10;&#10;##  Quick Start&#10;&#10;### Basic Setup&#10;&#10;**Step 1: Define your entity**&#10;&#10;```java&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(name = &quot;username&quot;, nullable = false, unique = true)&#10;    private String username;&#10;    &#10;    @Column(name = &quot;email&quot;)&#10;    private String email;&#10;    &#10;    @Column(name = &quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;    &#10;    // Constructors, getters, setters...&#10;}&#10;```&#10;&#10;**Step 2: Initialize the database manager**&#10;&#10;```java&#10;DatabaseManager dbManager = new DatabaseManager(&quot;jdbc:h2:./data/myapp&quot;);&#10;dbManager.createTablesFromEntities(User.class);&#10;```&#10;&#10;**Step 3: Perform CRUD operations**&#10;&#10;```java&#10;User user = new User(&quot;john_doe&quot;, &quot;john@example.com&quot;);&#10;dbManager.save(user);&#10;&#10;List&lt;User&gt; users = dbManager.findAll(User.class);&#10;User foundUser = dbManager.findById(User.class, 1L);&#10;```&#10;&#10;### Configuration Options&#10;&#10;```java&#10;DatabaseConfig config = DatabaseConfig.builder()&#10;    .url(&quot;jdbc:h2:./data/myapp&quot;)&#10;    .username(&quot;sa&quot;)&#10;    .password(&quot;&quot;)&#10;    .dialect(DatabaseDialect.H2)&#10;    .showSql(true)&#10;    .formatSql(true)&#10;    .build();&#10;&#10;DatabaseManager dbManager = new DatabaseManager(config);&#10;```&#10;&#10;### Supported Database Types&#10;&#10;| Database | JDBC URL Example | Driver Required |&#10;|----------|------------------|-----------------|&#10;| H2 (File) | `jdbc:h2:./data/myapp` | Built-in |&#10;| H2 (Memory) | `jdbc:h2:mem:testdb` | Built-in |&#10;| MySQL | `jdbc:mysql://localhost:3306/mydb` | mysql-connector-java |&#10;| PostgreSQL | `jdbc:postgresql://localhost:5432/mydb` | postgresql |&#10;| SQLite | `jdbc:sqlite:./data/myapp.db` | sqlite-jdbc |&#10;&#10;##  Build from Source&#10;&#10;### Prerequisites&#10;&#10;- Java 11 or higher&#10;- Maven 3.6+&#10;- Git&#10;&#10;### Build Steps&#10;&#10;```bash&#10;# Clone the repository&#10;git clone https://github.com/your-repo/h2-orm.git&#10;cd h2-orm&#10;&#10;# Build the project&#10;./mvnw clean compile&#10;&#10;# Run tests&#10;./mvnw test&#10;&#10;# Package the library&#10;./mvnw package&#10;&#10;# Install to local repository&#10;./mvnw install&#10;```&#10;&#10;### Development Tools&#10;&#10;Use the development tools script:&#10;&#10;```bash&#10;./dev-tools.sh&#10;```&#10;&#10;Available commands:&#10;- `clean`: Clean build artifacts&#10;- `compile`: Compile source code&#10;- `test`: Run all tests&#10;- `package`: Create JAR file&#10;- `install`: Install to local Maven repository&#10;- `format`: Format code using Google Java Format&#10;&#10;##  API Documentation&#10;&#10;### Core Classes&#10;&#10;#### DatabaseManager&#10;The main class for database operations.&#10;&#10;**Basic CRUD operations:**&#10;- `save(T entity)` - Save entity to database&#10;- `update(T entity)` - Update existing entity&#10;- `findById(Class&lt;T&gt; entityClass, Object id)` - Find entity by ID&#10;- `findAll(Class&lt;T&gt; entityClass)` - Find all entities&#10;- `deleteById(Class&lt;T&gt; entityClass, Object id)` - Delete entity by ID&#10;&#10;**Query operations:**&#10;- `findByColumn(Class&lt;T&gt; entityClass, String columnName, Object value)` - Find by column value&#10;- `executeQuery(String sql, Class&lt;T&gt; resultClass, Object... params)` - Execute custom query&#10;&#10;**Schema operations:**&#10;- `createTablesFromEntities(Class&lt;?&gt;... entityClasses)` - Create tables from entities&#10;- `dropTable(String tableName)` - Drop table&#10;&#10;#### BackupManager&#10;Advanced backup and export functionality.&#10;&#10;**Backup operations:**&#10;- `createBackup(String backupPath)` - Create SQL backup&#10;- `createCompressedBackup(String backupPath)` - Create compressed backup&#10;- `restoreFromBackup(String backupPath)` - Restore from backup&#10;&#10;**Export operations:**&#10;- `exportToCSV(String tableName, String filePath)` - Export to CSV&#10;- `exportToJSON(String tableName, String filePath)` - Export to JSON&#10;- `exportToExcel(String tableName, String filePath)` - Export to Excel&#10;&#10;**Scheduled backups:**&#10;- `scheduleBackup(Duration interval, String backupDirectory)` - Schedule automatic backups&#10;&#10;### Annotations&#10;&#10;#### @Entity&#10;Marks a class as a database entity.&#10;&#10;#### @Table&#10;Specifies table details:&#10;- `name` - Custom table name&#10;&#10;#### @Id&#10;Marks the primary key field.&#10;&#10;#### @GeneratedValue&#10;Configures auto-generation of primary key values:&#10;- `strategy` - Generation strategy (IDENTITY, AUTO, etc.)&#10;&#10;#### @Column&#10;Configures column properties:&#10;- `name` - Custom column name&#10;- `nullable` - Whether column can be null&#10;- `unique` - Whether column values must be unique&#10;- `length` - Maximum column length&#10;&#10;##  Testing&#10;&#10;### Running Tests&#10;&#10;```bash&#10;# Run all tests&#10;./mvnw test&#10;&#10;# Run specific test class&#10;./mvnw test -Dtest=DatabaseManagerTest&#10;&#10;# Run tests with coverage&#10;./mvnw jacoco:prepare-agent test jacoco:report&#10;```&#10;&#10;### Test Categories&#10;&#10;- **Unit Tests**: Core functionality testing&#10;- **Integration Tests**: Database integration testing&#10;- **Performance Tests**: Load and performance testing&#10;&#10;### Sample Test&#10;&#10;```java&#10;@Test&#10;public void testSaveAndFindUser() {&#10;    // Given&#10;    User user = new User(&quot;testuser&quot;, &quot;test@example.com&quot;);&#10;    &#10;    // When&#10;    User savedUser = dbManager.save(user);&#10;    Optional&lt;User&gt; foundUser = dbManager.findById(User.class, savedUser.getId());&#10;    &#10;    // Then&#10;    assertTrue(foundUser.isPresent());&#10;    assertEquals(&quot;testuser&quot;, foundUser.get().getUsername());&#10;}&#10;```&#10;&#10;##  Release Process&#10;&#10;### Version Management&#10;&#10;The project follows [Semantic Versioning](https://semver.org/):&#10;- **MAJOR**: Incompatible API changes&#10;- **MINOR**: Backwards-compatible functionality additions&#10;- **PATCH**: Backwards-compatible bug fixes&#10;&#10;### Release Steps&#10;&#10;1. **Update Version**&#10;   ```bash&#10;   ./mvnw versions:set -DnewVersion=1.1.0&#10;   ```&#10;&#10;2. **Run Full Test Suite**&#10;   ```bash&#10;   ./mvnw clean test&#10;   ```&#10;&#10;3. **Create Release Build**&#10;   ```bash&#10;   ./release.sh&#10;   ```&#10;&#10;4. **Tag Release**&#10;   ```bash&#10;   git tag -a v1.1.0 -m &quot;Release version 1.1.0&quot;&#10;   git push origin v1.1.0&#10;   ```&#10;&#10;### Build Artifacts&#10;&#10;The release process generates:&#10;- `h2-orm-{version}.jar` - Main library&#10;- `h2-orm-{version}-sources.jar` - Source code&#10;- `h2-orm-{version}-javadoc.jar` - API documentation&#10;&#10;##  Configuration&#10;&#10;### Database Configuration&#10;&#10;Create `h2-orm-config.xml` in your resources directory:&#10;&#10;```xml&#10;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;configuration&gt;&#10;    &lt;database&gt;&#10;        &lt;url&gt;jdbc:h2:./data/myapp&lt;/url&gt;&#10;        &lt;username&gt;sa&lt;/username&gt;&#10;        &lt;password&gt;&lt;/password&gt;&#10;        &lt;dialect&gt;H2&lt;/dialect&gt;&#10;        &lt;showSql&gt;true&lt;/showSql&gt;&#10;        &lt;formatSql&gt;true&lt;/formatSql&gt;&#10;    &lt;/database&gt;&#10;    &#10;    &lt;backup&gt;&#10;        &lt;autoBackup&gt;true&lt;/autoBackup&gt;&#10;        &lt;backupInterval&gt;24h&lt;/backupInterval&gt;&#10;        &lt;backupDirectory&gt;./backups&lt;/backupDirectory&gt;&#10;        &lt;compressionEnabled&gt;true&lt;/compressionEnabled&gt;&#10;        &lt;maxBackupFiles&gt;10&lt;/maxBackupFiles&gt;&#10;    &lt;/backup&gt;&#10;    &#10;    &lt;logging&gt;&#10;        &lt;level&gt;INFO&lt;/level&gt;&#10;        &lt;file&gt;./logs/h2-orm.log&lt;/file&gt;&#10;    &lt;/logging&gt;&#10;&lt;/configuration&gt;&#10;```&#10;&#10;### Environment Variables&#10;&#10;| Variable | Description | Default |&#10;|----------|-------------|---------|&#10;| `H2_ORM_DB_URL` | Database URL | `jdbc:h2:./data/default` |&#10;| `H2_ORM_DB_USER` | Database username | `sa` |&#10;| `H2_ORM_DB_PASSWORD` | Database password | (empty) |&#10;| `H2_ORM_SHOW_SQL` | Show SQL queries | `false` |&#10;| `H2_ORM_BACKUP_DIR` | Backup directory | `./backups` |&#10;&#10;##  Advanced Features&#10;&#10;### Backup and Export&#10;&#10;```java&#10;// Create backup manager&#10;BackupManager backupManager = new BackupManager(dbManager);&#10;&#10;// Manual backup&#10;backupManager.createBackup(&quot;./backups/manual_backup.sql&quot;);&#10;&#10;// Compressed backup&#10;backupManager.createCompressedBackup(&quot;./backups/compressed_backup.gz&quot;);&#10;&#10;// Export to different formats&#10;backupManager.exportToCSV(&quot;users&quot;, &quot;./exports/users.csv&quot;);&#10;backupManager.exportToJSON(&quot;users&quot;, &quot;./exports/users.json&quot;);&#10;backupManager.exportToExcel(&quot;users&quot;, &quot;./exports/users.xlsx&quot;);&#10;&#10;// Scheduled backups&#10;backupManager.scheduleBackup(Duration.ofHours(24), &quot;./backups&quot;);&#10;```&#10;&#10;### Query Builder&#10;&#10;```java&#10;// Build complex queries&#10;List&lt;User&gt; activeUsers = dbManager.queryBuilder(User.class)&#10;    .where(&quot;status&quot;, &quot;ACTIVE&quot;)&#10;    .and(&quot;created_at&quot;, &quot;&gt;&quot;, LocalDateTime.now().minusDays(30))&#10;    .orderBy(&quot;created_at&quot;, &quot;DESC&quot;)&#10;    .limit(100)&#10;    .execute();&#10;```&#10;&#10;### Transaction Management&#10;&#10;```java&#10;// Manual transaction management&#10;dbManager.executeInTransaction(() -&gt; {&#10;    User user = new User(&quot;john&quot;, &quot;john@example.com&quot;);&#10;    dbManager.save(user);&#10;    &#10;    Profile profile = new Profile(user.getId(), &quot;John Doe&quot;);&#10;    dbManager.save(profile);&#10;    &#10;    return null; // Transaction will be committed&#10;});&#10;```&#10;&#10;## ️ Troubleshooting&#10;&#10;### Common Issues&#10;&#10;1. **Database Connection Failed**&#10;   - Check database URL format&#10;   - Verify database server is running&#10;   - Check credentials&#10;&#10;2. **Table Not Found**&#10;   - Ensure entities are properly annotated&#10;   - Call `createTablesFromEntities()` before operations&#10;&#10;3. **Primary Key Errors**&#10;   - Verify `@Id` annotation is present&#10;   - Check `@GeneratedValue` configuration&#10;&#10;### Debug Logging&#10;&#10;Enable debug logging in your configuration:&#10;&#10;```xml&#10;&lt;logging&gt;&#10;    &lt;level&gt;DEBUG&lt;/level&gt;&#10;&lt;/logging&gt;&#10;```&#10;&#10;Or set environment variable:&#10;```bash&#10;export H2_ORM_LOG_LEVEL=DEBUG&#10;```&#10;&#10;##  Examples&#10;&#10;Check the `examples/` directory for complete working examples:&#10;- Basic CRUD operations&#10;- Advanced querying&#10;- Backup and export&#10;- Multiple database types&#10;- Spring Boot integration&#10;&#10;##  Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch&#10;3. Make your changes&#10;4. Add tests for new functionality&#10;5. Run the test suite&#10;6. Submit a pull request&#10;&#10;##  License&#10;&#10;This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.&#10;&#10;##  Support&#10;&#10;-  Email: support@h2-orm.com&#10;-  Discord: H2-ORM Community&#10;-  Issues: GitHub Issues&#10;-  Documentation: Full Documentation&#10;&#10;---&#10;&#10;Made with ❤️ by the H2-ORM Team" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;packaging&gt;jar&lt;/packaging&gt;&#10;&#10;    &lt;name&gt;H2-ORM&lt;/name&gt;&#10;    &lt;description&gt;Modern Spring Boot-style ORM library supporting H2, MySQL, PostgreSQL, and SQLite with advanced backup/export features&lt;/description&gt;&#10;    &lt;url&gt;https://github.com/W1LDN16H7/h2-orm&lt;/url&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;        &lt;maven.compiler.target&gt;24&lt;/maven.compiler.target&gt;&#10;        &lt;maven.compiler.source&gt;24&lt;/maven.compiler.source&gt;&#10;        &lt;junit.version&gt;5.13.2&lt;/junit.version&gt;&#10;&#10;        &lt;hibernate.version&gt;6.6.3.Final&lt;/hibernate.version&gt;&#10;        &lt;jakarta.persistence.version&gt;3.2.0&lt;/jakarta.persistence.version&gt;&#10;        &lt;hikaricp.version&gt;6.2.1&lt;/hikaricp.version&gt;&#10;        &lt;h2.version&gt;2.3.232&lt;/h2.version&gt;&#10;        &lt;mysql.version&gt;8.4.0&lt;/mysql.version&gt;&#10;        &lt;postgresql.version&gt;42.7.4&lt;/postgresql.version&gt;&#10;        &lt;sqlite.version&gt;3.46.1.3&lt;/sqlite.version&gt;&#10;        &lt;jackson.version&gt;2.19.0&lt;/jackson.version&gt;&#10;        &lt;poi.version&gt;5.4.1&lt;/poi.version&gt;&#10;        &lt;slf4j.version&gt;2.0.17&lt;/slf4j.version&gt;&#10;        &lt;logback.version&gt;1.5.18&lt;/logback.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- JPA &amp; Hibernate --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${jakarta.persistence.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-hikaricp&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Connection Pool --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;&#10;            &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;&#10;            &lt;version&gt;${hikaricp.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Database Drivers --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.h2database&lt;/groupId&gt;&#10;            &lt;artifactId&gt;h2&lt;/artifactId&gt;&#10;            &lt;version&gt;${h2.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.mysql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;&#10;            &lt;version&gt;9.4.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;            &lt;version&gt;${postgresql.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.xerial&lt;/groupId&gt;&#10;            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;&#10;            &lt;version&gt;${sqlite.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JSON Processing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Excel Export --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Logging --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${slf4j.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;&#10;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;&#10;            &lt;version&gt;${logback.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Testing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;&#10;            &lt;version&gt;5.11.4&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;!-- Compiler Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.13.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;17&lt;/source&gt;&#10;                    &lt;target&gt;17&lt;/target&gt;&#10;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Source Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.3.1&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-sources&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Javadoc Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.11.1&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;doclint&gt;none&lt;/doclint&gt;&#10;                    &lt;quiet&gt;true&lt;/quiet&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-javadocs&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Assembly Plugin for fat JAR --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.7.1&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;descriptorRefs&gt;&#10;                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;&#10;                    &lt;/descriptorRefs&gt;&#10;                    &lt;archive&gt;&#10;                        &lt;manifest&gt;&#10;                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;&#10;                        &lt;/manifest&gt;&#10;                    &lt;/archive&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;make-assembly&lt;/id&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;single&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Shade Plugin for uber JAR --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.6.0&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;shade&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                        &lt;configuration&gt;&#10;                            &lt;shadedArtifactAttached&gt;true&lt;/shadedArtifactAttached&gt;&#10;                            &lt;shadedClassifierName&gt;uber&lt;/shadedClassifierName&gt;&#10;                            &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;&#10;                            &lt;transformers&gt;&#10;                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;&#10;                                    &lt;manifestEntries&gt;&#10;                                        &lt;Built-By&gt;JPA Database Handler&lt;/Built-By&gt;&#10;                                        &lt;Implementation-Version&gt;${project.version}&lt;/Implementation-Version&gt;&#10;                                    &lt;/manifestEntries&gt;&#10;                                &lt;/transformer&gt;&#10;                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&gt;&#10;                            &lt;/transformers&gt;&#10;                        &lt;/configuration&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Test Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.5.2&lt;/version&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;    &lt;licenses&gt;&#10;        &lt;license&gt;&#10;            &lt;name&gt;MIT License&lt;/name&gt;&#10;            &lt;url&gt;https://opensource.org/licenses/MIT&lt;/url&gt;&#10;            &lt;distribution&gt;repo&lt;/distribution&gt;&#10;        &lt;/license&gt;&#10;    &lt;/licenses&gt;&#10;&#10;    &lt;developers&gt;&#10;        &lt;developer&gt;&#10;            &lt;id&gt;h2orm-team&lt;/id&gt;&#10;            &lt;name&gt;H2-ORM Development Team&lt;/name&gt;&#10;            &lt;email&gt;team@h2orm.com&lt;/email&gt;&#10;        &lt;/developer&gt;&#10;    &lt;/developers&gt;&#10;&#10;    &lt;scm&gt;&#10;        &lt;connection&gt;scm:git:git://github.com/W1LDN16H7/h2-orm.git&lt;/connection&gt;&#10;        &lt;developerConnection&gt;scm:git:ssh://github.com/W1LDN16H7/h2-orm.git&lt;/developerConnection&gt;&#10;        &lt;url&gt;https://github.com/W1LDN16H7/h2-orm&lt;/url&gt;&#10;    &lt;/scm&gt;&#10;&#10;&lt;/project&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;packaging&gt;jar&lt;/packaging&gt;&#10;&#10;    &lt;name&gt;H2-ORM&lt;/name&gt;&#10;    &lt;description&gt;Modern Spring Boot-style ORM library supporting H2, MySQL, PostgreSQL, and SQLite with advanced backup/export features&lt;/description&gt;&#10;    &lt;url&gt;https://github.com/W1LDN16H7/h2-orm&lt;/url&gt;&#10;    &lt;inceptionYear&gt;2025&lt;/inceptionYear&gt;&#10;&#10;    &lt;licenses&gt;&#10;        &lt;license&gt;&#10;            &lt;name&gt;MIT License&lt;/name&gt;&#10;            &lt;url&gt;https://opensource.org/licenses/MIT&lt;/url&gt;&#10;            &lt;distribution&gt;repo&lt;/distribution&gt;&#10;        &lt;/license&gt;&#10;    &lt;/licenses&gt;&#10;&#10;    &lt;developers&gt;&#10;        &lt;developer&gt;&#10;            &lt;id&gt;w1ldn16h7&lt;/id&gt;&#10;            &lt;name&gt;W1LDN16H7&lt;/name&gt;&#10;            &lt;email&gt;developer@h2orm.com&lt;/email&gt;&#10;            &lt;organization&gt;H2-ORM&lt;/organization&gt;&#10;            &lt;organizationUrl&gt;https://github.com/W1LDN16H7&lt;/organizationUrl&gt;&#10;            &lt;roles&gt;&#10;                &lt;role&gt;Lead Developer&lt;/role&gt;&#10;                &lt;role&gt;Architect&lt;/role&gt;&#10;            &lt;/roles&gt;&#10;            &lt;timezone&gt;+0&lt;/timezone&gt;&#10;        &lt;/developer&gt;&#10;    &lt;/developers&gt;&#10;&#10;    &lt;scm&gt;&#10;        &lt;url&gt;https://github.com/W1LDN16H7/h2-orm&lt;/url&gt;&#10;        &lt;connection&gt;scm:git:git://github.com/W1LDN16H7/h2-orm.git&lt;/connection&gt;&#10;        &lt;developerConnection&gt;scm:git:ssh://git@github.com/W1LDN16H7/h2-orm.git&lt;/developerConnection&gt;&#10;        &lt;tag&gt;HEAD&lt;/tag&gt;&#10;    &lt;/scm&gt;&#10;&#10;    &lt;issueManagement&gt;&#10;        &lt;system&gt;GitHub Issues&lt;/system&gt;&#10;        &lt;url&gt;https://github.com/W1LDN16H7/h2-orm/issues&lt;/url&gt;&#10;    &lt;/issueManagement&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&#10;        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;&#10;        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.release&gt;21&lt;/maven.compiler.release&gt;&#10;        &lt;junit.version&gt;5.13.2&lt;/junit.version&gt;&#10;&#10;        &lt;!-- Core Dependencies --&gt;&#10;        &lt;hibernate.version&gt;6.6.3.Final&lt;/hibernate.version&gt;&#10;        &lt;jakarta.persistence.version&gt;3.2.0&lt;/jakarta.persistence.version&gt;&#10;        &lt;hikaricp.version&gt;6.2.1&lt;/hikaricp.version&gt;&#10;        &#10;        &lt;!-- Database Drivers --&gt;&#10;        &lt;h2.version&gt;2.3.232&lt;/h2.version&gt;&#10;        &lt;mysql.version&gt;8.4.0&lt;/mysql.version&gt;&#10;        &lt;postgresql.version&gt;42.7.4&lt;/postgresql.version&gt;&#10;        &lt;sqlite.version&gt;3.46.1.3&lt;/sqlite.version&gt;&#10;        &#10;        &lt;!-- Utils --&gt;&#10;        &lt;jackson.version&gt;2.19.0&lt;/jackson.version&gt;&#10;        &lt;poi.version&gt;5.4.1&lt;/poi.version&gt;&#10;        &lt;slf4j.version&gt;2.0.17&lt;/slf4j.version&gt;&#10;        &lt;logback.version&gt;1.5.18&lt;/logback.version&gt;&#10;&#10;        &lt;!-- Plugin Versions --&gt;&#10;        &lt;maven.compiler.plugin.version&gt;3.13.0&lt;/maven.compiler.plugin.version&gt;&#10;        &lt;maven.surefire.plugin.version&gt;3.5.2&lt;/maven.surefire.plugin.version&gt;&#10;        &lt;maven.failsafe.plugin.version&gt;3.5.2&lt;/maven.failsafe.plugin.version&gt;&#10;        &lt;maven.source.plugin.version&gt;3.3.1&lt;/maven.source.plugin.version&gt;&#10;        &lt;maven.javadoc.plugin.version&gt;3.11.1&lt;/maven.javadoc.plugin.version&gt;&#10;        &lt;maven.gpg.plugin.version&gt;3.2.7&lt;/maven.gpg.plugin.version&gt;&#10;        &lt;maven.release.plugin.version&gt;3.1.1&lt;/maven.release.plugin.version&gt;&#10;        &lt;maven.assembly.plugin.version&gt;3.7.1&lt;/maven.assembly.plugin.version&gt;&#10;        &lt;jacoco.plugin.version&gt;0.8.12&lt;/jacoco.plugin.version&gt;&#10;        &lt;spotbugs.plugin.version&gt;4.8.6.4&lt;/spotbugs.plugin.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- JPA &amp; Hibernate --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${jakarta.persistence.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-hikaricp&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Connection Pool --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;&#10;            &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;&#10;            &lt;version&gt;${hikaricp.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Database Drivers --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.h2database&lt;/groupId&gt;&#10;            &lt;artifactId&gt;h2&lt;/artifactId&gt;&#10;            &lt;version&gt;${h2.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.mysql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;&#10;            &lt;version&gt;9.4.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;            &lt;version&gt;${postgresql.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.xerial&lt;/groupId&gt;&#10;            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;&#10;            &lt;version&gt;${sqlite.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JSON Processing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Excel Export --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Logging --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${slf4j.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;&#10;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;&#10;            &lt;version&gt;${logback.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Testing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;&#10;            &lt;version&gt;5.11.4&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;!-- Compiler Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.compiler.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;release&gt;${maven.compiler.release}&lt;/release&gt;&#10;                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;&#10;                    &lt;compilerArgs&gt;&#10;                        &lt;arg&gt;-parameters&lt;/arg&gt;&#10;                        &lt;arg&gt;-Xlint:all&lt;/arg&gt;&#10;                        &lt;arg&gt;-Xlint:-processing&lt;/arg&gt;&#10;                    &lt;/compilerArgs&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Surefire Plugin for Unit Tests --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.surefire.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;includes&gt;&#10;                        &lt;include&gt;**/*Test.java&lt;/include&gt;&#10;                        &lt;include&gt;**/*Tests.java&lt;/include&gt;&#10;                    &lt;/includes&gt;&#10;                    &lt;excludes&gt;&#10;                        &lt;exclude&gt;**/*IntegrationTest.java&lt;/exclude&gt;&#10;                    &lt;/excludes&gt;&#10;                    &lt;systemPropertyVariables&gt;&#10;                        &lt;java.util.logging.manager&gt;org.jboss.logmanager.LogManager&lt;/java.util.logging.manager&gt;&#10;                    &lt;/systemPropertyVariables&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Failsafe Plugin for Integration Tests --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.failsafe.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;includes&gt;&#10;                        &lt;include&gt;**/*IntegrationTest.java&lt;/include&gt;&#10;                        &lt;include&gt;**/*IT.java&lt;/include&gt;&#10;                    &lt;/includes&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;integration-test&lt;/goal&gt;&#10;                            &lt;goal&gt;verify&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Source Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.source.plugin.version}&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-sources&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Javadoc Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.javadoc.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;${maven.compiler.source}&lt;/source&gt;&#10;                    &lt;target&gt;${maven.compiler.target}&lt;/target&gt;&#10;                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;&#10;                    &lt;doctitle&gt;${project.name} ${project.version} API&lt;/doctitle&gt;&#10;                    &lt;windowTitle&gt;${project.name} ${project.version} API&lt;/windowTitle&gt;&#10;                    &lt;show&gt;public&lt;/show&gt;&#10;                    &lt;nohelp&gt;true&lt;/nohelp&gt;&#10;                    &lt;failOnError&gt;false&lt;/failOnError&gt;&#10;                    &lt;failOnWarnings&gt;false&lt;/failOnWarnings&gt;&#10;                    &lt;additionalJOptions&gt;&#10;                        &lt;additionalJOption&gt;-Xdoclint:none&lt;/additionalJOption&gt;&#10;                    &lt;/additionalJOptions&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-javadocs&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Assembly Plugin for Distribution --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.assembly.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;descriptorRefs&gt;&#10;                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;&#10;                    &lt;/descriptorRefs&gt;&#10;                    &lt;finalName&gt;${project.artifactId}-${project.version}-complete&lt;/finalName&gt;&#10;                    &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;make-assembly&lt;/id&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;single&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- JaCoCo for Code Coverage --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.jacoco&lt;/groupId&gt;&#10;                &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${jacoco.plugin.version}&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;prepare-agent&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;report&lt;/id&gt;&#10;                        &lt;phase&gt;test&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;report&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- SpotBugs for Static Analysis --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;com.github.spotbugs&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spotbugs-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${spotbugs.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;effort&gt;Max&lt;/effort&gt;&#10;                    &lt;threshold&gt;Low&lt;/threshold&gt;&#10;                    &lt;failOnError&gt;false&lt;/failOnError&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;    &lt;profiles&gt;&#10;        &lt;!-- Release Profile --&gt;&#10;        &lt;profile&gt;&#10;            &lt;id&gt;release&lt;/id&gt;&#10;            &lt;build&gt;&#10;                &lt;plugins&gt;&#10;                    &lt;!-- GPG Plugin for Signing --&gt;&#10;                    &lt;plugin&gt;&#10;                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                        &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;&#10;                        &lt;version&gt;${maven.gpg.plugin.version}&lt;/version&gt;&#10;                        &lt;executions&gt;&#10;                            &lt;execution&gt;&#10;                                &lt;id&gt;sign-artifacts&lt;/id&gt;&#10;                                &lt;phase&gt;verify&lt;/phase&gt;&#10;                                &lt;goals&gt;&#10;                                    &lt;goal&gt;sign&lt;/goal&gt;&#10;                                &lt;/goals&gt;&#10;                            &lt;/execution&gt;&#10;                        &lt;/executions&gt;&#10;                    &lt;/plugin&gt;&#10;                &lt;/plugins&gt;&#10;            &lt;/build&gt;&#10;        &lt;/profile&gt;&#10;&#10;        &lt;!-- Development Profile --&gt;&#10;        &lt;profile&gt;&#10;            &lt;id&gt;dev&lt;/id&gt;&#10;            &lt;activation&gt;&#10;                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;&#10;            &lt;/activation&gt;&#10;            &lt;properties&gt;&#10;                &lt;maven.test.skip&gt;false&lt;/maven.test.skip&gt;&#10;            &lt;/properties&gt;&#10;        &lt;/profile&gt;&#10;&#10;        &lt;!-- Fast Build Profile --&gt;&#10;        &lt;profile&gt;&#10;            &lt;id&gt;fast&lt;/id&gt;&#10;            &lt;properties&gt;&#10;                &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt;&#10;                &lt;maven.javadoc.skip&gt;true&lt;/maven.javadoc.skip&gt;&#10;                &lt;spotbugs.skip&gt;true&lt;/spotbugs.skip&gt;&#10;                &lt;jacoco.skip&gt;true&lt;/jacoco.skip&gt;&#10;            &lt;/properties&gt;&#10;        &lt;/profile&gt;&#10;    &lt;/profiles&gt;&#10;&#10;    &lt;distributionManagement&gt;&#10;        &lt;snapshotRepository&gt;&#10;            &lt;id&gt;ossrh&lt;/id&gt;&#10;            &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;&#10;        &lt;/snapshotRepository&gt;&#10;        &lt;repository&gt;&#10;            &lt;id&gt;ossrh&lt;/id&gt;&#10;            &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;&#10;        &lt;/repository&gt;&#10;    &lt;/distributionManagement&gt;&#10;&lt;/project&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/EntityManagerProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/EntityManagerProvider.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.config.DatabaseProperties;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Enhanced EntityManager Provider for H2-ORM library&#10; * Supports H2, SQLite, MySQL, PostgreSQL with advanced configuration management&#10; */&#10;public class EntityManagerProvider {&#10;    private static final Logger logger = LoggerFactory.getLogger(EntityManagerProvider.class);&#10;    private static final Map&lt;String, EntityManagerFactory&gt; factories = new ConcurrentHashMap&lt;&gt;();&#10;    private static final ThreadLocal&lt;EntityManager&gt; entityManagerThreadLocal = new ThreadLocal&lt;&gt;();&#10;    private static String defaultConfigName = &quot;default&quot;;&#10;    private static DatabaseConfiguration currentConfig;&#10;&#10;    /**&#10;     * Initialize with default configuration from properties&#10;     */&#10;    public static void initialize() {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromProperties();&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with custom properties file&#10;     */&#10;    public static void initialize(String propertiesFile) {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with specific configuration&#10;     */&#10;    public static void initialize(DatabaseConfiguration config) {&#10;        initialize(defaultConfigName, config);&#10;        currentConfig = config;&#10;    }&#10;&#10;    /**&#10;     * Initialize with named configuration for multi-database support&#10;     */&#10;    public static void initialize(String configName, DatabaseConfiguration config) {&#10;        EntityManagerFactory existingFactory = factories.get(configName);&#10;        if (existingFactory != null &amp;&amp; existingFactory.isOpen()) {&#10;            existingFactory.close();&#10;        }&#10;&#10;        try {&#10;            Map&lt;String, Object&gt; properties = buildJpaProperties(config);&#10;&#10;            logger.info(&quot;Initializing EntityManagerFactory for config: {} with database: {}&quot;,&#10;                    configName, config.getUrl());&#10;&#10;            EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;h2-orm-pu&quot;, properties);&#10;            factories.put(configName, factory);&#10;&#10;            logger.info(&quot;EntityManagerFactory initialized successfully for config: {}&quot;, configName);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to initialize EntityManagerFactory for config: {}&quot;, configName, e);&#10;            throw new RuntimeException(&quot;Failed to initialize database connection&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for default configuration&#10;     */&#10;    public static EntityManager getEntityManager() {&#10;        return getEntityManager(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for named configuration&#10;     */&#10;    public static EntityManager getEntityManager(String configName) {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em == null || !em.isOpen()) {&#10;            EntityManagerFactory factory = factories.get(configName);&#10;            if (factory == null) {&#10;                throw new IllegalStateException(&quot;EntityManagerFactory not initialized for config: &quot; + configName);&#10;            }&#10;            em = factory.createEntityManager();&#10;            entityManagerThreadLocal.set(em);&#10;        }&#10;        return em;&#10;    }&#10;&#10;    /**&#10;     * Close current thread's EntityManager&#10;     */&#10;    public static void closeEntityManager() {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em != null &amp;&amp; em.isOpen()) {&#10;            try {&#10;                if (em.getTransaction().isActive()) {&#10;                    em.getTransaction().rollback();&#10;                }&#10;                em.close();&#10;            } catch (Exception e) {&#10;                logger.warn(&quot;Error closing EntityManager&quot;, e);&#10;            } finally {&#10;                entityManagerThreadLocal.remove();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(TransactionCallback&lt;T&gt; callback) {&#10;        return executeInTransaction(defaultConfigName, callback);&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, TransactionCallback&lt;T&gt; callback) {&#10;        EntityManager em = getEntityManager(configName);&#10;        try {&#10;            em.getTransaction().begin();&#10;            T result = callback.execute(em);&#10;            em.getTransaction().commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;            }&#10;            throw new RuntimeException(&quot;Transaction failed&quot;, e);&#10;        } finally {&#10;            closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown all EntityManagerFactories&#10;     */&#10;    public static void shutdown() {&#10;        closeEntityManager();&#10;        factories.values().forEach(factory -&gt; {&#10;            if (factory.isOpen()) {&#10;                try {&#10;                    factory.close();&#10;                } catch (Exception e) {&#10;                    logger.warn(&quot;Error closing EntityManagerFactory&quot;, e);&#10;                }&#10;            }&#10;        });&#10;        factories.clear();&#10;        logger.info(&quot;All EntityManagerFactories shut down&quot;);&#10;    }&#10;&#10;    /**&#10;     * Check if provider is initialized&#10;     */&#10;    public static boolean isInitialized() {&#10;        return isInitialized(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Check if named configuration is initialized&#10;     */&#10;    public static boolean isInitialized(String configName) {&#10;        EntityManagerFactory factory = factories.get(configName);&#10;        return factory != null &amp;&amp; factory.isOpen();&#10;    }&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public static DatabaseConfiguration getCurrentConfiguration() {&#10;        return currentConfig;&#10;    }&#10;&#10;    private static Map&lt;String, Object&gt; buildJpaProperties(DatabaseConfiguration config) {&#10;        Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();&#10;&#10;        // Basic connection properties&#10;        properties.put(&quot;jakarta.persistence.jdbc.driver&quot;, config.getDriverClass());&#10;        properties.put(&quot;jakarta.persistence.jdbc.url&quot;, config.getUrl());&#10;        properties.put(&quot;jakarta.persistence.jdbc.user&quot;, config.getUsername());&#10;        properties.put(&quot;jakarta.persistence.jdbc.password&quot;, config.getPassword());&#10;&#10;        // Hibernate specific properties&#10;        properties.put(&quot;hibernate.dialect&quot;, config.getDialect());&#10;        properties.put(&quot;hibernate.hbm2ddl.auto&quot;, config.getDdlAuto());&#10;        properties.put(&quot;hibernate.show_sql&quot;, String.valueOf(config.isShowSql()));&#10;        properties.put(&quot;hibernate.format_sql&quot;, String.valueOf(config.isFormatSql()));&#10;        properties.put(&quot;hibernate.use_sql_comments&quot;, &quot;true&quot;);&#10;&#10;        // Connection pool settings (HikariCP)&#10;        properties.put(&quot;hibernate.connection.provider_class&quot;, &quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;);&#10;        properties.put(&quot;hibernate.hikari.maximumPoolSize&quot;, String.valueOf(config.getPoolSize()));&#10;        properties.put(&quot;hibernate.hikari.minimumIdle&quot;, String.valueOf(config.getMinimumIdle()));&#10;        properties.put(&quot;hibernate.hikari.connectionTimeout&quot;, String.valueOf(config.getConnectionTimeout()));&#10;        properties.put(&quot;hibernate.hikari.idleTimeout&quot;, String.valueOf(config.getIdleTimeout()));&#10;        properties.put(&quot;hibernate.hikari.maxLifetime&quot;, String.valueOf(config.getMaxLifetime()));&#10;        properties.put(&quot;hibernate.hikari.poolName&quot;, config.getPoolName());&#10;&#10;        // Performance settings&#10;        properties.put(&quot;hibernate.jdbc.batch_size&quot;, String.valueOf(config.getBatchSize()));&#10;        properties.put(&quot;hibernate.order_inserts&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.order_updates&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.jdbc.batch_versioned_data&quot;, &quot;true&quot;);&#10;&#10;        // Cache settings - Disable caching by default for simplicity&#10;        properties.put(&quot;hibernate.cache.use_second_level_cache&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.cache.use_query_cache&quot;, &quot;false&quot;);&#10;&#10;        if (config.isUseSecondLevelCache()) {&#10;            // Use Hibernate's built-in cache instead of JCache&#10;            properties.put(&quot;hibernate.cache.region.factory_class&quot;, &quot;org.hibernate.cache.internal.NoCacheRegionFactory&quot;);&#10;        }&#10;&#10;        // Additional optimizations&#10;        properties.put(&quot;hibernate.connection.autocommit&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.jdbc.lob.non_contextual_creation&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.temp.use_jdbc_metadata_defaults&quot;, &quot;false&quot;);&#10;&#10;        return properties;&#10;    }&#10;&#10;    /**&#10;     * Functional interface for transaction callbacks&#10;     */&#10;    @FunctionalInterface&#10;    public interface TransactionCallback&lt;T&gt; {&#10;        T execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.config.DatabaseProperties;&#10;import h2.orm.exception.DatabaseNotInitializedException;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Enhanced EntityManager Provider for H2-ORM library&#10; * Supports H2, SQLite, MySQL, PostgreSQL with advanced configuration management&#10; */&#10;public class EntityManagerProvider {&#10;    private static final Logger logger = LoggerFactory.getLogger(EntityManagerProvider.class);&#10;    private static final Map&lt;String, EntityManagerFactory&gt; factories = new ConcurrentHashMap&lt;&gt;();&#10;    private static final ThreadLocal&lt;EntityManager&gt; entityManagerThreadLocal = new ThreadLocal&lt;&gt;();&#10;    private static String defaultConfigName = &quot;default&quot;;&#10;    private static DatabaseConfiguration currentConfig;&#10;&#10;    /**&#10;     * Initialize with default configuration from properties&#10;     */&#10;    public static void initialize() {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromProperties();&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with custom properties file&#10;     */&#10;    public static void initialize(String propertiesFile) {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with specific configuration&#10;     */&#10;    public static void initialize(DatabaseConfiguration config) {&#10;        initialize(defaultConfigName, config);&#10;        currentConfig = config;&#10;    }&#10;&#10;    /**&#10;     * Initialize with named configuration for multi-database support&#10;     */&#10;    public static void initialize(String configName, DatabaseConfiguration config) {&#10;        EntityManagerFactory existingFactory = factories.get(configName);&#10;        if (existingFactory != null &amp;&amp; existingFactory.isOpen()) {&#10;            existingFactory.close();&#10;        }&#10;&#10;        try {&#10;            Map&lt;String, Object&gt; properties = buildJpaProperties(config);&#10;&#10;            logger.info(&quot;Initializing EntityManagerFactory for config: {} with database: {}&quot;,&#10;                    configName, config.getUrl());&#10;&#10;            EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;h2-orm-pu&quot;, properties);&#10;            factories.put(configName, factory);&#10;&#10;            logger.info(&quot;EntityManagerFactory initialized successfully for config: {}&quot;, configName);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to initialize EntityManagerFactory for config: {}&quot;, configName, e);&#10;            throw new RuntimeException(&quot;Failed to initialize database connection&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for default configuration&#10;     */&#10;    public static EntityManager getEntityManager() {&#10;        return getEntityManager(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for named configuration&#10;     */&#10;    public static EntityManager getEntityManager(String configName) {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em == null || !em.isOpen()) {&#10;            EntityManagerFactory factory = factories.get(configName);&#10;            if (factory == null) {&#10;                throw new DatabaseNotInitializedException();&#10;            }&#10;            em = factory.createEntityManager();&#10;            entityManagerThreadLocal.set(em);&#10;        }&#10;        return em;&#10;    }&#10;&#10;    /**&#10;     * Close current thread's EntityManager&#10;     */&#10;    public static void closeEntityManager() {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em != null &amp;&amp; em.isOpen()) {&#10;            try {&#10;                if (em.getTransaction().isActive()) {&#10;                    em.getTransaction().rollback();&#10;                }&#10;                em.close();&#10;            } catch (Exception e) {&#10;                logger.warn(&quot;Error closing EntityManager&quot;, e);&#10;            } finally {&#10;                entityManagerThreadLocal.remove();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(TransactionCallback&lt;T&gt; callback) {&#10;        return executeInTransaction(defaultConfigName, callback);&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, TransactionCallback&lt;T&gt; callback) {&#10;        EntityManager em = getEntityManager(configName);&#10;        try {&#10;            em.getTransaction().begin();&#10;            T result = callback.execute(em);&#10;            em.getTransaction().commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;            }&#10;            throw new RuntimeException(&quot;Transaction failed&quot;, e);&#10;        } finally {&#10;            closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown all EntityManagerFactories&#10;     */&#10;    public static void shutdown() {&#10;        closeEntityManager();&#10;        factories.values().forEach(factory -&gt; {&#10;            if (factory.isOpen()) {&#10;                try {&#10;                    factory.close();&#10;                } catch (Exception e) {&#10;                    logger.warn(&quot;Error closing EntityManagerFactory&quot;, e);&#10;                }&#10;            }&#10;        });&#10;        factories.clear();&#10;        logger.info(&quot;All EntityManagerFactories shut down&quot;);&#10;    }&#10;&#10;    /**&#10;     * Check if provider is initialized&#10;     */&#10;    public static boolean isInitialized() {&#10;        return isInitialized(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Check if named configuration is initialized&#10;     */&#10;    public static boolean isInitialized(String configName) {&#10;        EntityManagerFactory factory = factories.get(configName);&#10;        return factory != null &amp;&amp; factory.isOpen();&#10;    }&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public static DatabaseConfiguration getCurrentConfiguration() {&#10;        return currentConfig;&#10;    }&#10;&#10;    private static Map&lt;String, Object&gt; buildJpaProperties(DatabaseConfiguration config) {&#10;        Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();&#10;&#10;        // Basic connection properties&#10;        properties.put(&quot;jakarta.persistence.jdbc.driver&quot;, config.getDriverClass());&#10;        properties.put(&quot;jakarta.persistence.jdbc.url&quot;, config.getUrl());&#10;        properties.put(&quot;jakarta.persistence.jdbc.user&quot;, config.getUsername());&#10;        properties.put(&quot;jakarta.persistence.jdbc.password&quot;, config.getPassword());&#10;&#10;        // Hibernate specific properties&#10;        properties.put(&quot;hibernate.dialect&quot;, config.getDialect());&#10;        properties.put(&quot;hibernate.hbm2ddl.auto&quot;, config.getDdlAuto());&#10;        properties.put(&quot;hibernate.show_sql&quot;, String.valueOf(config.isShowSql()));&#10;        properties.put(&quot;hibernate.format_sql&quot;, String.valueOf(config.isFormatSql()));&#10;        properties.put(&quot;hibernate.use_sql_comments&quot;, &quot;true&quot;);&#10;&#10;        // Connection pool settings (HikariCP)&#10;        properties.put(&quot;hibernate.connection.provider_class&quot;, &quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;);&#10;        properties.put(&quot;hibernate.hikari.maximumPoolSize&quot;, String.valueOf(config.getPoolSize()));&#10;        properties.put(&quot;hibernate.hikari.minimumIdle&quot;, String.valueOf(config.getMinimumIdle()));&#10;        properties.put(&quot;hibernate.hikari.connectionTimeout&quot;, String.valueOf(config.getConnectionTimeout()));&#10;        properties.put(&quot;hibernate.hikari.idleTimeout&quot;, String.valueOf(config.getIdleTimeout()));&#10;        properties.put(&quot;hibernate.hikari.maxLifetime&quot;, String.valueOf(config.getMaxLifetime()));&#10;        properties.put(&quot;hibernate.hikari.poolName&quot;, config.getPoolName());&#10;&#10;        // Performance settings&#10;        properties.put(&quot;hibernate.jdbc.batch_size&quot;, String.valueOf(config.getBatchSize()));&#10;        properties.put(&quot;hibernate.order_inserts&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.order_updates&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.jdbc.batch_versioned_data&quot;, &quot;true&quot;);&#10;&#10;        // Cache settings - Disable caching by default for simplicity&#10;        properties.put(&quot;hibernate.cache.use_second_level_cache&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.cache.use_query_cache&quot;, &quot;false&quot;);&#10;&#10;        if (config.isUseSecondLevelCache()) {&#10;            // Use Hibernate's built-in cache instead of JCache&#10;            properties.put(&quot;hibernate.cache.region.factory_class&quot;, &quot;org.hibernate.cache.internal.NoCacheRegionFactory&quot;);&#10;        }&#10;&#10;        // Additional optimizations&#10;        properties.put(&quot;hibernate.connection.autocommit&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.jdbc.lob.non_contextual_creation&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.temp.use_jdbc_metadata_defaults&quot;, &quot;false&quot;);&#10;&#10;        return properties;&#10;    }&#10;&#10;    /**&#10;     * Functional interface for transaction callbacks&#10;     */&#10;    @FunctionalInterface&#10;    public interface TransactionCallback&lt;T&gt; {&#10;        T execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/JpaAdvancedDatabaseHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/JpaAdvancedDatabaseHandler.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.open.autobot.database.jpa.repository.AbstractRepository;&#10;import com.open.autobot.database.jpa.repository.Repository;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.Query;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Modern JPA-based Database Handler&#10; * High-performance replacement for the original H2DatabaseHandler&#10; * Supports H2, MySQL, PostgreSQL, SQLite and other JPA-compatible databases&#10; */&#10;public class JpaAdvancedDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(JpaAdvancedDatabaseHandler.class);&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;    private final Map&lt;Class&lt;?&gt;, Repository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Initialize the database with configuration&#10;     */&#10;    public void initialize(DatabaseConfig config) {&#10;        EntityManagerProvider.initialize(config);&#10;        logger.info(&quot;JPA Advanced Database Handler initialized successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Get or create repository for entity class&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T, ID extends Serializable&gt; Repository&lt;T, ID&gt; getRepository(Class&lt;T&gt; entityClass) {&#10;        return (Repository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, clazz -&gt;&#10;            new GenericRepository&lt;&gt;((Class&lt;T&gt;) clazz)&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        return repo.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save multiple entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return new ArrayList&lt;&gt;();&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        return repo.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findAll();&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findAll(offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByAttribute(Class&lt;T&gt; entityClass, String attributeName, Object value) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByAttribute(attributeName, value);&#10;    }&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByNativeQuery(Class&lt;T&gt; entityClass, String sqlQuery, Object... params) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByNativeQuery(sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByQuery(Class&lt;T&gt; entityClass, String jpqlQuery, Object... params) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByQuery(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.count();&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean existsById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.existsById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    public &lt;T&gt; boolean existsByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.existsByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        return repo.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        repo.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    public &lt;T&gt; void deleteAll(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteAll();&#10;    }&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    public &lt;T&gt; void deleteByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    public int executeUpdate(String jpqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            Query query = em.createQuery(jpqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            int result = query.executeUpdate();&#10;            tx.commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to execute update query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Execute update operation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    public int executeNativeUpdate(String sqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            Query query = em.createNativeQuery(sqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            int result = query.executeUpdate();&#10;            tx.commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to execute native update query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Execute native update operation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Batch insert entities for high performance&#10;     */&#10;    public &lt;T&gt; void batchInsert(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return;&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        repo.batchInsert(entities);&#10;    }&#10;&#10;    /**&#10;     * Batch update entities for high performance&#10;     */&#10;    public &lt;T&gt; void batchUpdate(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return;&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        repo.batchUpdate(entities);&#10;    }&#10;&#10;    /**&#10;     * Create database schema/tables&#10;     */&#10;    public void createSchema() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            // Schema creation is handled by JPA/Hibernate automatically&#10;            // based on the ddl-auto configuration&#10;            tx.commit();&#10;            logger.info(&quot;Database schema created/updated successfully&quot;);&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to create schema: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Schema creation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Drop all tables&#10;     */&#10;    public void dropSchema() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            em.createNativeQuery(&quot;DROP ALL OBJECTS&quot;).executeUpdate();&#10;            tx.commit();&#10;            logger.info(&quot;Database schema dropped successfully&quot;);&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to drop schema: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Schema drop failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get database version&#10;     */&#10;    public String getVersion() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(&quot;SELECT VERSION()&quot;);&#10;            Object result = query.getSingleResult();&#10;            return result != null ? result.toString() : &quot;Unknown&quot;;&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Could not retrieve database version: {}&quot;, e.getMessage());&#10;            return &quot;Unknown&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute custom SQL query and return raw results&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomQuery(String sqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            @SuppressWarnings(&quot;unchecked&quot;)&#10;            List&lt;Object[]&gt; results = query.getResultList();&#10;            return results;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to execute custom query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Custom query execution failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query and return raw results&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomJpql(String jpqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createQuery(jpqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            @SuppressWarnings(&quot;unchecked&quot;)&#10;            List&lt;Object[]&gt; results = query.getResultList();&#10;            return results;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to execute custom JPQL: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Custom JPQL execution failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown the database handler&#10;     */&#10;    public void shutdown() {&#10;        EntityManagerProvider.shutdown();&#10;        logger.info(&quot;JPA Advanced Database Handler shutdown completed&quot;);&#10;    }&#10;&#10;    /**&#10;     * Generic Repository Implementation&#10;     */&#10;    private static class GenericRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;&#10;        public GenericRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;&#10;        // getEntityClass() method is inherited from AbstractRepository&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import h2.orm.repository.AbstractRepository;&#10;import h2.orm.repository.Repository;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.Query;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Advanced JPA-based Database Handler for H2-ORM Standalone Library&#10; * High-performance replacement for traditional database handlers&#10; * Supports H2, MySQL, PostgreSQL, SQLite and other JPA-compatible databases&#10; */&#10;public class JpaAdvancedDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(JpaAdvancedDatabaseHandler.class);&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;    private final Map&lt;Class&lt;?&gt;, Repository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get or create repository for entity class&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T, ID extends Serializable&gt; Repository&lt;T, ID&gt; getRepository(Class&lt;T&gt; entityClass) {&#10;        return (Repository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, clazz -&gt;&#10;            new GenericRepository&lt;&gt;((Class&lt;T&gt;) clazz)&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            em.persist(entity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity saved: {}&quot;, entity.getClass().getSimpleName());&#10;            return entity;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Save all entities in batch&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        if (entities == null || entities.isEmpty()) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;            int batchSize = 20; // Default batch size&#10;            &#10;            for (int i = 0; i &lt; entities.size(); i++) {&#10;                T entity = entities.get(i);&#10;                em.persist(entity);&#10;                savedEntities.add(entity);&#10;                &#10;                if (i % batchSize == 0 &amp;&amp; i &gt; 0) {&#10;                    em.flush();&#10;                    em.clear();&#10;                }&#10;            }&#10;            &#10;            em.flush();&#10;            logger.debug(&quot;Batch saved {} entities&quot;, entities.size());&#10;            return savedEntities;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T updated = em.merge(entity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity updated: {}&quot;, entity.getClass().getSimpleName());&#10;            return updated;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Delete an entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;            em.remove(managedEntity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity deleted: {}&quot;, entity.getClass().getSimpleName());&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T entity = em.find(entityClass, id);&#10;            if (entity != null) {&#10;                em.remove(entity);&#10;                em.flush();&#10;                logger.debug(&quot;Entity deleted by ID: {} - {}&quot;, entityClass.getSimpleName(), id);&#10;            }&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            T entity = em.find(entityClass, id);&#10;            return Optional.ofNullable(entity);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find all entities of a given class&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(root);&#10;            &#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(root);&#10;            &#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            typedQuery.setFirstResult(offset);&#10;            typedQuery.setMaxResults(limit);&#10;            &#10;            return typedQuery.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Count entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;Long&gt; query = cb.createQuery(Long.class);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(cb.count(root));&#10;            &#10;            TypedQuery&lt;Long&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getSingleResult();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean exists(Class&lt;T&gt; entityClass, Object id) {&#10;        return findById(entityClass, id).isPresent();&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            TypedQuery&lt;T&gt; query = em.createQuery(jpql, resultClass);&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            TypedQuery&lt;T&gt; query = em.createQuery(jpql, resultClass);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sql, resultClass);&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query with parameters&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sql, resultClass);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute update query&#10;     */&#10;    public int executeUpdate(String jpql) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            Query query = em.createQuery(jpql);&#10;            return query.executeUpdate();&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute update query with parameters&#10;     */&#10;    public int executeUpdate(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            Query query = em.createQuery(jpql);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.executeUpdate();&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Clear entity manager cache&#10;     */&#10;    public void clearCache() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            em.clear();&#10;            logger.debug(&quot;Entity manager cache cleared&quot;);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Flush pending changes&#10;     */&#10;    public void flush() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            em.flush();&#10;            logger.debug(&quot;Entity manager flushed&quot;);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generic Repository Implementation&#10;     */&#10;    private static class GenericRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;        &#10;        public GenericRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;        &#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/ModernJpaDatabaseHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/ModernJpaDatabaseHandler.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import com.open.autobot.database.jpa.service.BackupService;&#10;import com.open.autobot.database.jpa.service.ChatService;&#10;import com.open.autobot.database.jpa.service.ExportService;&#10;import com.open.autobot.model.Conversation;&#10;import com.open.autobot.model.Message;&#10;import com.open.autobot.model.SenderRole;&#10;import jakarta.persistence.EntityManager;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Modern JPA Advanced Database Handler&#10; *&#10; * A complete replacement for H2DatabaseHandler with modern JPA architecture&#10; * Features:&#10; * - High-performance JPA operations with connection pooling&#10; * - Support for H2, MySQL, PostgreSQL, SQLite&#10; * - Comprehensive CRUD operations&#10; * - Chat system with conversations and messages&#10; * - Backup and restore functionality&#10; * - Export to CSV, Excel, JSON&#10; * - Batch operations for optimal performance&#10; * - Transaction management&#10; * - Query caching and optimization&#10; *&#10; * Usage:&#10; * 1. Initialize with database configuration&#10; * 2. Use save(), findAll(), findById() etc. for basic operations&#10; * 3. Use chat methods for conversation management&#10; * 4. Use backup methods for data protection&#10; * 5. Use export methods for data analysis&#10; */&#10;public class ModernJpaDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(ModernJpaDatabaseHandler.class);&#10;&#10;    private final JpaAdvancedDatabaseHandler coreHandler;&#10;    private final ChatService chatService;&#10;    private final BackupService backupService;&#10;    private final ExportService exportService;&#10;&#10;    /**&#10;     * Constructor - Initialize with H2 database (default)&#10;     */&#10;    public ModernJpaDatabaseHandler() {&#10;        this(DatabaseConfig.h2());&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with custom database configuration&#10;     */&#10;    public ModernJpaDatabaseHandler(DatabaseConfig config) {&#10;        this.coreHandler = new JpaAdvancedDatabaseHandler();&#10;        this.chatService = new ChatService();&#10;        this.backupService = new BackupService();&#10;        this.exportService = new ExportService();&#10;&#10;        // Initialize the database&#10;        this.coreHandler.initialize(config);&#10;&#10;        logger.info(&quot;Modern JPA Database Handler initialized with {}&quot;,&#10;                   config.getUrl().contains(&quot;h2&quot;) ? &quot;H2&quot; :&#10;                   config.getUrl().contains(&quot;mysql&quot;) ? &quot;MySQL&quot; :&#10;                   config.getUrl().contains(&quot;postgresql&quot;) ? &quot;PostgreSQL&quot; : &quot;Other database&quot;);&#10;    }&#10;&#10;    // =====================&#10;    // CORE CRUD OPERATIONS&#10;    // =====================&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return coreHandler.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save multiple entities with batch optimization&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        return coreHandler.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.findById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.findAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination (high performance for large datasets)&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        return coreHandler.findAll(entityClass, offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByAttribute(Class&lt;T&gt; entityClass, String attributeName, Object value) {&#10;        return coreHandler.findByAttribute(entityClass, attributeName, value);&#10;    }&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        return coreHandler.findByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByNativeQuery(Class&lt;T&gt; entityClass, String sqlQuery, Object... params) {&#10;        return coreHandler.findByNativeQuery(entityClass, sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByQuery(Class&lt;T&gt; entityClass, String jpqlQuery, Object... params) {&#10;        return coreHandler.findByQuery(entityClass, jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.count(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean existsById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.existsById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    public &lt;T&gt; boolean existsByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        return coreHandler.existsByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return coreHandler.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        coreHandler.deleteById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        coreHandler.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete all entities of a type&#10;     */&#10;    public &lt;T&gt; void deleteAll(Class&lt;T&gt; entityClass) {&#10;        coreHandler.deleteAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    public &lt;T&gt; void deleteByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        coreHandler.deleteByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Batch insert for high performance&#10;     */&#10;    public &lt;T&gt; void batchInsert(List&lt;T&gt; entities) {&#10;        coreHandler.batchInsert(entities);&#10;    }&#10;&#10;    /**&#10;     * Batch update for high performance&#10;     */&#10;    public &lt;T&gt; void batchUpdate(List&lt;T&gt; entities) {&#10;        coreHandler.batchUpdate(entities);&#10;    }&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    public int executeUpdate(String jpqlQuery, Object... params) {&#10;        return coreHandler.executeUpdate(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    public int executeNativeUpdate(String sqlQuery, Object... params) {&#10;        return coreHandler.executeNativeUpdate(sqlQuery, params);&#10;    }&#10;&#10;    // =====================&#10;    // CHAT SYSTEM METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Initialize chat system (called automatically)&#10;     */&#10;    public void initializeChatTables() {&#10;        chatService.initializeChatTables();&#10;    }&#10;&#10;    /**&#10;     * Start a new conversation&#10;     */&#10;    public String startNewConversation(String userId, String title) {&#10;        return chatService.startNewConversation(userId, title);&#10;    }&#10;&#10;    /**&#10;     * Add message to conversation&#10;     */&#10;    public void addMessage(String conversationId, SenderRole role, String content) {&#10;        chatService.addMessage(conversationId, role, content);&#10;    }&#10;&#10;    /**&#10;     * Get conversation history&#10;     */&#10;    public List&lt;Message&gt; getConversationHistory(String conversationId) {&#10;        return chatService.getConversationHistory(conversationId);&#10;    }&#10;&#10;    /**&#10;     * List user conversations&#10;     */&#10;    public List&lt;Conversation&gt; listUserConversations(String userId) {&#10;        return chatService.listUserConversations(userId);&#10;    }&#10;&#10;    /**&#10;     * Rename conversation&#10;     */&#10;    public void renameConversation(String conversationId, String newTitle) {&#10;        chatService.renameConversation(conversationId, newTitle);&#10;    }&#10;&#10;    /**&#10;     * Delete conversation&#10;     */&#10;    public void deleteConversation(String conversationId) {&#10;        chatService.deleteConversation(conversationId);&#10;    }&#10;&#10;    /**&#10;     * Add simple chat message (legacy compatibility)&#10;     */&#10;    public void addChatMessage(String message) {&#10;        chatService.addChatMessage(message);&#10;    }&#10;&#10;    /**&#10;     * Load simple chat history (legacy compatibility)&#10;     */&#10;    public List&lt;String&gt; loadChatHistory() {&#10;        return chatService.loadChatHistory();&#10;    }&#10;&#10;    /**&#10;     * Clear simple chat history (legacy compatibility)&#10;     */&#10;    public void clearChatHistory() {&#10;        chatService.clearChatHistory();&#10;    }&#10;&#10;    // =====================&#10;    // BACKUP &amp; RESTORE METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Create backup of a table&#10;     */&#10;    public String backup(String tableName) {&#10;        return backupService.backup(tableName);&#10;    }&#10;&#10;    /**&#10;     * Create backup of all tables&#10;     */&#10;    public List&lt;String&gt; backupAll() {&#10;        return backupService.backupAll();&#10;    }&#10;&#10;    /**&#10;     * List backup tables&#10;     */&#10;    public List&lt;String&gt; listBackups(String baseTableName) {&#10;        return backupService.listBackups(baseTableName);&#10;    }&#10;&#10;    /**&#10;     * Restore table from backup&#10;     */&#10;    public boolean restore(String backupTableName, String targetTableName) {&#10;        return backupService.restore(backupTableName, targetTableName);&#10;    }&#10;&#10;    /**&#10;     * Delete backup table&#10;     */&#10;    public boolean deleteBackup(String backupTableName) {&#10;        return backupService.deleteBackup(backupTableName);&#10;    }&#10;&#10;    /**&#10;     * Schedule periodic backup&#10;     */&#10;    public void schedulePeriodicBackup(String tableName, long intervalMinutes) {&#10;        backupService.schedulePeriodicBackup(tableName, intervalMinutes);&#10;    }&#10;&#10;    /**&#10;     * Schedule periodic backup for all tables&#10;     */&#10;    public void schedulePeriodicBackupAll(long intervalMinutes) {&#10;        backupService.schedulePeriodicBackupAll(intervalMinutes);&#10;    }&#10;&#10;    /**&#10;     * Create database dump&#10;     */&#10;    public String createDatabaseDump(String filePath) {&#10;        return backupService.createDatabaseDump(filePath);&#10;    }&#10;&#10;    /**&#10;     * Restore from database dump&#10;     */&#10;    public boolean restoreFromDump(String filePath) {&#10;        return backupService.restoreFromDump(filePath);&#10;    }&#10;&#10;    // =====================&#10;    // EXPORT METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Export table to CSV&#10;     */&#10;    public void exportToCSV(String tableName, String filePath) {&#10;        exportService.exportToCSV(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export table to Excel&#10;     */&#10;    public void exportToExcel(String tableName, String filePath) {&#10;        exportService.exportToExcel(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export table to JSON&#10;     */&#10;    public void exportToJSON(String tableName, String filePath) {&#10;        exportService.exportToJSON(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export query results to CSV&#10;     */&#10;    public void exportQueryToCSV(String sqlQuery, String filePath, Object... params) {&#10;        exportService.exportQueryToCSV(sqlQuery, filePath, params);&#10;    }&#10;&#10;    /**&#10;     * Export multiple tables to Excel&#10;     */&#10;    public void exportMultipleTablesToExcel(List&lt;String&gt; tableNames, String filePath) {&#10;        exportService.exportMultipleTablesToExcel(tableNames, filePath);&#10;    }&#10;&#10;    /**&#10;     * Get database statistics&#10;     */&#10;    public Map&lt;String, Object&gt; getDatabaseStatistics() {&#10;        return exportService.getDatabaseStatistics();&#10;    }&#10;&#10;    /**&#10;     * Export database statistics to JSON&#10;     */&#10;    public void exportStatisticsToJSON(String filePath) {&#10;        exportService.exportStatisticsToJSON(filePath);&#10;    }&#10;&#10;    // =====================&#10;    // UTILITY METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Get database version&#10;     */&#10;    public String getVersion() {&#10;        return coreHandler.getVersion();&#10;    }&#10;&#10;    /**&#10;     * Execute custom SQL query&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomQuery(String sqlQuery, Object... params) {&#10;        return coreHandler.executeCustomQuery(sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomJpql(String jpqlQuery, Object... params) {&#10;        return coreHandler.executeCustomJpql(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for advanced operations&#10;     */&#10;    public EntityManager getEntityManager() {&#10;        return EntityManagerProvider.getEntityManager();&#10;    }&#10;&#10;    /**&#10;     * Close current EntityManager&#10;     */&#10;    public void closeEntityManager() {&#10;        EntityManagerProvider.closeEntityManager();&#10;    }&#10;&#10;    /**&#10;     * Create database schema&#10;     */&#10;    public void createSchema() {&#10;        coreHandler.createSchema();&#10;    }&#10;&#10;    /**&#10;     * Drop database schema&#10;     */&#10;    public void dropSchema() {&#10;        coreHandler.dropSchema();&#10;    }&#10;&#10;    /**&#10;     * Shutdown the database handler&#10;     */&#10;    public void shutdown() {&#10;        try {&#10;            backupService.shutdown();&#10;            coreHandler.shutdown();&#10;            logger.info(&quot;Modern JPA Database Handler shutdown completed&quot;);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error during shutdown: {}&quot;, e.getMessage());&#10;        }&#10;    }&#10;&#10;    // =====================&#10;    // FACTORY METHODS FOR DIFFERENT DATABASES&#10;    // =====================&#10;&#10;    /**&#10;     * Create handler for H2 database&#10;     */&#10;    public static ModernJpaDatabaseHandler forH2() {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.h2());&#10;    }&#10;&#10;    /**&#10;     * Create handler for MySQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler forMySQL(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.mysql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Create handler for PostgreSQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler forPostgreSQL(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.postgresql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Create handler for SQLite database&#10;     */&#10;    public static ModernJpaDatabaseHandler forSQLite(String filePath) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.sqlite(filePath));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.service.BackupService;&#10;import h2.orm.service.ExportService;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.function.Consumer;&#10;&#10;/**&#10; * Modern JPA Database Handler for H2-ORM Standalone Library&#10; *&#10; * A complete JPA-based database handler with modern architecture&#10; * Features:&#10; * - High-performance JPA operations with connection pooling&#10; * - Support for H2, MySQL, PostgreSQL, SQLite&#10; * - Comprehensive CRUD operations&#10; * - Backup and restore functionality&#10; * - Export to CSV, Excel, JSON&#10; * - Batch operations for optimal performance&#10; * - Transaction management&#10; * - Query caching and optimization&#10; * - Easy integration as standalone library&#10; *&#10; * Usage:&#10; * 1. Initialize with database configuration&#10; * 2. Use save(), findAll(), findById() etc. for basic operations&#10; * 3. Use backup methods for data protection&#10; * 4. Use export methods for data analysis&#10; */&#10;public class ModernJpaDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(ModernJpaDatabaseHandler.class);&#10;&#10;    private final JpaAdvancedDatabaseHandler coreHandler;&#10;    private final BackupService backupService;&#10;    private final ExportService exportService;&#10;    private final DatabaseConfiguration configuration;&#10;&#10;    /**&#10;     * Constructor - Initialize with default H2 configuration&#10;     */&#10;    public ModernJpaDatabaseHandler() {&#10;        this(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with H2 file-based database&#10;     */&#10;    public ModernJpaDatabaseHandler(String databasePath) {&#10;        this(DatabaseConfiguration.h2File(databasePath));&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with custom configuration&#10;     */&#10;    public ModernJpaDatabaseHandler(DatabaseConfiguration config) {&#10;        this.configuration = config;&#10;&#10;        logger.info(&quot;Initializing ModernJpaDatabaseHandler with configuration: {}&quot;, config);&#10;&#10;        // Initialize EntityManager Provider&#10;        EntityManagerProvider.initialize(config);&#10;&#10;        // Initialize core components&#10;        this.coreHandler = new JpaAdvancedDatabaseHandler();&#10;        this.backupService = new BackupService();&#10;        this.exportService = new ExportService();&#10;&#10;        logger.info(&quot;ModernJpaDatabaseHandler initialized successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Factory method for H2 in-memory database&#10;     */&#10;    public static ModernJpaDatabaseHandler h2InMemory() {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Factory method for H2 file-based database&#10;     */&#10;    public static ModernJpaDatabaseHandler h2File(String path) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.h2File(path));&#10;    }&#10;&#10;    /**&#10;     * Factory method for SQLite database&#10;     */&#10;    public static ModernJpaDatabaseHandler sqlite(String path) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.sqlite(path));&#10;    }&#10;&#10;    /**&#10;     * Factory method for MySQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler mysql(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.mysql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Factory method for PostgreSQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler postgresql(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.postgresql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Factory method from properties file&#10;     */&#10;    public static ModernJpaDatabaseHandler fromProperties(String propertiesFile) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.fromPropertiesFile(propertiesFile));&#10;    }&#10;&#10;    // ===== CRUD Operations =====&#10;&#10;    /**&#10;     * Save entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return coreHandler.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save entity with validation&#10;     */&#10;    public &lt;T&gt; T save(T entity, Consumer&lt;T&gt; validator) {&#10;        if (validator != null) {&#10;            validator.accept(entity);&#10;        }&#10;        return save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        return coreHandler.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Update entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return coreHandler.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        coreHandler.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        coreHandler.deleteById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.findById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.findAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Find with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        return coreHandler.findAll(entityClass, offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Count entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.count(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists&#10;     */&#10;    public &lt;T&gt; boolean exists(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.exists(entityClass, id);&#10;    }&#10;&#10;    // ===== Query Operations =====&#10;&#10;    /**&#10;     * Execute JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass) {&#10;        return coreHandler.query(jpql, resultClass);&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.query(jpql, resultClass, parameters);&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass) {&#10;        return coreHandler.nativeQuery(sql, resultClass);&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.nativeQuery(sql, resultClass, parameters);&#10;    }&#10;&#10;    /**&#10;     * Execute update query&#10;     */&#10;    public int executeUpdate(String jpql) {&#10;        return coreHandler.executeUpdate(jpql);&#10;    }&#10;&#10;    /**&#10;     * Execute update query with parameters&#10;     */&#10;    public int executeUpdate(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.executeUpdate(jpql, parameters);&#10;    }&#10;&#10;    // ===== Criteria API =====&#10;&#10;    /**&#10;     * Create criteria query builder&#10;     */&#10;    public &lt;T&gt; CriteriaQueryBuilder&lt;T&gt; criteriaBuilder(Class&lt;T&gt; entityClass) {&#10;        return new CriteriaQueryBuilder&lt;&gt;(entityClass);&#10;    }&#10;&#10;    // ===== Transaction Management =====&#10;&#10;    /**&#10;     * Execute in transaction&#10;     */&#10;    public &lt;T&gt; T executeInTransaction(EntityManagerProvider.TransactionCallback&lt;T&gt; callback) {&#10;        return EntityManagerProvider.executeInTransaction(callback);&#10;    }&#10;&#10;    /**&#10;     * Execute without result in transaction&#10;     */&#10;    public void executeInTransaction(TransactionCallback callback) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            callback.execute(em);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    // ===== Export Operations =====&#10;&#10;    /**&#10;     * Export to CSV&#10;     */&#10;    public &lt;T&gt; void exportToCsv(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToCsv(data, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export to Excel&#10;     */&#10;    public &lt;T&gt; void exportToExcel(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToExcel(data, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export to JSON&#10;     */&#10;    public &lt;T&gt; void exportToJson(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToJson(data, filePath);&#10;    }&#10;&#10;    // ===== Backup Operations =====&#10;&#10;    /**&#10;     * Create database backup&#10;     */&#10;    public void backup(String backupPath) {&#10;        backupService.createBackup(backupPath);&#10;    }&#10;&#10;    /**&#10;     * Restore database from backup&#10;     */&#10;    public void restore(String backupPath) {&#10;        backupService.restoreBackup(backupPath);&#10;    }&#10;&#10;    // ===== Utility Methods =====&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public DatabaseConfiguration getConfiguration() {&#10;        return configuration;&#10;    }&#10;&#10;    /**&#10;     * Check if handler is initialized&#10;     */&#10;    public boolean isInitialized() {&#10;        return EntityManagerProvider.isInitialized();&#10;    }&#10;&#10;    /**&#10;     * Shutdown handler and cleanup resources&#10;     */&#10;    public void shutdown() {&#10;        logger.info(&quot;Shutting down ModernJpaDatabaseHandler&quot;);&#10;        EntityManagerProvider.shutdown();&#10;        logger.info(&quot;ModernJpaDatabaseHandler shutdown completed&quot;);&#10;    }&#10;&#10;    // ===== Inner Classes =====&#10;&#10;    /**&#10;     * Criteria Query Builder for type-safe queries&#10;     */&#10;    public class CriteriaQueryBuilder&lt;T&gt; {&#10;        private final Class&lt;T&gt; entityClass;&#10;        private final CriteriaBuilder criteriaBuilder;&#10;        private final CriteriaQuery&lt;T&gt; query;&#10;        private final Root&lt;T&gt; root;&#10;&#10;        public CriteriaQueryBuilder(Class&lt;T&gt; entityClass) {&#10;            this.entityClass = entityClass;&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            this.criteriaBuilder = em.getCriteriaBuilder();&#10;            this.query = criteriaBuilder.createQuery(entityClass);&#10;            this.root = query.from(entityClass);&#10;        }&#10;&#10;        public CriteriaQueryBuilder&lt;T&gt; where(String fieldName, Object value) {&#10;            query.where(criteriaBuilder.equal(root.get(fieldName), value));&#10;            return this;&#10;        }&#10;&#10;        public CriteriaQueryBuilder&lt;T&gt; orderBy(String fieldName, boolean ascending) {&#10;            if (ascending) {&#10;                query.orderBy(criteriaBuilder.asc(root.get(fieldName)));&#10;            } else {&#10;                query.orderBy(criteriaBuilder.desc(root.get(fieldName)));&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public List&lt;T&gt; getResultList() {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getResultList();&#10;        }&#10;&#10;        public List&lt;T&gt; getResultList(int maxResults) {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            typedQuery.setMaxResults(maxResults);&#10;            return typedQuery.getResultList();&#10;        }&#10;&#10;        public Optional&lt;T&gt; getSingleResult() {&#10;            List&lt;T&gt; results = getResultList(1);&#10;            return results.isEmpty() ? Optional.empty() : Optional.of(results.get(0));&#10;        }&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface TransactionCallback {&#10;        void execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/MetadataManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/MetadataManager.java" />
              <option name="originalContent" value="package h2.orm.core;&#10;&#10;import jakarta.persistence.*;&#10;import jakarta.persistence.metamodel.EntityType;&#10;import jakarta.persistence.metamodel.Metamodel;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.lang.reflect.Field;&#10;import java.util.*;&#10;&#10;/**&#10; * Core metadata manager for H2-ORM&#10; * Handles entity metadata, reflection, and schema information&#10; */&#10;public class MetadataManager {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(MetadataManager.class);&#10;    private static final Map&lt;Class&lt;?&gt;, EntityMetadata&gt; metadataCache = new HashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get entity metadata with caching&#10;     */&#10;    public static EntityMetadata getEntityMetadata(Class&lt;?&gt; entityClass) {&#10;        return metadataCache.computeIfAbsent(entityClass, MetadataManager::buildEntityMetadata);&#10;    }&#10;&#10;    /**&#10;     * Get all managed entity types&#10;     */&#10;    public static Set&lt;EntityType&lt;?&gt;&gt; getAllEntityTypes() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Metamodel metamodel = em.getMetamodel();&#10;            return metamodel.getEntities();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get table name for entity&#10;     */&#10;    public static String getTableName(Class&lt;?&gt; entityClass) {&#10;        Table tableAnnotation = entityClass.getAnnotation(Table.class);&#10;        if (tableAnnotation != null &amp;&amp; !tableAnnotation.name().isEmpty()) {&#10;            return tableAnnotation.name();&#10;        }&#10;        return entityClass.getSimpleName().toLowerCase();&#10;    }&#10;&#10;    /**&#10;     * Get ID field for entity&#10;     */&#10;    public static Field getIdField(Class&lt;?&gt; entityClass) {&#10;        return getEntityMetadata(entityClass).getIdField();&#10;    }&#10;&#10;    /**&#10;     * Get ID value from entity instance&#10;     */&#10;    public static Object getIdValue(Object entity) {&#10;        try {&#10;            Field idField = getIdField(entity.getClass());&#10;            if (idField != null) {&#10;                idField.setAccessible(true);&#10;                return idField.get(entity);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Failed to get ID value from entity&quot;, e);&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Check if entity is new (ID is null or zero)&#10;     */&#10;    public static boolean isEntityNew(Object entity) {&#10;        Object idValue = getIdValue(entity);&#10;        if (idValue == null) {&#10;            return true;&#10;        }&#10;        if (idValue instanceof Number) {&#10;            return ((Number) idValue).longValue() == 0;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Get all fields with JPA annotations&#10;     */&#10;    public static List&lt;Field&gt; getJpaFields(Class&lt;?&gt; entityClass) {&#10;        return getEntityMetadata(entityClass).getJpaFields();&#10;    }&#10;&#10;    /**&#10;     * Get column name for field&#10;     */&#10;    public static String getColumnName(Field field) {&#10;        Column columnAnnotation = field.getAnnotation(Column.class);&#10;        if (columnAnnotation != null &amp;&amp; !columnAnnotation.name().isEmpty()) {&#10;            return columnAnnotation.name();&#10;        }&#10;        return field.getName();&#10;    }&#10;&#10;    /**&#10;     * Build entity metadata&#10;     */&#10;    private static EntityMetadata buildEntityMetadata(Class&lt;?&gt; entityClass) {&#10;        logger.debug(&quot;Building metadata for entity: {}&quot;, entityClass.getSimpleName());&#10;&#10;        EntityMetadata metadata = new EntityMetadata();&#10;        metadata.setEntityClass(entityClass);&#10;        metadata.setTableName(getTableName(entityClass));&#10;&#10;        List&lt;Field&gt; jpaFields = new ArrayList&lt;&gt;();&#10;        Field idField = null;&#10;&#10;        // Process all fields including inherited ones&#10;        Class&lt;?&gt; currentClass = entityClass;&#10;        while (currentClass != null &amp;&amp; !currentClass.equals(Object.class)) {&#10;            for (Field field : currentClass.getDeclaredFields()) {&#10;                if (hasJpaAnnotation(field)) {&#10;                    jpaFields.add(field);&#10;&#10;                    if (field.isAnnotationPresent(Id.class)) {&#10;                        idField = field;&#10;                    }&#10;                }&#10;            }&#10;            currentClass = currentClass.getSuperclass();&#10;        }&#10;&#10;        metadata.setJpaFields(jpaFields);&#10;        metadata.setIdField(idField);&#10;&#10;        return metadata;&#10;    }&#10;&#10;    /**&#10;     * Check if field has JPA annotations&#10;     */&#10;    private static boolean hasJpaAnnotation(Field field) {&#10;        return field.isAnnotationPresent(Id.class) ||&#10;               field.isAnnotationPresent(Column.class) ||&#10;               field.isAnnotationPresent(JoinColumn.class) ||&#10;               field.isAnnotationPresent(OneToOne.class) ||&#10;               field.isAnnotationPresent(OneToMany.class) ||&#10;               field.isAnnotationPresent(ManyToOne.class) ||&#10;               field.isAnnotationPresent(ManyToMany.class) ||&#10;               field.isAnnotationPresent(Embedded.class) ||&#10;               field.isAnnotationPresent(GeneratedValue.class);&#10;    }&#10;&#10;    /**&#10;     * Clear metadata cache&#10;     */&#10;    public static void clearCache() {&#10;        metadataCache.clear();&#10;        logger.debug(&quot;Metadata cache cleared&quot;);&#10;    }&#10;&#10;    /**&#10;     * Entity metadata holder class&#10;     */&#10;    public static class EntityMetadata {&#10;        private Class&lt;?&gt; entityClass;&#10;        private String tableName;&#10;        private Field idField;&#10;        private List&lt;Field&gt; jpaFields;&#10;&#10;        // Getters and setters&#10;        public Class&lt;?&gt; getEntityClass() { return entityClass; }&#10;        public void setEntityClass(Class&lt;?&gt; entityClass) { this.entityClass = entityClass; }&#10;&#10;        public String getTableName() { return tableName; }&#10;        public void setTableName(String tableName) { this.tableName = tableName; }&#10;&#10;        public Field getIdField() { return idField; }&#10;        public void setIdField(Field idField) { this.idField = idField; }&#10;&#10;        public List&lt;Field&gt; getJpaFields() { return jpaFields; }&#10;        public void setJpaFields(List&lt;Field&gt; jpaFields) { this.jpaFields = jpaFields; }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return &quot;EntityMetadata{&quot; +&#10;                    &quot;entityClass=&quot; + entityClass.getSimpleName() +&#10;                    &quot;, tableName='&quot; + tableName + '\'' +&#10;                    &quot;, idField=&quot; + (idField != null ? idField.getName() : &quot;null&quot;) +&#10;                    &quot;, jpaFieldsCount=&quot; + (jpaFields != null ? jpaFields.size() : 0) +&#10;                    '}';&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.core;&#10;&#10;import jakarta.persistence.*;&#10;import jakarta.persistence.metamodel.EntityType;&#10;import jakarta.persistence.metamodel.Metamodel;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.lang.reflect.Field;&#10;import java.util.*;&#10;&#10;/**&#10; * Core metadata manager for H2-ORM&#10; * Handles entity metadata, reflection, and schema information&#10; */&#10;public class MetadataManager {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(MetadataManager.class);&#10;    private static final Map&lt;Class&lt;?&gt;, EntityMetadata&gt; metadataCache = new HashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get entity metadata with caching&#10;     */&#10;    public static EntityMetadata getEntityMetadata(Class&lt;?&gt; entityClass) {&#10;        return metadataCache.computeIfAbsent(entityClass, MetadataManager::buildEntityMetadata);&#10;    }&#10;&#10;    /**&#10;     * Get all managed entity types&#10;     */&#10;    public static Set&lt;EntityType&lt;?&gt;&gt; getAllEntityTypes() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Metamodel metamodel = em.getMetamodel();&#10;            return metamodel.getEntities();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get table name for entity&#10;     */&#10;    public static String getTableName(Class&lt;?&gt; entityClass) {&#10;        Table tableAnnotation = entityClass.getAnnotation(Table.class);&#10;        if (tableAnnotation != null &amp;&amp; !tableAnnotation.name().isEmpty()) {&#10;            return tableAnnotation.name();&#10;        }&#10;        return entityClass.getSimpleName().toLowerCase();&#10;    }&#10;&#10;    /**&#10;     * Get entity ID value using reflection&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;ID&gt; ID getEntityId(Object entity) {&#10;        if (entity == null) {&#10;            return null;&#10;        }&#10;&#10;        try {&#10;            EntityMetadata metadata = getEntityMetadata(entity.getClass());&#10;            Field idField = metadata.getIdField();&#10;            if (idField != null) {&#10;                idField.setAccessible(true);&#10;                return (ID) idField.get(entity);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Failed to get entity ID for {}: {}&quot;, entity.getClass().getSimpleName(), e.getMessage());&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Check if entity is new (has null or default ID)&#10;     */&#10;    public static boolean isEntityNew(Object entity) {&#10;        if (entity == null) {&#10;            return false;&#10;        }&#10;&#10;        Object id = getEntityId(entity);&#10;        if (id == null) {&#10;            return true;&#10;        }&#10;&#10;        // Check for default values that indicate new entity&#10;        if (id instanceof Number) {&#10;            return ((Number) id).longValue() == 0;&#10;        }&#10;&#10;        if (id instanceof String) {&#10;            return ((String) id).isEmpty();&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Get ID field for entity&#10;     */&#10;    public static Field getIdField(Class&lt;?&gt; entityClass) {&#10;        return getEntityMetadata(entityClass).getIdField();&#10;    }&#10;&#10;    /**&#10;     * Get ID value from entity instance&#10;     */&#10;    public static Object getIdValue(Object entity) {&#10;        try {&#10;            Field idField = getIdField(entity.getClass());&#10;            if (idField != null) {&#10;                idField.setAccessible(true);&#10;                return idField.get(entity);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Failed to get ID value from entity&quot;, e);&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Check if entity is new (ID is null or zero)&#10;     */&#10;    public static boolean isEntityNewById(Object entity) {&#10;        Object idValue = getIdValue(entity);&#10;        if (idValue == null) {&#10;            return true;&#10;        }&#10;        if (idValue instanceof Number) {&#10;            return ((Number) idValue).longValue() == 0;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Get all fields with JPA annotations&#10;     */&#10;    public static List&lt;Field&gt; getJpaFields(Class&lt;?&gt; entityClass) {&#10;        return getEntityMetadata(entityClass).getJpaFields();&#10;    }&#10;&#10;    /**&#10;     * Get column name for field&#10;     */&#10;    public static String getColumnName(Field field) {&#10;        Column columnAnnotation = field.getAnnotation(Column.class);&#10;        if (columnAnnotation != null &amp;&amp; !columnAnnotation.name().isEmpty()) {&#10;            return columnAnnotation.name();&#10;        }&#10;        return field.getName();&#10;    }&#10;&#10;    /**&#10;     * Build entity metadata&#10;     */&#10;    private static EntityMetadata buildEntityMetadata(Class&lt;?&gt; entityClass) {&#10;        logger.debug(&quot;Building metadata for entity: {}&quot;, entityClass.getSimpleName());&#10;&#10;        EntityMetadata metadata = new EntityMetadata();&#10;        metadata.setEntityClass(entityClass);&#10;        metadata.setTableName(getTableName(entityClass));&#10;&#10;        List&lt;Field&gt; jpaFields = new ArrayList&lt;&gt;();&#10;        Field idField = null;&#10;&#10;        // Process all fields including inherited ones&#10;        Class&lt;?&gt; currentClass = entityClass;&#10;        while (currentClass != null &amp;&amp; !currentClass.equals(Object.class)) {&#10;            for (Field field : currentClass.getDeclaredFields()) {&#10;                if (hasJpaAnnotation(field)) {&#10;                    jpaFields.add(field);&#10;&#10;                    if (field.isAnnotationPresent(Id.class)) {&#10;                        idField = field;&#10;                    }&#10;                }&#10;            }&#10;            currentClass = currentClass.getSuperclass();&#10;        }&#10;&#10;        metadata.setJpaFields(jpaFields);&#10;        metadata.setIdField(idField);&#10;&#10;        return metadata;&#10;    }&#10;&#10;    /**&#10;     * Check if field has JPA annotations&#10;     */&#10;    private static boolean hasJpaAnnotation(Field field) {&#10;        return field.isAnnotationPresent(Id.class) ||&#10;               field.isAnnotationPresent(Column.class) ||&#10;               field.isAnnotationPresent(JoinColumn.class) ||&#10;               field.isAnnotationPresent(OneToOne.class) ||&#10;               field.isAnnotationPresent(OneToMany.class) ||&#10;               field.isAnnotationPresent(ManyToOne.class) ||&#10;               field.isAnnotationPresent(ManyToMany.class) ||&#10;               field.isAnnotationPresent(Embedded.class) ||&#10;               field.isAnnotationPresent(GeneratedValue.class);&#10;    }&#10;&#10;    /**&#10;     * Clear metadata cache&#10;     */&#10;    public static void clearCache() {&#10;        metadataCache.clear();&#10;        logger.debug(&quot;Metadata cache cleared&quot;);&#10;    }&#10;&#10;    /**&#10;     * Entity metadata holder class&#10;     */&#10;    public static class EntityMetadata {&#10;        private Class&lt;?&gt; entityClass;&#10;        private String tableName;&#10;        private Field idField;&#10;        private List&lt;Field&gt; jpaFields;&#10;&#10;        // Getters and setters&#10;        public Class&lt;?&gt; getEntityClass() { return entityClass; }&#10;        public void setEntityClass(Class&lt;?&gt; entityClass) { this.entityClass = entityClass; }&#10;&#10;        public String getTableName() { return tableName; }&#10;        public void setTableName(String tableName) { this.tableName = tableName; }&#10;&#10;        public Field getIdField() { return idField; }&#10;        public void setIdField(Field idField) { this.idField = idField; }&#10;&#10;        public List&lt;Field&gt; getJpaFields() { return jpaFields; }&#10;        public void setJpaFields(List&lt;Field&gt; jpaFields) { this.jpaFields = jpaFields; }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return &quot;EntityMetadata{&quot; +&#10;                    &quot;entityClass=&quot; + entityClass.getSimpleName() +&#10;                    &quot;, tableName='&quot; + tableName + '\'' +&#10;                    &quot;, idField=&quot; + (idField != null ? idField.getName() : &quot;null&quot;) +&#10;                    &quot;, jpaFieldsCount=&quot; + (jpaFields != null ? jpaFields.size() : 0) +&#10;                    '}';&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/Page.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/Page.java" />
              <option name="updatedContent" value="package h2.orm.core.repository;&#10;&#10;import java.util.Iterator;&#10;import java.util.List;&#10;import java.util.function.Function;&#10;&#10;/**&#10; * A page is a sublist of a list of objects - similar to Spring Data JPA Page&#10; */&#10;public interface Page&lt;T&gt; extends Iterable&lt;T&gt; {&#10;    &#10;    /**&#10;     * Get the number of the current page&#10;     */&#10;    int getNumber();&#10;    &#10;    /**&#10;     * Get the size of the page&#10;     */&#10;    int getSize();&#10;    &#10;    /**&#10;     * Get the number of elements currently on this page&#10;     */&#10;    int getNumberOfElements();&#10;    &#10;    /**&#10;     * Get the content as List&#10;     */&#10;    List&lt;T&gt; getContent();&#10;    &#10;    /**&#10;     * Check if the page has content&#10;     */&#10;    boolean hasContent();&#10;    &#10;    /**&#10;     * Get the sorting parameters for the page&#10;     */&#10;    Sort getSort();&#10;    &#10;    /**&#10;     * Check if this is the first page&#10;     */&#10;    boolean isFirst();&#10;    &#10;    /**&#10;     * Check if this is the last page&#10;     */&#10;    boolean isLast();&#10;    &#10;    /**&#10;     * Check if there is a next page&#10;     */&#10;    boolean hasNext();&#10;    &#10;    /**&#10;     * Check if there is a previous page&#10;     */&#10;    boolean hasPrevious();&#10;    &#10;    /**&#10;     * Get the pageable descriptor that was used to request this page&#10;     */&#10;    Pageable getPageable();&#10;    &#10;    /**&#10;     * Get the pageable to request the next page&#10;     */&#10;    Pageable nextPageable();&#10;    &#10;    /**&#10;     * Get the pageable to request the previous page&#10;     */&#10;    Pageable previousPageable();&#10;    &#10;    /**&#10;     * Get the total number of elements&#10;     */&#10;    long getTotalElements();&#10;    &#10;    /**&#10;     * Get the total number of pages&#10;     */&#10;    int getTotalPages();&#10;    &#10;    /**&#10;     * Convert the content of the page to another type&#10;     */&#10;    &lt;U&gt; Page&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; converter);&#10;    &#10;    @Override&#10;    default Iterator&lt;T&gt; iterator() {&#10;        return getContent().iterator();&#10;    }&#10;    &#10;    /**&#10;     * Create empty page&#10;     */&#10;    static &lt;T&gt; Page&lt;T&gt; empty() {&#10;        return empty(Pageable.unpaged());&#10;    }&#10;    &#10;    /**&#10;     * Create empty page with pageable&#10;     */&#10;    static &lt;T&gt; Page&lt;T&gt; empty(Pageable pageable) {&#10;        return new PageImpl&lt;&gt;(List.of(), pageable, 0);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/PageImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/PageImpl.java" />
              <option name="updatedContent" value="package h2.orm.core.repository;&#10;&#10;import java.util.List;&#10;import java.util.Objects;&#10;import java.util.function.Function;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Basic Page implementation - similar to Spring Data JPA PageImpl&#10; */&#10;public class PageImpl&lt;T&gt; implements Page&lt;T&gt; {&#10;    &#10;    private final List&lt;T&gt; content;&#10;    private final Pageable pageable;&#10;    private final long total;&#10;    &#10;    /**&#10;     * Constructor with content and pageable&#10;     */&#10;    public PageImpl(List&lt;T&gt; content, Pageable pageable, long total) {&#10;        this.content = content;&#10;        this.pageable = pageable;&#10;        this.total = total;&#10;    }&#10;    &#10;    /**&#10;     * Constructor with content only (unpaged)&#10;     */&#10;    public PageImpl(List&lt;T&gt; content) {&#10;        this(content, Pageable.unpaged(), content.size());&#10;    }&#10;    &#10;    @Override&#10;    public int getNumber() {&#10;        return pageable.isPaged() ? pageable.getPageNumber() : 0;&#10;    }&#10;    &#10;    @Override&#10;    public int getSize() {&#10;        return pageable.isPaged() ? pageable.getPageSize() : content.size();&#10;    }&#10;    &#10;    @Override&#10;    public int getNumberOfElements() {&#10;        return content.size();&#10;    }&#10;    &#10;    @Override&#10;    public List&lt;T&gt; getContent() {&#10;        return content;&#10;    }&#10;    &#10;    @Override&#10;    public boolean hasContent() {&#10;        return !content.isEmpty();&#10;    }&#10;    &#10;    @Override&#10;    public Sort getSort() {&#10;        return pageable.getSort();&#10;    }&#10;    &#10;    @Override&#10;    public boolean isFirst() {&#10;        return !hasPrevious();&#10;    }&#10;    &#10;    @Override&#10;    public boolean isLast() {&#10;        return !hasNext();&#10;    }&#10;    &#10;    @Override&#10;    public boolean hasNext() {&#10;        return getNumber() + 1 &lt; getTotalPages();&#10;    }&#10;    &#10;    @Override&#10;    public boolean hasPrevious() {&#10;        return getNumber() &gt; 0;&#10;    }&#10;    &#10;    @Override&#10;    public Pageable getPageable() {&#10;        return pageable;&#10;    }&#10;    &#10;    @Override&#10;    public Pageable nextPageable() {&#10;        return hasNext() ? pageable.next() : Pageable.unpaged();&#10;    }&#10;    &#10;    @Override&#10;    public Pageable previousPageable() {&#10;        return hasPrevious() ? pageable.previousOrFirst() : Pageable.unpaged();&#10;    }&#10;    &#10;    @Override&#10;    public long getTotalElements() {&#10;        return total;&#10;    }&#10;    &#10;    @Override&#10;    public int getTotalPages() {&#10;        return pageable.isPaged() ? &#10;            (int) Math.ceil((double) total / (double) pageable.getPageSize()) : 1;&#10;    }&#10;    &#10;    @Override&#10;    public &lt;U&gt; Page&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; converter) {&#10;        List&lt;U&gt; converted = content.stream().map(converter).collect(Collectors.toList());&#10;        return new PageImpl&lt;&gt;(converted, pageable, total);&#10;    }&#10;    &#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj) {&#10;            return true;&#10;        }&#10;        &#10;        if (!(obj instanceof PageImpl)) {&#10;            return false;&#10;        }&#10;        &#10;        PageImpl&lt;?&gt; that = (PageImpl&lt;?&gt;) obj;&#10;        return Objects.equals(this.content, that.content) &amp;&amp;&#10;                Objects.equals(this.pageable, that.pageable) &amp;&amp;&#10;                this.total == that.total;&#10;    }&#10;    &#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(content, pageable, total);&#10;    }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        return String.format(&quot;Page %d of %d containing %s instances&quot;, &#10;                getNumber() + 1, getTotalPages(), content.getClass().getSimpleName());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/PageRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/PageRequest.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package h2.orm.core.repository;&#10;&#10;import java.util.Objects;&#10;&#10;/**&#10; * Basic Java Bean implementation of Pageable - similar to Spring Data JPA PageRequest&#10; */&#10;public class PageRequest implements Pageable {&#10;    &#10;    private final int page;&#10;    private final int size;&#10;    private final Sort sort;&#10;    &#10;    /**&#10;     * Creates a new PageRequest with sort parameters applied&#10;     */&#10;    protected PageRequest(int page, int size, Sort sort) {&#10;        if (page &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;Page index must not be less than zero!&quot;);&#10;        }&#10;        if (size &lt; 1) {&#10;            throw new IllegalArgumentException(&quot;Page size must not be less than one!&quot;);&#10;        }&#10;        &#10;        this.page = page;&#10;        this.size = size;&#10;        this.sort = sort;&#10;    }&#10;    &#10;    /**&#10;     * Creates a new unsorted PageRequest&#10;     */&#10;    public static PageRequest of(int page, int size) {&#10;        return of(page, size, Sort.unsorted());&#10;    }&#10;    &#10;    /**&#10;     * Creates a new PageRequest with sort parameters applied&#10;     */&#10;    public static PageRequest of(int page, int size, Sort sort) {&#10;        return new PageRequest(page, size, sort);&#10;    }&#10;    &#10;    /**&#10;     * Creates a new PageRequest with sort direction and properties applied&#10;     */&#10;    public static PageRequest of(int page, int size, Sort.Direction direction, String... properties) {&#10;        return of(page, size, Sort.by(direction, properties));&#10;    }&#10;    &#10;    /**&#10;     * Creates a new PageRequest for the first page&#10;     */&#10;    public static PageRequest ofSize(int pageSize) {&#10;        return PageRequest.of(0, pageSize);&#10;    }&#10;    &#10;    @Override&#10;    public int getPageNumber() {&#10;        return page;&#10;    }&#10;    &#10;    @Override&#10;    public int getPageSize() {&#10;        return size;&#10;    }&#10;    &#10;    @Override&#10;    public long getOffset() {&#10;        return (long) page * (long) size;&#10;    }&#10;    &#10;    @Override&#10;    public Sort getSort() {&#10;        return sort;&#10;    }&#10;    &#10;    @Override&#10;    public Pageable next() {&#10;        return new PageRequest(getPageNumber() + 1, getPageSize(), getSort());&#10;    }&#10;    &#10;    public Pageable previous() {&#10;        return getPageNumber() == 0 ? this : new PageRequest(getPageNumber() - 1, getPageSize(), getSort());&#10;    }&#10;    &#10;    @Override&#10;    public Pageable previousOrFirst() {&#10;        return hasPrevious() ? previous() : first();&#10;    }&#10;    &#10;    @Override&#10;    public Pageable first() {&#10;        return new PageRequest(0, getPageSize(), getSort());&#10;    }&#10;    &#10;    @Override&#10;    public Pageable withPage(int pageNumber) {&#10;        return new PageRequest(pageNumber, getPageSize(), getSort());&#10;    }&#10;    &#10;    @Override&#10;    public boolean hasPrevious() {&#10;        return page &gt; 0;&#10;    }&#10;    &#10;    /**&#10;     * Create new PageRequest with different sort&#10;     */&#10;    public PageRequest withSort(Sort sort) {&#10;        return new PageRequest(this.page, this.size, sort);&#10;    }&#10;    &#10;    /**&#10;     * Create new PageRequest with sort direction and properties&#10;     */&#10;    public PageRequest withSort(Sort.Direction direction, String... properties) {&#10;        return new PageRequest(this.page, this.size, Sort.by(direction, properties));&#10;    }&#10;    &#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj) {&#10;            return true;&#10;        }&#10;        &#10;        if (!(obj instanceof PageRequest)) {&#10;            return false;&#10;        }&#10;        &#10;        PageRequest that = (PageRequest) obj;&#10;        return this.page == that.page &amp;&amp; this.size == that.size &amp;&amp; Objects.equals(this.sort, that.sort);&#10;    }&#10;    &#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(page, size, sort);&#10;    }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        return String.format(&quot;Page request [number: %d, size %d, sort: %s]&quot;, &#10;                getPageNumber(), getPageSize(), sort);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/Pageable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/Pageable.java" />
              <option name="updatedContent" value="package h2.orm.core.repository;&#10;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Abstract interface for pagination information - similar to Spring Data JPA Pageable&#10; */&#10;public interface Pageable {&#10;    &#10;    /**&#10;     * Get the page number (zero-based)&#10;     */&#10;    int getPageNumber();&#10;    &#10;    /**&#10;     * Get the page size&#10;     */&#10;    int getPageSize();&#10;    &#10;    /**&#10;     * Get the offset (calculated from page number and size)&#10;     */&#10;    long getOffset();&#10;    &#10;    /**&#10;     * Get the sort information&#10;     */&#10;    Sort getSort();&#10;    &#10;    /**&#10;     * Get the sort information or default sort if unsorted&#10;     */&#10;    default Sort getSortOr(Sort sort) {&#10;        return getSort().isSorted() ? getSort() : sort;&#10;    }&#10;    &#10;    /**&#10;     * Get next pageable&#10;     */&#10;    Pageable next();&#10;    &#10;    /**&#10;     * Get previous pageable or first if already at first page&#10;     */&#10;    Pageable previousOrFirst();&#10;    &#10;    /**&#10;     * Get first pageable&#10;     */&#10;    Pageable first();&#10;    &#10;    /**&#10;     * Get pageable with new page number&#10;     */&#10;    Pageable withPage(int pageNumber);&#10;    &#10;    /**&#10;     * Check if there is a previous page&#10;     */&#10;    boolean hasPrevious();&#10;    &#10;    /**&#10;     * Check if this is the first page&#10;     */&#10;    default boolean isFirst() {&#10;        return !hasPrevious();&#10;    }&#10;    &#10;    /**&#10;     * Get unpaged instance&#10;     */&#10;    static Pageable unpaged() {&#10;        return Unpaged.INSTANCE;&#10;    }&#10;    &#10;    /**&#10;     * Get unpaged instance with sort&#10;     */&#10;    static Pageable unpaged(Sort sort) {&#10;        return Unpaged.sorted(sort);&#10;    }&#10;    &#10;    /**&#10;     * Create pageable with page and size&#10;     */&#10;    static Pageable ofSize(int pageSize) {&#10;        return PageRequest.of(0, pageSize);&#10;    }&#10;    &#10;    /**&#10;     * Check if this pageable is paged&#10;     */&#10;    default boolean isPaged() {&#10;        return true;&#10;    }&#10;    &#10;    /**&#10;     * Check if this pageable is unpaged&#10;     */&#10;    default boolean isUnpaged() {&#10;        return !isPaged();&#10;    }&#10;    &#10;    /**&#10;     * Get optional previous pageable&#10;     */&#10;    default Optional&lt;Pageable&gt; toOptional() {&#10;        return isUnpaged() ? Optional.empty() : Optional.of(this);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/Repository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/Repository.java" />
              <option name="originalContent" value="package h2.orm.core.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Base repository interface similar to Spring Data JPA&#10; * Provides standard CRUD operations for entities&#10; */&#10;public interface Repository&lt;T, ID extends Serializable&gt; {&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    T save(T entity);&#10;&#10;    /**&#10;     * Save all entities&#10;     */&#10;    List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    Optional&lt;T&gt; findById(ID id);&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    boolean existsById(ID id);&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    List&lt;T&gt; findAll();&#10;&#10;    /**&#10;     * Find all entities with sort&#10;     */&#10;    List&lt;T&gt; findAll(Sort sort);&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    Page&lt;T&gt; findAll(Pageable pageable);&#10;&#10;    /**&#10;     * Find all entities by IDs&#10;     */&#10;    List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    long count();&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    void deleteById(ID id);&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    void delete(T entity);&#10;&#10;    /**&#10;     * Delete all entities by IDs&#10;     */&#10;    void deleteAllById(Iterable&lt;ID&gt; ids);&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll(Iterable&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll();&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.core.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Base repository interface similar to Spring Data JPA&#10; * Provides standard CRUD operations for entities&#10; */&#10;public interface Repository&lt;T, ID extends Serializable&gt; {&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    T save(T entity);&#10;&#10;    /**&#10;     * Save all entities&#10;     */&#10;    List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    Optional&lt;T&gt; findById(ID id);&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    boolean existsById(ID id);&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    List&lt;T&gt; findAll();&#10;&#10;    /**&#10;     * Find all entities with sort&#10;     */&#10;    List&lt;T&gt; findAll(Sort sort);&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    Page&lt;T&gt; findAll(Pageable pageable);&#10;&#10;    /**&#10;     * Find entities by field value&#10;     */&#10;    List&lt;T&gt; findByField(String fieldName, Object value);&#10;&#10;    /**&#10;     * Find entities by field value with sorting&#10;     */&#10;    List&lt;T&gt; findByField(String fieldName, Object value, Sort sort);&#10;&#10;    /**&#10;     * Find entities by field value with pagination&#10;     */&#10;    Page&lt;T&gt; findByField(String fieldName, Object value, Pageable pageable);&#10;&#10;    /**&#10;     * Find entities by multiple field values (AND condition)&#10;     */&#10;    List&lt;T&gt; findByFields(java.util.Map&lt;String, Object&gt; fieldValues);&#10;&#10;    /**&#10;     * Find entities by multiple field values with sorting&#10;     */&#10;    List&lt;T&gt; findByFields(java.util.Map&lt;String, Object&gt; fieldValues, Sort sort);&#10;&#10;    /**&#10;     * Find entities by multiple field values with pagination&#10;     */&#10;    Page&lt;T&gt; findByFields(java.util.Map&lt;String, Object&gt; fieldValues, Pageable pageable);&#10;&#10;    /**&#10;     * Find first entity by field value&#10;     */&#10;    Optional&lt;T&gt; findFirstByField(String fieldName, Object value);&#10;&#10;    /**&#10;     * Check if any entity exists with field value&#10;     */&#10;    boolean existsByField(String fieldName, Object value);&#10;&#10;    /**&#10;     * Count entities by field value&#10;     */&#10;    long countByField(String fieldName, Object value);&#10;&#10;    /**&#10;     * Delete entities by field value&#10;     */&#10;    void deleteByField(String fieldName, Object value);&#10;&#10;    /**&#10;     * Find entities where field is null&#10;     */&#10;    List&lt;T&gt; findByFieldIsNull(String fieldName);&#10;&#10;    /**&#10;     * Find entities where field is not null&#10;     */&#10;    List&lt;T&gt; findByFieldIsNotNull(String fieldName);&#10;&#10;    /**&#10;     * Find entities where field value is in given collection&#10;     */&#10;    List&lt;T&gt; findByFieldIn(String fieldName, java.util.Collection&lt;?&gt; values);&#10;&#10;    /**&#10;     * Find entities where field value is between two values (for numbers/dates)&#10;     */&#10;    List&lt;T&gt; findByFieldBetween(String fieldName, Object startValue, Object endValue);&#10;&#10;    /**&#10;     * Find entities where string field contains given value&#10;     */&#10;    List&lt;T&gt; findByFieldContaining(String fieldName, String value);&#10;&#10;    /**&#10;     * Find entities where string field starts with given value&#10;     */&#10;    List&lt;T&gt; findByFieldStartingWith(String fieldName, String value);&#10;&#10;    /**&#10;     * Find entities where string field ends with given value&#10;     */&#10;    List&lt;T&gt; findByFieldEndingWith(String fieldName, String value);&#10;&#10;    /**&#10;     * Find all entities by IDs&#10;     */&#10;    List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    long count();&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    void deleteById(ID id);&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    void delete(T entity);&#10;&#10;    /**&#10;     * Delete all entities by IDs&#10;     */&#10;    void deleteAllById(Iterable&lt;ID&gt; ids);&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll(Iterable&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/Sort.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/Sort.java" />
              <option name="originalContent" value="package h2.orm.core.repository;&#10;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Sort option for repository queries - similar to Spring Data JPA Sort&#10; * Provides fluent API for building sort criteria&#10; */&#10;public class Sort implements Iterable&lt;Sort.Order&gt; {&#10;&#10;    private static final Sort UNSORTED = Sort.by();&#10;&#10;    private final List&lt;Order&gt; orders;&#10;&#10;    private Sort(List&lt;Order&gt; orders) {&#10;        this.orders = orders;&#10;    }&#10;&#10;    /**&#10;     * Create Sort instance with multiple orders&#10;     */&#10;    public static Sort by(Order... orders) {&#10;        return new Sort(Arrays.asList(orders));&#10;    }&#10;&#10;    /**&#10;     * Create Sort instance with property names (ascending by default)&#10;     */&#10;    public static Sort by(String... properties) {&#10;        return by(Arrays.stream(properties)&#10;                .map(Order::asc)&#10;                .toArray(Order[]::new));&#10;    }&#10;&#10;    /**&#10;     * Create Sort instance with direction and properties&#10;     */&#10;    public static Sort by(Direction direction, String... properties) {&#10;        return by(Arrays.stream(properties)&#10;                .map(property -&gt; new Order(direction, property))&#10;                .toArray(Order[]::new));&#10;    }&#10;&#10;    /**&#10;     * Create Sort instance with direction and property list&#10;     */&#10;    public static Sort by(Direction direction, List&lt;String&gt; properties) {&#10;        return by(direction, properties.toArray(new String[0]));&#10;    }&#10;&#10;    /**&#10;     * Get unsorted instance&#10;     */&#10;    public static Sort unsorted() {&#10;        return UNSORTED;&#10;    }&#10;&#10;    /**&#10;     * Add ascending order for property&#10;     */&#10;    public Sort and(Sort sort) {&#10;        List&lt;Order&gt; combinedOrders = new ArrayList&lt;&gt;(this.orders);&#10;        combinedOrders.addAll(sort.orders);&#10;        return new Sort(combinedOrders);&#10;    }&#10;&#10;    /**&#10;     * Get order for specific property&#10;     */&#10;    public Optional&lt;Order&gt; getOrderFor(String property) {&#10;        return orders.stream()&#10;                .filter(order -&gt; order.getProperty().equals(property))&#10;                .findFirst();&#10;    }&#10;&#10;    /**&#10;     * Check if sort is sorted&#10;     */&#10;    public boolean isSorted() {&#10;        return !orders.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Check if sort is unsorted&#10;     */&#10;    public boolean isUnsorted() {&#10;        return orders.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Create descending sort for properties&#10;     */&#10;    public Sort descending() {&#10;        return by(orders.stream()&#10;                .map(order -&gt; new Order(Direction.DESC, order.getProperty()))&#10;                .toArray(Order[]::new));&#10;    }&#10;&#10;    /**&#10;     * Create ascending sort for properties&#10;     */&#10;    public Sort ascending() {&#10;        return by(orders.stream()&#10;                .map(order -&gt; new Order(Direction.ASC, order.getProperty()))&#10;                .toArray(Order[]::new));&#10;    }&#10;&#10;    @Override&#10;    public Iterator&lt;Order&gt; iterator() {&#10;        return orders.iterator();&#10;    }&#10;&#10;    public List&lt;Order&gt; getOrders() {&#10;        return Collections.unmodifiableList(orders);&#10;    }&#10;&#10;    /**&#10;     * Convert to ORDER BY clause&#10;     */&#10;    public String toOrderByClause(String alias) {&#10;        if (isUnsorted()) {&#10;            return &quot;&quot;;&#10;        }&#10;&#10;        return &quot; ORDER BY &quot; + orders.stream()&#10;                .map(order -&gt; (alias != null ? alias + &quot;.&quot; : &quot;&quot;) + order.getProperty() + &quot; &quot; + order.getDirection().name())&#10;                .collect(Collectors.joining(&quot;, &quot;));&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj) return true;&#10;        if (obj == null || getClass() != obj.getClass()) return false;&#10;        Sort sort = (Sort) obj;&#10;        return Objects.equals(orders, sort.orders);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(orders);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return orders.isEmpty() ? &quot;UNSORTED&quot; : orders.toString();&#10;    }&#10;&#10;    /**&#10;     * Sort direction enum&#10;     */&#10;    public enum Direction {&#10;        ASC, DESC;&#10;&#10;        public boolean isAscending() {&#10;            return this == ASC;&#10;        }&#10;&#10;        public boolean isDescending() {&#10;            return this == DESC;&#10;        }&#10;&#10;        public static Direction fromString(String value) {&#10;            try {&#10;                return Direction.valueOf(value.toUpperCase());&#10;            } catch (Exception e) {&#10;                throw new IllegalArgumentException(&quot;Invalid direction: &quot; + value);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Property order specification&#10;     */&#10;    public static class Order {&#10;        private final Direction direction;&#10;        private final String property;&#10;        private final NullHandling nullHandling;&#10;&#10;        public Order(Direction direction, String property) {&#10;            this(direction, property, NullHandling.NATIVE);&#10;        }&#10;&#10;        public Order(Direction direction, String property, NullHandling nullHandling) {&#10;            this.direction = direction;&#10;            this.property = property;&#10;            this.nullHandling = nullHandling;&#10;        }&#10;&#10;        /**&#10;         * Create ascending order&#10;         */&#10;        public static Order asc(String property) {&#10;            return new Order(Direction.ASC, property);&#10;        }&#10;&#10;        /**&#10;         * Create descending order&#10;         */&#10;        public static Order desc(String property) {&#10;            return new Order(Direction.DESC, property);&#10;        }&#10;&#10;        /**&#10;         * Create order by direction and property&#10;         */&#10;        public static Order by(String property) {&#10;            return new Order(Direction.ASC, property);&#10;        }&#10;&#10;        public Direction getDirection() {&#10;            return direction;&#10;        }&#10;&#10;        public String getProperty() {&#10;            return property;&#10;        }&#10;&#10;        public NullHandling getNullHandling() {&#10;            return nullHandling;&#10;        }&#10;&#10;        public boolean isAscending() {&#10;            return direction.isAscending();&#10;        }&#10;&#10;        public boolean isDescending() {&#10;            return direction.isDescending();&#10;        }&#10;&#10;        public Order with(Direction direction) {&#10;            return new Order(direction, property, nullHandling);&#10;        }&#10;&#10;        public Order with(NullHandling nullHandling) {&#10;            return new Order(direction, property, nullHandling);&#10;        }&#10;&#10;        public Order nullsFirst() {&#10;            return with(NullHandling.NULLS_FIRST);&#10;        }&#10;&#10;        public Order nullsLast() {&#10;            return with(NullHandling.NULLS_LAST);&#10;        }&#10;&#10;        public Order nullsNative() {&#10;            return with(NullHandling.NATIVE);&#10;        }&#10;&#10;        @Override&#10;        public boolean equals(Object obj) {&#10;            if (this == obj) return true;&#10;            if (obj == null || getClass() != obj.getClass()) return false;&#10;            Order order = (Order) obj;&#10;            return direction == order.direction &amp;&amp;&#10;                    Objects.equals(property, order.property) &amp;&amp;&#10;                    nullHandling == order.nullHandling;&#10;        }&#10;&#10;        @Override&#10;        public int hashCode() {&#10;            return Objects.hash(direction, property, nullHandling);&#10;        }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return property + &quot;: &quot; + direction;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Null handling options&#10;     */&#10;    public enum NullHandling {&#10;        NATIVE, NULLS_FIRST, NULLS_LAST&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.core.repository;&#10;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Sort option for repository queries - similar to Spring Data JPA Sort&#10; * Provides fluent API for building sort criteria&#10; */&#10;public class Sort implements Iterable&lt;Sort.Order&gt; {&#10;&#10;    private static final Sort UNSORTED = new Sort(new ArrayList&lt;&gt;());&#10;&#10;    private final List&lt;Order&gt; orders;&#10;&#10;    private Sort(List&lt;Order&gt; orders) {&#10;        this.orders = orders != null ? orders : new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    /**&#10;     * Create Sort instance with multiple orders&#10;     */&#10;    public static Sort by(Order... orders) {&#10;        return new Sort(Arrays.asList(orders));&#10;    }&#10;&#10;    /**&#10;     * Create Sort instance with property names (ascending by default)&#10;     */&#10;    public static Sort by(String... properties) {&#10;        if (properties.length == 0) {&#10;            return UNSORTED;&#10;        }&#10;        return by(Arrays.stream(properties)&#10;                .map(Order::asc)&#10;                .toArray(Order[]::new));&#10;    }&#10;&#10;    /**&#10;     * Create Sort instance with direction and properties&#10;     */&#10;    public static Sort by(Direction direction, String... properties) {&#10;        return by(Arrays.stream(properties)&#10;                .map(property -&gt; new Order(direction, property))&#10;                .toArray(Order[]::new));&#10;    }&#10;&#10;    /**&#10;     * Create Sort instance with direction and property list&#10;     */&#10;    public static Sort by(Direction direction, List&lt;String&gt; properties) {&#10;        return by(direction, properties.toArray(new String[0]));&#10;    }&#10;&#10;    /**&#10;     * Get unsorted instance&#10;     */&#10;    public static Sort unsorted() {&#10;        return UNSORTED;&#10;    }&#10;&#10;    /**&#10;     * Add ascending order for property&#10;     */&#10;    public Sort and(Sort sort) {&#10;        List&lt;Order&gt; combinedOrders = new ArrayList&lt;&gt;(this.orders);&#10;        combinedOrders.addAll(sort.orders);&#10;        return new Sort(combinedOrders);&#10;    }&#10;&#10;    /**&#10;     * Get order for specific property&#10;     */&#10;    public Optional&lt;Order&gt; getOrderFor(String property) {&#10;        return orders.stream()&#10;                .filter(order -&gt; order.getProperty().equals(property))&#10;                .findFirst();&#10;    }&#10;&#10;    /**&#10;     * Check if sort is sorted&#10;     */&#10;    public boolean isSorted() {&#10;        return !orders.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Check if sort is unsorted&#10;     */&#10;    public boolean isUnsorted() {&#10;        return orders.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Create descending sort for properties&#10;     */&#10;    public Sort descending() {&#10;        return by(orders.stream()&#10;                .map(order -&gt; new Order(Direction.DESC, order.getProperty()))&#10;                .toArray(Order[]::new));&#10;    }&#10;&#10;    /**&#10;     * Create ascending sort for properties&#10;     */&#10;    public Sort ascending() {&#10;        return by(orders.stream()&#10;                .map(order -&gt; new Order(Direction.ASC, order.getProperty()))&#10;                .toArray(Order[]::new));&#10;    }&#10;&#10;    @Override&#10;    public Iterator&lt;Order&gt; iterator() {&#10;        return orders.iterator();&#10;    }&#10;&#10;    public List&lt;Order&gt; getOrders() {&#10;        return Collections.unmodifiableList(orders);&#10;    }&#10;&#10;    /**&#10;     * Convert to ORDER BY clause&#10;     */&#10;    public String toOrderByClause(String alias) {&#10;        if (isUnsorted()) {&#10;            return &quot;&quot;;&#10;        }&#10;&#10;        return &quot; ORDER BY &quot; + orders.stream()&#10;                .map(order -&gt; (alias != null ? alias + &quot;.&quot; : &quot;&quot;) + order.getProperty() + &quot; &quot; + order.getDirection().name())&#10;                .collect(Collectors.joining(&quot;, &quot;));&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object obj) {&#10;        if (this == obj) return true;&#10;        if (obj == null || getClass() != obj.getClass()) return false;&#10;        Sort sort = (Sort) obj;&#10;        return Objects.equals(orders, sort.orders);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(orders);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return orders.isEmpty() ? &quot;UNSORTED&quot; : orders.toString();&#10;    }&#10;&#10;    /**&#10;     * Sort direction enum&#10;     */&#10;    public enum Direction {&#10;        ASC, DESC;&#10;&#10;        public boolean isAscending() {&#10;            return this == ASC;&#10;        }&#10;&#10;        public boolean isDescending() {&#10;            return this == DESC;&#10;        }&#10;&#10;        public static Direction fromString(String value) {&#10;            try {&#10;                return Direction.valueOf(value.toUpperCase());&#10;            } catch (Exception e) {&#10;                throw new IllegalArgumentException(&quot;Invalid direction: &quot; + value);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Property order specification&#10;     */&#10;    public static class Order {&#10;        private final Direction direction;&#10;        private final String property;&#10;        private final NullHandling nullHandling;&#10;&#10;        public Order(Direction direction, String property) {&#10;            this(direction, property, NullHandling.NATIVE);&#10;        }&#10;&#10;        public Order(Direction direction, String property, NullHandling nullHandling) {&#10;            this.direction = direction;&#10;            this.property = property;&#10;            this.nullHandling = nullHandling;&#10;        }&#10;&#10;        /**&#10;         * Create ascending order&#10;         */&#10;        public static Order asc(String property) {&#10;            return new Order(Direction.ASC, property);&#10;        }&#10;&#10;        /**&#10;         * Create descending order&#10;         */&#10;        public static Order desc(String property) {&#10;            return new Order(Direction.DESC, property);&#10;        }&#10;&#10;        /**&#10;         * Create order by direction and property&#10;         */&#10;        public static Order by(String property) {&#10;            return new Order(Direction.ASC, property);&#10;        }&#10;&#10;        public Direction getDirection() {&#10;            return direction;&#10;        }&#10;&#10;        public String getProperty() {&#10;            return property;&#10;        }&#10;&#10;        public NullHandling getNullHandling() {&#10;            return nullHandling;&#10;        }&#10;&#10;        public boolean isAscending() {&#10;            return direction.isAscending();&#10;        }&#10;&#10;        public boolean isDescending() {&#10;            return direction.isDescending();&#10;        }&#10;&#10;        public Order with(Direction direction) {&#10;            return new Order(direction, property, nullHandling);&#10;        }&#10;&#10;        public Order with(NullHandling nullHandling) {&#10;            return new Order(direction, property, nullHandling);&#10;        }&#10;&#10;        public Order nullsFirst() {&#10;            return with(NullHandling.NULLS_FIRST);&#10;        }&#10;&#10;        public Order nullsLast() {&#10;            return with(NullHandling.NULLS_LAST);&#10;        }&#10;&#10;        public Order nullsNative() {&#10;            return with(NullHandling.NATIVE);&#10;        }&#10;&#10;        @Override&#10;        public boolean equals(Object obj) {&#10;            if (this == obj) return true;&#10;            if (obj == null || getClass() != obj.getClass()) return false;&#10;            Order order = (Order) obj;&#10;            return direction == order.direction &amp;&amp;&#10;                    Objects.equals(property, order.property) &amp;&amp;&#10;                    nullHandling == order.nullHandling;&#10;        }&#10;&#10;        @Override&#10;        public int hashCode() {&#10;            return Objects.hash(direction, property, nullHandling);&#10;        }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return property + &quot;: &quot; + direction;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Null handling options&#10;     */&#10;    public enum NullHandling {&#10;        NATIVE, NULLS_FIRST, NULLS_LAST&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/Unpaged.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/repository/Unpaged.java" />
              <option name="updatedContent" value="package h2.orm.core.repository;&#10;&#10;/**&#10; * Unpaged implementation of Pageable - similar to Spring Data JPA Unpaged&#10; */&#10;enum Unpaged implements Pageable {&#10;    &#10;    INSTANCE;&#10;    &#10;    @Override&#10;    public boolean isPaged() {&#10;        return false;&#10;    }&#10;    &#10;    @Override&#10;    public Pageable previousOrFirst() {&#10;        return this;&#10;    }&#10;    &#10;    @Override&#10;    public Pageable next() {&#10;        return this;&#10;    }&#10;    &#10;    @Override&#10;    public boolean hasPrevious() {&#10;        return false;&#10;    }&#10;    &#10;    @Override&#10;    public Sort getSort() {&#10;        return Sort.unsorted();&#10;    }&#10;    &#10;    @Override&#10;    public int getPageSize() {&#10;        throw new UnsupportedOperationException();&#10;    }&#10;    &#10;    @Override&#10;    public int getPageNumber() {&#10;        throw new UnsupportedOperationException();&#10;    }&#10;    &#10;    @Override&#10;    public long getOffset() {&#10;        throw new UnsupportedOperationException();&#10;    }&#10;    &#10;    @Override&#10;    public Pageable first() {&#10;        return this;&#10;    }&#10;    &#10;    @Override&#10;    public Pageable withPage(int pageNumber) {&#10;        if (pageNumber == 0) {&#10;            return this;&#10;        }&#10;        throw new UnsupportedOperationException();&#10;    }&#10;    &#10;    /**&#10;     * Create unpaged instance with sort&#10;     */&#10;    public static Pageable sorted(Sort sort) {&#10;        return sort.isUnsorted() ? INSTANCE : new UnpagedSorted(sort);&#10;    }&#10;    &#10;    /**&#10;     * Unpaged implementation with sorting&#10;     */&#10;    static class UnpagedSorted implements Pageable {&#10;        &#10;        private final Sort sort;&#10;        &#10;        UnpagedSorted(Sort sort) {&#10;            this.sort = sort;&#10;        }&#10;        &#10;        @Override&#10;        public boolean isPaged() {&#10;            return false;&#10;        }&#10;        &#10;        @Override&#10;        public Pageable previousOrFirst() {&#10;            return this;&#10;        }&#10;        &#10;        @Override&#10;        public Pageable next() {&#10;            return this;&#10;        }&#10;        &#10;        @Override&#10;        public boolean hasPrevious() {&#10;            return false;&#10;        }&#10;        &#10;        @Override&#10;        public Sort getSort() {&#10;            return sort;&#10;        }&#10;        &#10;        @Override&#10;        public int getPageSize() {&#10;            throw new UnsupportedOperationException();&#10;        }&#10;        &#10;        @Override&#10;        public int getPageNumber() {&#10;            throw new UnsupportedOperationException();&#10;        }&#10;        &#10;        @Override&#10;        public long getOffset() {&#10;            throw new UnsupportedOperationException();&#10;        }&#10;        &#10;        @Override&#10;        public Pageable first() {&#10;            return this;&#10;        }&#10;        &#10;        @Override&#10;        public Pageable withPage(int pageNumber) {&#10;            if (pageNumber == 0) {&#10;                return this;&#10;            }&#10;            throw new UnsupportedOperationException();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/example/Order.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/example/Order.java" />
              <option name="updatedContent" value="package h2.orm.example;&#10;&#10;import jakarta.persistence.*;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Order entity with status field for demonstrating field-based queries&#10; */&#10;@Entity&#10;@Table(name = &quot;orders&quot;)&#10;public class Order {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @Column(name = &quot;order_number&quot;, unique = true, nullable = false)&#10;    private String orderNumber;&#10;&#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;customer_id&quot;)&#10;    private User customer;&#10;&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;status&quot;, nullable = false)&#10;    private Status status;&#10;&#10;    @Column(name = &quot;amount&quot;, nullable = false)&#10;    private Double amount;&#10;&#10;    @Column(name = &quot;created_date&quot;)&#10;    private LocalDateTime createdDate;&#10;&#10;    @Column(name = &quot;processed_date&quot;)&#10;    private LocalDateTime processedDate;&#10;&#10;    // Constructors&#10;    public Order() {&#10;        this.createdDate = LocalDateTime.now();&#10;    }&#10;&#10;    public Order(String orderNumber, User customer, Status status, Double amount) {&#10;        this();&#10;        this.orderNumber = orderNumber;&#10;        this.customer = customer;&#10;        this.status = status;&#10;        this.amount = amount;&#10;        &#10;        if (status == Status.PROCESSED) {&#10;            this.processedDate = LocalDateTime.now();&#10;        }&#10;    }&#10;&#10;    // Status enum&#10;    public enum Status {&#10;        NEW,&#10;        PROCESSED, &#10;        SHIPPED,&#10;        DELIVERED,&#10;        CANCELLED,&#10;        PENDING&#10;    }&#10;&#10;    // Getters and Setters&#10;    public Long getId() {&#10;        return id;&#10;    }&#10;&#10;    public void setId(Long id) {&#10;        this.id = id;&#10;    }&#10;&#10;    public String getOrderNumber() {&#10;        return orderNumber;&#10;    }&#10;&#10;    public void setOrderNumber(String orderNumber) {&#10;        this.orderNumber = orderNumber;&#10;    }&#10;&#10;    public User getCustomer() {&#10;        return customer;&#10;    }&#10;&#10;    public void setCustomer(User customer) {&#10;        this.customer = customer;&#10;    }&#10;&#10;    public Status getStatus() {&#10;        return status;&#10;    }&#10;&#10;    public void setStatus(Status status) {&#10;        this.status = status;&#10;        if (status == Status.PROCESSED &amp;&amp; this.processedDate == null) {&#10;            this.processedDate = LocalDateTime.now();&#10;        }&#10;    }&#10;&#10;    public Double getAmount() {&#10;        return amount;&#10;    }&#10;&#10;    public void setAmount(Double amount) {&#10;        this.amount = amount;&#10;    }&#10;&#10;    public LocalDateTime getCreatedDate() {&#10;        return createdDate;&#10;    }&#10;&#10;    public void setCreatedDate(LocalDateTime createdDate) {&#10;        this.createdDate = createdDate;&#10;    }&#10;&#10;    public LocalDateTime getProcessedDate() {&#10;        return processedDate;&#10;    }&#10;&#10;    public void setProcessedDate(LocalDateTime processedDate) {&#10;        this.processedDate = processedDate;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Order{&quot; +&#10;                &quot;id=&quot; + id +&#10;                &quot;, orderNumber='&quot; + orderNumber + '\'' +&#10;                &quot;, status=&quot; + status +&#10;                &quot;, amount=&quot; + amount +&#10;                &quot;, createdDate=&quot; + createdDate +&#10;                '}';&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/H2OrmExceptions.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/H2OrmExceptions.java" />
              <option name="updatedContent" value="package h2.orm.exception;&#10;&#10;/**&#10; * Exception thrown when database is not initialized&#10; */&#10;public class DatabaseNotInitializedException extends H2OrmException {&#10;    &#10;    public DatabaseNotInitializedException() {&#10;        super(&#10;            &quot;Database not initialized&quot;,&#10;            &quot;The H2-ORM database connection has not been initialized yet.&quot;,&#10;            &quot;Call EntityManagerProvider.initialize() before using repositories.&quot;&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when transaction is required but not active&#10; */&#10;class TransactionRequiredException extends H2OrmException {&#10;    &#10;    public TransactionRequiredException(String operation) {&#10;        super(&#10;            &quot;Transaction required for operation: &quot; + operation,&#10;            &quot;The operation '&quot; + operation + &quot;' requires an active transaction.&quot;,&#10;            &quot;This operation will be automatically wrapped in a transaction.&quot;&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when entity operation fails&#10; */&#10;class EntityOperationException extends H2OrmException {&#10;    &#10;    public EntityOperationException(String operation, Throwable cause) {&#10;        super(&#10;            &quot;Entity operation failed: &quot; + operation,&#10;            &quot;Failed to &quot; + operation.toLowerCase() + &quot; entity.&quot;,&#10;            &quot;Check if the entity is valid and database connection is working.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when unique constraint is violated&#10; */&#10;class UniqueConstraintException extends H2OrmException {&#10;    &#10;    public UniqueConstraintException(String field, Object value, Throwable cause) {&#10;        super(&#10;            &quot;Unique constraint violation&quot;,&#10;            &quot;A record with &quot; + field + &quot; = '&quot; + value + &quot;' already exists.&quot;,&#10;            &quot;Use a different value for &quot; + field + &quot; or update the existing record.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when configuration is invalid&#10; */&#10;class ConfigurationException extends H2OrmException {&#10;    &#10;    public ConfigurationException(String message, String suggestion) {&#10;        super(&#10;            &quot;Configuration error&quot;,&#10;            message,&#10;            suggestion&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when repository operation fails&#10; */&#10;class RepositoryException extends H2OrmException {&#10;    &#10;    public RepositoryException(String operation, Throwable cause) {&#10;        super(&#10;            &quot;Repository operation failed: &quot; + operation,&#10;            &quot;Failed to execute repository operation: &quot; + operation,&#10;            &quot;Check your entity configuration and database connection.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/AbstractRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/AbstractRepository.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import h2.orm.core.MetadataManager;&#10;import h2.orm.core.TransactionManager;&#10;import h2.orm.exception.ExceptionHandler;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.lang.reflect.ParameterizedType;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Abstract JPA Repository implementation similar to Spring Data JPA&#10; * Provides automatic implementation of all repository methods with comprehensive exception handling&#10; * Now uses core classes for better performance and reliability&#10; */&#10;public abstract class AbstractRepository&lt;T, ID extends Serializable&gt; implements JpaRepository&lt;T, ID&gt; {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(AbstractRepository.class);&#10;&#10;    protected final Class&lt;T&gt; entityClass;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public AbstractRepository() {&#10;        this.entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass().getGenericSuperclass())&#10;                .getActualTypeArguments()[0];&#10;    }&#10;&#10;    protected AbstractRepository(Class&lt;T&gt; entityClass) {&#10;        this.entityClass = entityClass;&#10;    }&#10;&#10;    protected abstract EntityManager getEntityManager();&#10;&#10;    @Override&#10;    public T save(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                // Use MetadataManager for entity state detection&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    return entity;&#10;                } else {&#10;                    return em.merge(entity);&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                int batchSize = 20;&#10;                int count = 0;&#10;&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;&#10;                    if (++count % batchSize == 0) {&#10;                        em.flush();&#10;                        em.clear();&#10;                    }&#10;                }&#10;&#10;                em.flush(); // Final flush&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;T&gt; findById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;find entity by ID&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                T entity = em.find(entityClass, id);&#10;                return Optional.ofNullable(entity);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public boolean existsById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;check entity exists&quot;, () -&gt; {&#10;            return findById(id).isPresent();&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAll() {&#10;        return ExceptionHandler.safeExecute(&quot;find all entities&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                CriteriaBuilder cb = em.getCriteriaBuilder();&#10;                CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;                Root&lt;T&gt; root = query.from(entityClass);&#10;                query.select(root);&#10;&#10;                TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;                return typedQuery.getResultList();&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities by IDs&quot;, () -&gt; {&#10;            List&lt;T&gt; result = new ArrayList&lt;&gt;();&#10;            for (ID id : ids) {&#10;                findById(id).ifPresent(result::add);&#10;            }&#10;            return result;&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public long count() {&#10;        return ExceptionHandler.safeExecute(&quot;count entities&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                CriteriaBuilder cb = em.getCriteriaBuilder();&#10;                CriteriaQuery&lt;Long&gt; query = cb.createQuery(Long.class);&#10;                Root&lt;T&gt; root = query.from(entityClass);&#10;                query.select(cb.count(root));&#10;&#10;                TypedQuery&lt;Long&gt; typedQuery = em.createQuery(query);&#10;                return typedQuery.getSingleResult();&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteById(ID id) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity by ID&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T entity = em.find(entityClass, id);&#10;                if (entity != null) {&#10;                    em.remove(entity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void delete(T entity) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                em.remove(managedEntity);&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllById(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;                ids.forEach(idList::add);&#10;&#10;                if (!idList.isEmpty()) {&#10;                    String tableName = MetadataManager.getTableName(entityClass);&#10;                    em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;)&#10;                            .setParameter(&quot;ids&quot;, idList)&#10;                            .executeUpdate();&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName()).executeUpdate();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void flush() {&#10;        ExceptionHandler.safeExecute(&quot;flush changes&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.flush();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T saveAndFlush(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save and flush entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                T savedEntity;&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    savedEntity = entity;&#10;                } else {&#10;                    savedEntity = em.merge(entity);&#10;                }&#10;                em.flush();&#10;                return savedEntity;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all and flush entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;                }&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteInBatch(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllInBatch() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName()).executeUpdate();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;                ids.forEach(idList::add);&#10;&#10;                if (!idList.isEmpty()) {&#10;                    em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;)&#10;                            .setParameter(&quot;ids&quot;, idList)&#10;                            .executeUpdate();&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getOne(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;get entity reference&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                return em.getReference(entityClass, id);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getReferenceById(ID id) {&#10;        return getOne(id);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import h2.orm.core.MetadataManager;&#10;import h2.orm.core.QueryExecutor;&#10;import h2.orm.core.TransactionManager;&#10;import h2.orm.exception.ExceptionHandler;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.lang.reflect.ParameterizedType;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Abstract JPA Repository implementation similar to Spring Data JPA&#10; * Now uses QueryExecutor for optimized query performance&#10; */&#10;public abstract class AbstractRepository&lt;T, ID extends Serializable&gt; implements JpaRepository&lt;T, ID&gt; {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(AbstractRepository.class);&#10;&#10;    protected final Class&lt;T&gt; entityClass;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public AbstractRepository() {&#10;        this.entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass().getGenericSuperclass())&#10;                .getActualTypeArguments()[0];&#10;    }&#10;&#10;    protected AbstractRepository(Class&lt;T&gt; entityClass) {&#10;        this.entityClass = entityClass;&#10;    }&#10;&#10;    protected abstract EntityManager getEntityManager();&#10;&#10;    @Override&#10;    public T save(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    return entity;&#10;                } else {&#10;                    return em.merge(entity);&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                int batchSize = 20;&#10;                int count = 0;&#10;&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;&#10;                    if (++count % batchSize == 0) {&#10;                        em.flush();&#10;                        em.clear();&#10;                    }&#10;                }&#10;&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;T&gt; findById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;find entity by ID&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                T entity = em.find(entityClass, id);&#10;                return Optional.ofNullable(entity);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public boolean existsById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;check entity exists&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized exists check&#10;            String jpql = &quot;SELECT COUNT(e) FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id = :id&quot;;&#10;            Long count = QueryExecutor.executeSingleResultQuery(jpql, Long.class, Map.of(&quot;id&quot;, id));&#10;            return count &gt; 0;&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAll() {&#10;        return ExceptionHandler.safeExecute(&quot;find all entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized query execution&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executeQuery(jpql, entityClass);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities by IDs&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;            &#10;            if (idList.isEmpty()) {&#10;                return new ArrayList&lt;&gt;();&#10;            }&#10;            &#10;            // Use QueryExecutor for batch ID lookup&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;            return QueryExecutor.executeQuery(jpql, entityClass, Map.of(&quot;ids&quot;, idList));&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public long count() {&#10;        return ExceptionHandler.safeExecute(&quot;count entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized count query&#10;            String jpql = &quot;SELECT COUNT(e) FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executeSingleResultQuery(jpql, Long.class);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteById(ID id) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity by ID&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id = :id&quot;;&#10;            QueryExecutor.executeUpdate(jpql, Map.of(&quot;id&quot;, id));&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void delete(T entity) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                em.remove(managedEntity);&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllById(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;&#10;            if (!idList.isEmpty()) {&#10;                // Use QueryExecutor for batch delete&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, idList));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized bulk delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName();&#10;            QueryExecutor.executeUpdate(jpql);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void flush() {&#10;        ExceptionHandler.safeExecute(&quot;flush changes&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.flush();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T saveAndFlush(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save and flush entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                T savedEntity;&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    savedEntity = entity;&#10;                } else {&#10;                    savedEntity = em.merge(entity);&#10;                }&#10;                em.flush();&#10;                return savedEntity;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all and flush entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;                }&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteInBatch(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities in batch&quot;, () -&gt; {&#10;            // Extract IDs and use QueryExecutor for batch delete&#10;            List&lt;ID&gt; ids = new ArrayList&lt;&gt;();&#10;            for (T entity : entities) {&#10;                @SuppressWarnings(&quot;unchecked&quot;)&#10;                ID id = (ID) MetadataManager.getIdValue(entity);&#10;                if (id != null) {&#10;                    ids.add(id);&#10;                }&#10;            }&#10;            &#10;            if (!ids.isEmpty()) {&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, ids));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllInBatch() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities in batch&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized bulk delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName();&#10;            QueryExecutor.executeUpdate(jpql);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs in batch&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;&#10;            if (!idList.isEmpty()) {&#10;                // Use QueryExecutor for batch delete&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, idList));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getOne(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;get entity reference&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                return em.getReference(entityClass, id);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getReferenceById(ID id) {&#10;        return getOne(id);&#10;    }&#10;&#10;    // Additional utility methods using QueryExecutor&#10;&#10;    /**&#10;     * Find entities with pagination using QueryExecutor&#10;     */&#10;    public List&lt;T&gt; findAll(int offset, int limit) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities with pagination&quot;, () -&gt; {&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executePaginatedQuery(jpql, entityClass, null, offset, limit);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query&#10;     */&#10;    public List&lt;T&gt; findByJpql(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return ExceptionHandler.safeExecute(&quot;execute custom JPQL query&quot;, () -&gt; {&#10;            return QueryExecutor.executeQuery(jpql, entityClass, parameters);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute custom native SQL query&#10;     */&#10;    public List&lt;T&gt; findByNativeQuery(String sql, Map&lt;String, Object&gt; parameters) {&#10;        return ExceptionHandler.safeExecute(&quot;execute custom native query&quot;, () -&gt; {&#10;            return QueryExecutor.executeNativeQuery(sql, entityClass, parameters);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/JpaRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/JpaRepository.java" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;&#10;/**&#10; * JPA Repository interface similar to Spring Data JPA&#10; * Extends base Repository with additional JPA-specific methods&#10; */&#10;public interface JpaRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; {&#10;    &#10;    /**&#10;     * Flush changes to database&#10;     */&#10;    void flush();&#10;    &#10;    /**&#10;     * Save and flush entity&#10;     */&#10;    T saveAndFlush(T entity);&#10;    &#10;    /**&#10;     * Save all and flush entities&#10;     */&#10;    List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete entities in batch&#10;     */&#10;    void deleteInBatch(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete all entities in batch&#10;     */&#10;    void deleteAllInBatch();&#10;    &#10;    /**&#10;     * Delete all entities in batch by IDs&#10;     */&#10;    void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Get reference to entity (lazy loading)&#10;     */&#10;    T getOne(ID id);&#10;    &#10;    /**&#10;     * Get reference to entity (lazy loading) - JPA 3.0 style&#10;     */&#10;    T getReferenceById(ID id);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repositories.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repositories.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import jakarta.persistence.EntityManager;&#10;&#10;import java.io.Serializable;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Repository factory that creates JPA repositories automatically&#10; * Works exactly like Spring Data JPA - just call Repositories.of(EntityClass.class)&#10; */&#10;public class Repositories {&#10;&#10;    private static final Map&lt;Class&lt;?&gt;, JpaRepository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get repository for entity class - creates it automatically if needed&#10;     * Usage: UserRepository userRepo = Repositories.of(User.class);&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;T, ID extends Serializable&gt; JpaRepository&lt;T, ID&gt; of(Class&lt;T&gt; entityClass) {&#10;        return (JpaRepository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass,&#10;            clazz -&gt; new SimpleJpaRepository&lt;&gt;((Class&lt;T&gt;) clazz));&#10;    }&#10;&#10;    /**&#10;     * Clear repository cache&#10;     */&#10;    public static void clearCache() {&#10;        repositoryCache.clear();&#10;    }&#10;&#10;    /**&#10;     * Simple JPA Repository implementation&#10;     */&#10;    private static class SimpleJpaRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;&#10;        public SimpleJpaRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;&#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import jakarta.persistence.EntityManager;&#10;&#10;import java.io.Serializable;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Repository factory that creates JPA repositories automatically&#10; * Works exactly like Spring Data JPA - just call Repositories.of(EntityClass.class)&#10; * Now uses core EntityManagerProvider for better performance&#10; */&#10;public class Repositories {&#10;    &#10;    private static final Map&lt;Class&lt;?&gt;, JpaRepository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;    &#10;    /**&#10;     * Get repository for entity class - creates it automatically if needed&#10;     * Usage: UserRepository userRepo = Repositories.of(User.class);&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;T, ID extends Serializable&gt; JpaRepository&lt;T, ID&gt; of(Class&lt;T&gt; entityClass) {&#10;        return (JpaRepository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, &#10;            clazz -&gt; new SimpleJpaRepository&lt;&gt;((Class&lt;T&gt;) clazz));&#10;    }&#10;    &#10;    /**&#10;     * Clear repository cache&#10;     */&#10;    public static void clearCache() {&#10;        repositoryCache.clear();&#10;    }&#10;    &#10;    /**&#10;     * Simple JPA Repository implementation using core EntityManagerProvider&#10;     */&#10;    private static class SimpleJpaRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;        &#10;        public SimpleJpaRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;        &#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repository.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Generic Repository interface for basic CRUD operations&#10; * @param &lt;T&gt; Entity type&#10; * @param &lt;ID&gt; Primary key type&#10; */&#10;public interface Repository&lt;T, ID extends Serializable&gt; {&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    T save(T entity);&#10;&#10;    /**&#10;     * Save multiple entities&#10;     */&#10;    List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    Optional&lt;T&gt; findById(ID id);&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    List&lt;T&gt; findAll();&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    List&lt;T&gt; findAll(int offset, int limit);&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    List&lt;T&gt; findByAttribute(String attributeName, Object value);&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    List&lt;T&gt; findByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    List&lt;T&gt; findByNativeQuery(String sqlQuery, Object... params);&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    List&lt;T&gt; findByQuery(String jpqlQuery, Object... params);&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    long count();&#10;&#10;    /**&#10;     * Count entities by criteria&#10;     */&#10;    long countByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    boolean existsById(ID id);&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    boolean existsByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Update entity&#10;     */&#10;    T update(T entity);&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    void deleteById(ID id);&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    void delete(T entity);&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll();&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    void deleteByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    int executeUpdate(String jpqlQuery, Object... params);&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    int executeNativeUpdate(String sqlQuery, Object... params);&#10;&#10;    /**&#10;     * Batch insert entities&#10;     */&#10;    void batchInsert(List&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Batch update entities&#10;     */&#10;    void batchUpdate(List&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Get entity class&#10;     */&#10;    Class&lt;T&gt; getEntityClass();&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Base repository interface similar to Spring Data JPA&#10; * Provides standard CRUD operations for entities&#10; */&#10;public interface Repository&lt;T, ID extends Serializable&gt; {&#10;    &#10;    /**&#10;     * Save an entity&#10;     */&#10;    T save(T entity);&#10;    &#10;    /**&#10;     * Save all entities&#10;     */&#10;    List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    Optional&lt;T&gt; findById(ID id);&#10;    &#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    boolean existsById(ID id);&#10;    &#10;    /**&#10;     * Find all entities&#10;     */&#10;    List&lt;T&gt; findAll();&#10;    &#10;    /**&#10;     * Find all entities by IDs&#10;     */&#10;    List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Count all entities&#10;     */&#10;    long count();&#10;    &#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    void deleteById(ID id);&#10;    &#10;    /**&#10;     * Delete entity&#10;     */&#10;    void delete(T entity);&#10;    &#10;    /**&#10;     * Delete all entities by IDs&#10;     */&#10;    void deleteAllById(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/service/BackupService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/service/BackupService.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/service/ExportService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/service/ExportService.java" />
              <option name="updatedContent" value="package h2.orm.service;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.fasterxml.jackson.databind.SerializationFeature;&#10;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;&#10;import org.apache.poi.ss.usermodel.*;&#10;import org.apache.poi.xssf.usermodel.XSSFWorkbook;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.FileOutputStream;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.lang.reflect.Field;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;/**&#10; * Export service for converting data to various formats (CSV, Excel, JSON)&#10; */&#10;public class ExportService {&#10;    &#10;    private static final Logger logger = LoggerFactory.getLogger(ExportService.class);&#10;    private final ObjectMapper objectMapper;&#10;    &#10;    public ExportService() {&#10;        this.objectMapper = new ObjectMapper();&#10;        this.objectMapper.registerModule(new JavaTimeModule());&#10;        this.objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);&#10;        this.objectMapper.enable(SerializationFeature.INDENT_OUTPUT);&#10;    }&#10;    &#10;    /**&#10;     * Export data to CSV file&#10;     */&#10;    public &lt;T&gt; void exportToCsv(List&lt;T&gt; data, String filePath) {&#10;        if (data == null || data.isEmpty()) {&#10;            logger.warn(&quot;No data to export to CSV&quot;);&#10;            return;&#10;        }&#10;        &#10;        try (FileWriter writer = new FileWriter(filePath)) {&#10;            Class&lt;?&gt; clazz = data.get(0).getClass();&#10;            Field[] fields = clazz.getDeclaredFields();&#10;            &#10;            // Write header&#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                if (i &gt; 0) writer.append(&quot;,&quot;);&#10;                writer.append(fields[i].getName());&#10;            }&#10;            writer.append(&quot;\n&quot;);&#10;            &#10;            // Write data&#10;            for (T item : data) {&#10;                for (int i = 0; i &lt; fields.length; i++) {&#10;                    if (i &gt; 0) writer.append(&quot;,&quot;);&#10;                    &#10;                    fields[i].setAccessible(true);&#10;                    Object value = fields[i].get(item);&#10;                    String stringValue = value != null ? value.toString() : &quot;&quot;;&#10;                    &#10;                    // Escape commas and quotes in CSV&#10;                    if (stringValue.contains(&quot;,&quot;) || stringValue.contains(&quot;\&quot;&quot;)) {&#10;                        stringValue = &quot;\&quot;&quot; + stringValue.replace(&quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;) + &quot;\&quot;&quot;;&#10;                    }&#10;                    &#10;                    writer.append(stringValue);&#10;                }&#10;                writer.append(&quot;\n&quot;);&#10;            }&#10;            &#10;            logger.info(&quot;Data exported to CSV: {} ({} records)&quot;, filePath, data.size());&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to export to CSV&quot;, e);&#10;            throw new RuntimeException(&quot;CSV export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export data to Excel file&#10;     */&#10;    public &lt;T&gt; void exportToExcel(List&lt;T&gt; data, String filePath) {&#10;        if (data == null || data.isEmpty()) {&#10;            logger.warn(&quot;No data to export to Excel&quot;);&#10;            return;&#10;        }&#10;        &#10;        try (Workbook workbook = new XSSFWorkbook()) {&#10;            Sheet sheet = workbook.createSheet(&quot;Data&quot;);&#10;            &#10;            Class&lt;?&gt; clazz = data.get(0).getClass();&#10;            Field[] fields = clazz.getDeclaredFields();&#10;            &#10;            // Create header row&#10;            Row headerRow = sheet.createRow(0);&#10;            CellStyle headerStyle = workbook.createCellStyle();&#10;            Font headerFont = workbook.createFont();&#10;            headerFont.setBold(true);&#10;            headerStyle.setFont(headerFont);&#10;            &#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                Cell cell = headerRow.createCell(i);&#10;                cell.setCellValue(fields[i].getName());&#10;                cell.setCellStyle(headerStyle);&#10;            }&#10;            &#10;            // Create data rows&#10;            for (int rowIndex = 0; rowIndex &lt; data.size(); rowIndex++) {&#10;                Row row = sheet.createRow(rowIndex + 1);&#10;                T item = data.get(rowIndex);&#10;                &#10;                for (int colIndex = 0; colIndex &lt; fields.length; colIndex++) {&#10;                    Cell cell = row.createCell(colIndex);&#10;                    fields[colIndex].setAccessible(true);&#10;                    Object value = fields[colIndex].get(item);&#10;                    &#10;                    if (value != null) {&#10;                        if (value instanceof Number) {&#10;                            cell.setCellValue(((Number) value).doubleValue());&#10;                        } else if (value instanceof Boolean) {&#10;                            cell.setCellValue((Boolean) value);&#10;                        } else if (value instanceof LocalDate) {&#10;                            cell.setCellValue(value.toString());&#10;                        } else if (value instanceof LocalDateTime) {&#10;                            cell.setCellValue(value.toString());&#10;                        } else {&#10;                            cell.setCellValue(value.toString());&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            &#10;            // Auto-size columns&#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                sheet.autoSizeColumn(i);&#10;            }&#10;            &#10;            // Write to file&#10;            try (FileOutputStream fileOut = new FileOutputStream(filePath)) {&#10;                workbook.write(fileOut);&#10;            }&#10;            &#10;            logger.info(&quot;Data exported to Excel: {} ({} records)&quot;, filePath, data.size());&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to export to Excel&quot;, e);&#10;            throw new RuntimeException(&quot;Excel export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export data to JSON file&#10;     */&#10;    public &lt;T&gt; void exportToJson(List&lt;T&gt; data, String filePath) {&#10;        try {&#10;            objectMapper.writeValue(new java.io.File(filePath), data);&#10;            logger.info(&quot;Data exported to JSON: {} ({} records)&quot;, filePath, data != null ? data.size() : 0);&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Failed to export to JSON&quot;, e);&#10;            throw new RuntimeException(&quot;JSON export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export single object to JSON file&#10;     */&#10;    public &lt;T&gt; void exportToJson(T object, String filePath) {&#10;        try {&#10;            objectMapper.writeValue(new java.io.File(filePath), object);&#10;            logger.info(&quot;Object exported to JSON: {}&quot;, filePath);&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Failed to export to JSON&quot;, e);&#10;            throw new RuntimeException(&quot;JSON export failed&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>