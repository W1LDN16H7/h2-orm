<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/workflows/ci.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/ci.yml" />
              <option name="updatedContent" value="name: CI/CD Pipeline&#10;&#10;on:&#10;  push:&#10;    branches: [ main, develop ]&#10;  pull_request:&#10;    branches: [ main ]&#10;&#10;jobs:&#10;  test:&#10;    runs-on: ubuntu-latest&#10;    strategy:&#10;      matrix:&#10;        java: [21]&#10;    &#10;    steps:&#10;    - name: Checkout code&#10;      uses: actions/checkout@v4&#10;      &#10;    - name: Set up JDK ${{ matrix.java }}&#10;      uses: actions/setup-java@v4&#10;      with:&#10;        java-version: ${{ matrix.java }}&#10;        distribution: 'temurin'&#10;        cache: maven&#10;        &#10;    - name: Cache Maven dependencies&#10;      uses: actions/cache@v4&#10;      with:&#10;        path: ~/.m2&#10;        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}&#10;        restore-keys: ${{ runner.os }}-m2&#10;        &#10;    - name: Run tests&#10;      run: ./mvnw clean test&#10;      &#10;    - name: Generate test report&#10;      uses: dorny/test-reporter@v1&#10;      if: success() || failure()&#10;      with:&#10;        name: Maven Tests&#10;        path: target/surefire-reports/*.xml&#10;        reporter: java-junit&#10;        fail-on-error: true&#10;&#10;  build:&#10;    runs-on: ubuntu-latest&#10;    needs: test&#10;    &#10;    steps:&#10;    - name: Checkout code&#10;      uses: actions/checkout@v4&#10;      &#10;    - name: Set up JDK 21&#10;      uses: actions/setup-java@v4&#10;      with:&#10;        java-version: '21'&#10;        distribution: 'temurin'&#10;        cache: maven&#10;        &#10;    - name: Build with Maven&#10;      run: ./mvnw clean compile package -DskipTests&#10;      &#10;    - name: Generate JavaDoc&#10;      run: ./mvnw javadoc:javadoc&#10;      &#10;    - name: Run security scan&#10;      run: ./mvnw org.owasp:dependency-check-maven:check&#10;      continue-on-error: true&#10;      &#10;    - name: Upload build artifacts&#10;      uses: actions/upload-artifact@v4&#10;      with:&#10;        name: h2-orm-artifacts&#10;        path: |&#10;          target/*.jar&#10;          target/reports/&#10;        retention-days: 30&#10;&#10;  code-quality:&#10;    runs-on: ubuntu-latest&#10;    needs: test&#10;    &#10;    steps:&#10;    - name: Checkout code&#10;      uses: actions/checkout@v4&#10;      &#10;    - name: Set up JDK 21&#10;      uses: actions/setup-java@v4&#10;      with:&#10;        java-version: '21'&#10;        distribution: 'temurin'&#10;        cache: maven&#10;        &#10;    - name: Run SpotBugs analysis&#10;      run: ./mvnw spotbugs:check&#10;      continue-on-error: true&#10;      &#10;    - name: Generate code coverage&#10;      run: ./mvnw clean test jacoco:report&#10;      &#10;    - name: Upload coverage to Codecov&#10;      uses: codecov/codecov-action@v4&#10;      with:&#10;        file: target/site/jacoco/jacoco.xml&#10;        fail_ci_if_error: false&#10;&#10;  security-scan:&#10;    runs-on: ubuntu-latest&#10;    &#10;    steps:&#10;    - name: Checkout code&#10;      uses: actions/checkout@v4&#10;      &#10;    - name: Run Trivy vulnerability scanner&#10;      uses: aquasecurity/trivy-action@master&#10;      with:&#10;        scan-type: 'fs'&#10;        scan-ref: '.'&#10;        format: 'sarif'&#10;        output: 'trivy-results.sarif'&#10;        &#10;    - name: Upload Trivy scan results&#10;      uses: github/codeql-action/upload-sarif@v3&#10;      if: always()&#10;      with:&#10;        sarif_file: 'trivy-results.sarif'&#10;&#10;  release:&#10;    runs-on: ubuntu-latest&#10;    needs: [build, code-quality]&#10;    if: github.ref == 'refs/heads/main' &amp;&amp; github.event_name == 'push'&#10;    &#10;    steps:&#10;    - name: Checkout code&#10;      uses: actions/checkout@v4&#10;      &#10;    - name: Set up JDK 21&#10;      uses: actions/setup-java@v4&#10;      with:&#10;        java-version: '21'&#10;        distribution: 'temurin'&#10;        cache: maven&#10;        &#10;    - name: Build release artifacts&#10;      run: ./mvnw clean package source:jar javadoc:jar -DskipTests&#10;      &#10;    - name: Create release tag&#10;      id: tag&#10;      run: |&#10;        VERSION=$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout)&#10;        echo &quot;version=$VERSION&quot; &gt;&gt; $GITHUB_OUTPUT&#10;        &#10;    - name: Create GitHub Release&#10;      uses: actions/create-release@v1&#10;      env:&#10;        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}&#10;      with:&#10;        tag_name: v${{ steps.tag.outputs.version }}&#10;        release_name: H2-ORM v${{ steps.tag.outputs.version }}&#10;        body: |&#10;          ## H2-ORM Release v${{ steps.tag.outputs.version }}&#10;          &#10;          ### ️ Security Features&#10;          - All critical security vulnerabilities have been addressed&#10;          - Comprehensive input validation and sanitization&#10;          - Path traversal protection&#10;          - SQL injection prevention&#10;          &#10;          ###  Artifacts&#10;          - JAR: h2-orm-${{ steps.tag.outputs.version }}.jar&#10;          - Sources: h2-orm-${{ steps.tag.outputs.version }}-sources.jar&#10;          - JavaDoc: h2-orm-${{ steps.tag.outputs.version }}-javadoc.jar&#10;          &#10;          See [SECURITY_ASSESSMENT_REPORT.md](SECURITY_ASSESSMENT_REPORT.md) for security details.&#10;        draft: false&#10;        prerelease: false&#10;        &#10;    - name: Upload release assets&#10;      uses: actions/upload-release-asset@v1&#10;      env:&#10;        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}&#10;      with:&#10;        upload_url: ${{ steps.create_release.outputs.upload_url }}&#10;        asset_path: target/h2-orm-${{ steps.tag.outputs.version }}.jar&#10;        asset_name: h2-orm-${{ steps.tag.outputs.version }}.jar&#10;        asset_content_type: application/java-archive" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/LIBRARY_SETUP_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/LIBRARY_SETUP_GUIDE.md" />
              <option name="originalContent" value="# H2-ORM Library Setup Guide&#10;&#10; **Modern Spring Boot-style ORM Library** supporting H2, MySQL, PostgreSQL, and SQLite with advanced backup/export features.&#10;&#10;##  Quick Navigation&#10;&#10;- [ Installation](#-installation)&#10;- [ Quick Start](#-quick-start)&#10;- [ Build from Source](#-build-from-source)&#10;- [ API Documentation](#-api-documentation)&#10;- [ Testing](#-testing)&#10;- [ Release Process](#-release-process)&#10;&#10;##  Installation&#10;&#10;### Maven Dependency&#10;&#10;```xml&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;```&#10;&#10;### Gradle Dependency&#10;&#10;```gradle&#10;implementation 'com.h2.orm:h2-orm:1.0.0'&#10;```&#10;&#10;### Manual Installation&#10;&#10;1. Download the latest release from [GitHub Releases](https://github.com/W1LDN16H7/h2-orm/releases)&#10;2. Add the JAR to your project classpath&#10;3. Include required dependencies (see `pom.xml` for full list)&#10;&#10;##  Quick Start&#10;&#10;### 1. Basic Setup&#10;&#10;```java&#10;import h2.orm.H2ORM;&#10;import h2.orm.core.repository.JpaRepository;&#10;&#10;// Start H2-ORM with in-memory database&#10;H2ORM.startInMemory();&#10;&#10;// Or with file-based database&#10;H2ORM.start(&quot;./data/myapp&quot;);&#10;&#10;// Get repository (just like Spring Data JPA)&#10;JpaRepository&lt;User, Long&gt; userRepo = H2ORM.repository(User.class);&#10;```&#10;&#10;### 2. Entity Definition&#10;&#10;```java&#10;import jakarta.persistence.*;&#10;&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false, unique = true)&#10;    private String username;&#10;    &#10;    @Column(nullable = false)&#10;    private String email;&#10;    &#10;    // constructors, getters, setters...&#10;}&#10;```&#10;&#10;### 3. Repository Operations&#10;&#10;```java&#10;// Save entities&#10;User user = new User(&quot;john_doe&quot;, &quot;john@example.com&quot;);&#10;userRepo.save(user);&#10;&#10;// Query entities&#10;List&lt;User&gt; allUsers = userRepo.findAll();&#10;Optional&lt;User&gt; user = userRepo.findById(1L);&#10;&#10;// Field-based queries (NEW!)&#10;List&lt;User&gt; johns = userRepo.findByField(&quot;username&quot;, &quot;john_doe&quot;);&#10;List&lt;User&gt; gmailUsers = userRepo.findByFieldContaining(&quot;email&quot;, &quot;@gmail.com&quot;);&#10;&#10;// Pagination and sorting&#10;Page&lt;User&gt; page = userRepo.findAll(&#10;    PageRequest.of(0, 10, Sort.by(&quot;username&quot;))&#10;);&#10;```&#10;&#10;### 4. Advanced Features&#10;&#10;```java&#10;// Export data&#10;H2ORM.exportToCsv(User.class, &quot;./exports/users.csv&quot;);&#10;H2ORM.exportToExcel(User.class, &quot;./exports/users.xlsx&quot;);&#10;H2ORM.exportToJson(User.class, &quot;./exports/users.json&quot;);&#10;&#10;// Database backup&#10;H2ORM.backup(&quot;./backups/daily_backup&quot;);&#10;H2ORM.backupCompressed(&quot;./backups/compressed_backup&quot;);&#10;&#10;// Table management&#10;H2ORM.createTable(User.class);&#10;H2ORM.truncateTable(User.class);&#10;long count = H2ORM.getTableRowCount(User.class);&#10;```&#10;&#10;##  Build from Source&#10;&#10;### Prerequisites&#10;&#10;- ☕ **Java 21+** - Required for building and running&#10;-  **Maven 3.6+** - For dependency management and building&#10;-  **Git** - For version control (optional)&#10;&#10;### Development Setup&#10;&#10;```bash&#10;# Clone the repository&#10;git clone https://github.com/W1LDN16H7/h2-orm.git&#10;cd h2-orm&#10;&#10;# Set up development environment&#10;./dev-tools.sh setup&#10;&#10;# Run tests&#10;./dev-tools.sh test&#10;&#10;# Build the project&#10;./build.sh&#10;&#10;# Or quick build (skip tests and docs)&#10;./build.sh --quick&#10;```&#10;&#10;### Build Scripts&#10;&#10;| Script | Platform | Purpose |&#10;|--------|----------|---------|&#10;| `build.sh` | Unix/Linux/macOS | Full build with tests and documentation |&#10;| `build.bat` | Windows | Windows equivalent of build.sh |&#10;| `release.sh` | Unix/Linux/macOS | Create release packages |&#10;| `dev-tools.sh` | Unix/Linux/macOS | Development utilities |&#10;&#10;### Build Options&#10;&#10;```bash&#10;# Full build (default)&#10;./build.sh&#10;&#10;# Skip tests&#10;./build.sh --skip-tests&#10;&#10;# Skip documentation generation&#10;./build.sh --skip-docs&#10;&#10;# Quick build (skip tests and docs)&#10;./build.sh --quick&#10;&#10;# Show help&#10;./build.sh --help&#10;```&#10;&#10;##  API Documentation&#10;&#10;### Generated Documentation&#10;&#10;After building, documentation is available at:&#10;- **Javadocs**: `dist/javadocs/index.html`&#10;- **Coverage Report**: `dist/coverage/index.html`&#10;&#10;### Key Packages&#10;&#10;| Package | Description |&#10;|---------|-------------|&#10;| `h2.orm` | Main entry point (`H2ORM` class) |&#10;| `h2.orm.core.repository` | Repository interfaces and implementations |&#10;| `h2.orm.core.service` | Backup, export, and table management services |&#10;| `h2.orm.config` | Database configuration |&#10;| `h2.orm.example` | Example entities and usage demonstrations |&#10;&#10;### Repository Methods&#10;&#10;#### Basic CRUD&#10;- `save(T entity)` - Save or update entity&#10;- `findById(ID id)` - Find entity by ID&#10;- `findAll()` - Find all entities&#10;- `delete(T entity)` - Delete entity&#10;- `count()` - Count entities&#10;&#10;#### Field-Based Queries&#10;- `findByField(String field, Object value)` - Find by single field&#10;- `findByFields(Map&lt;String, Object&gt; criteria)` - Find by multiple fields&#10;- `findByFieldContaining(String field, String value)` - Text search&#10;- `findByFieldBetween(String field, Object start, Object end)` - Range query&#10;- `findByFieldIn(String field, Collection&lt;?&gt; values)` - IN query&#10;&#10;#### Pagination &amp; Sorting&#10;- `findAll(Sort sort)` - Find with sorting&#10;- `findAll(Pageable pageable)` - Find with pagination&#10;- `findByField(String field, Object value, Pageable pageable)` - Field query with pagination&#10;&#10;##  Testing&#10;&#10;### Running Tests&#10;&#10;```bash&#10;# Run all tests&#10;mvn test&#10;&#10;# Run with coverage&#10;./dev-tools.sh test&#10;&#10;# Run specific test class&#10;mvn test -Dtest=H2ORMTest&#10;&#10;# Run integration tests&#10;mvn verify&#10;```&#10;&#10;### Test Categories&#10;&#10;- **Unit Tests**: `src/test/java/h2/orm/test/`&#10;- **Integration Tests**: `src/test/java/h2/orm/integration/`&#10;- **Example Tests**: `src/test/java/h2/orm/example/`&#10;&#10;### Test Coverage&#10;&#10;The project maintains high test coverage:&#10;- **Target**: &gt;80% line coverage&#10;- **Report**: Available at `target/site/jacoco/index.html`&#10;&#10;##  Release Process&#10;&#10;### Creating a Release&#10;&#10;```bash&#10;# 1. Build the project&#10;./build.sh&#10;&#10;# 2. Create release packages&#10;./release.sh&#10;&#10;# 3. Bump version (optional)&#10;./release.sh bump-patch  # or bump-minor, bump-major&#10;```&#10;&#10;### Release Artifacts&#10;&#10;After running the release script, you'll find:&#10;&#10;```&#10;releases/&#10;├── h2-orm-1.0.0-release.tar.gz     # Complete release package&#10;├── github-v1.0.0/                  # GitHub release assets&#10;│   ├── h2-orm-1.0.0.jar&#10;│   ├── h2-orm-1.0.0-sources.jar&#10;│   ├── h2-orm-1.0.0-javadoc.jar&#10;│   ├── h2-orm-1.0.0-complete.jar&#10;│   └── release-notes.md&#10;└── maven-deploy-commands.txt        # Maven deployment commands&#10;```&#10;&#10;### Publishing to Maven Central&#10;&#10;1. Set up GPG signing and OSSRH account&#10;2. Configure `~/.m2/settings.xml` with credentials&#10;3. Run: `mvn clean deploy -P release`&#10;&#10;### GitHub Release&#10;&#10;1. Tag the release: `git tag v1.0.0`&#10;2. Push tag: `git push origin v1.0.0`&#10;3. Upload assets from `releases/github-v1.0.0/`&#10;4. Use `release-notes.md` as release description&#10;&#10;## ️ Development Tools&#10;&#10;### Available Commands&#10;&#10;```bash&#10;./dev-tools.sh setup      # Setup development environment&#10;./dev-tools.sh test       # Run tests with coverage&#10;./dev-tools.sh format     # Format code&#10;./dev-tools.sh deps       # Check dependency updates&#10;./dev-tools.sh security   # Run security scan&#10;./dev-tools.sh stats      # Show project statistics&#10;./dev-tools.sh clean      # Deep clean&#10;./dev-tools.sh ide        # Setup IDE configuration&#10;./dev-tools.sh all        # Run all development tasks&#10;```&#10;&#10;### IDE Setup&#10;&#10;The project includes configuration for:&#10;- **IntelliJ IDEA**: `.idea/` directory&#10;- **VS Code**: `.vscode/` directory&#10;- **Eclipse**: Import as Maven project&#10;&#10;### Code Quality&#10;&#10;- **Formatting**: Google Java Format&#10;- **Static Analysis**: SpotBugs&#10;- **Security**: OWASP Dependency Check&#10;- **Coverage**: JaCoCo&#10;&#10;##  Links&#10;&#10;- **Repository**: https://github.com/W1LDN16H7/h2-orm&#10;- **Issues**: https://github.com/W1LDN16H7/h2-orm/issues&#10;- **Wiki**: https://github.com/W1LDN16H7/h2-orm/wiki&#10;- **Releases**: https://github.com/W1LDN16H7/h2-orm/releases&#10;&#10;##  License&#10;&#10;This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.&#10;&#10;##  Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch: `git checkout -b feature/amazing-feature`&#10;3. Run tests: `./dev-tools.sh test`&#10;4. Commit changes: `git commit -m 'Add amazing feature'`&#10;5. Push to branch: `git push origin feature/amazing-feature`&#10;6. Open a Pull Request&#10;&#10;##  Support&#10;&#10;- **Documentation**: Check the [Wiki](https://github.com/W1LDN16H7/h2-orm/wiki)&#10;- **Issues**: Report bugs or request features via [GitHub Issues](https://github.com/W1LDN16H7/h2-orm/issues)&#10;- **Discussions**: Join the conversation in [GitHub Discussions](https://github.com/W1LDN16H7/h2-orm/discussions)&#10;&#10;---&#10;&#10;**Built with ❤️ by W1LDN16H7** | **Version 1.0.0** | **© 2025**&#10;" />
              <option name="updatedContent" value="# H2-ORM Library Setup Guide&#10;&#10; **Modern Spring Boot-style ORM Library** supporting H2, MySQL, PostgreSQL, and SQLite with advanced backup/export features.&#10;&#10;##  Quick Navigation&#10;&#10;- [ Installation](#-installation)&#10;- [ Quick Start](#-quick-start)&#10;- [ Build from Source](#-build-from-source)&#10;- [ API Documentation](#-api-documentation)&#10;- [ Testing](#-testing)&#10;- [ Release Process](#-release-process)&#10;&#10;##  Installation&#10;&#10;### Maven Dependency&#10;&#10;```xml&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;```&#10;&#10;### Gradle Dependency&#10;&#10;```gradle&#10;implementation 'com.h2.orm:h2-orm:1.0.0'&#10;```&#10;&#10;### Manual Installation&#10;&#10;1. Download the latest JAR from [Releases](https://github.com/your-repo/h2-orm/releases)&#10;2. Add the JAR to your project's classpath&#10;3. Include required dependencies:&#10;   - H2 Database Engine&#10;   - SLF4J API&#10;   - Jackson Core (for JSON export)&#10;   - Apache POI (for Excel export)&#10;&#10;##  Quick Start&#10;&#10;### Basic Setup&#10;&#10;```java&#10;import com.h2.orm.DatabaseManager;&#10;import com.h2.orm.annotations.*;&#10;&#10;// 1. Define your entity&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(name = &quot;username&quot;, nullable = false, unique = true)&#10;    private String username;&#10;    &#10;    @Column(name = &quot;email&quot;)&#10;    private String email;&#10;    &#10;    @Column(name = &quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;    &#10;    // Constructors, getters, setters...&#10;}&#10;&#10;// 2. Initialize the database manager&#10;DatabaseManager dbManager = new DatabaseManager(&quot;jdbc:h2:./data/myapp&quot;);&#10;dbManager.createTablesFromEntities(User.class);&#10;&#10;// 3. Perform CRUD operations&#10;User user = new User(&quot;john_doe&quot;, &quot;john@example.com&quot;);&#10;dbManager.save(user);&#10;&#10;List&lt;User&gt; users = dbManager.findAll(User.class);&#10;User foundUser = dbManager.findById(User.class, 1L);&#10;```&#10;&#10;### Configuration Options&#10;&#10;```java&#10;// Database configuration&#10;DatabaseConfig config = DatabaseConfig.builder()&#10;    .url(&quot;jdbc:h2:./data/myapp&quot;)&#10;    .username(&quot;sa&quot;)&#10;    .password(&quot;&quot;)&#10;    .dialect(DatabaseDialect.H2)&#10;    .showSql(true)&#10;    .formatSql(true)&#10;    .build();&#10;&#10;DatabaseManager dbManager = new DatabaseManager(config);&#10;```&#10;&#10;### Supported Database Types&#10;&#10;| Database | JDBC URL Example | Driver Required |&#10;|----------|------------------|-----------------|&#10;| H2 (File) | `jdbc:h2:./data/myapp` | Built-in |&#10;| H2 (Memory) | `jdbc:h2:mem:testdb` | Built-in |&#10;| MySQL | `jdbc:mysql://localhost:3306/mydb` | mysql-connector-java |&#10;| PostgreSQL | `jdbc:postgresql://localhost:5432/mydb` | postgresql |&#10;| SQLite | `jdbc:sqlite:./data/myapp.db` | sqlite-jdbc |&#10;&#10;##  Build from Source&#10;&#10;### Prerequisites&#10;&#10;- Java 11 or higher&#10;- Maven 3.6+&#10;- Git&#10;&#10;### Build Steps&#10;&#10;```bash&#10;# Clone the repository&#10;git clone https://github.com/your-repo/h2-orm.git&#10;cd h2-orm&#10;&#10;# Build the project&#10;./mvnw clean compile&#10;&#10;# Run tests&#10;./mvnw test&#10;&#10;# Package the library&#10;./mvnw package&#10;&#10;# Install to local repository&#10;./mvnw install&#10;```&#10;&#10;### Development Tools&#10;&#10;```bash&#10;# Use the development tools script&#10;./dev-tools.sh&#10;&#10;# Available commands:&#10;# - clean: Clean build artifacts&#10;# - compile: Compile source code&#10;# - test: Run all tests&#10;# - package: Create JAR file&#10;# - install: Install to local Maven repository&#10;# - format: Format code using Google Java Format&#10;```&#10;&#10;##  API Documentation&#10;&#10;### Core Classes&#10;&#10;#### DatabaseManager&#10;The main class for database operations.&#10;&#10;```java&#10;// Basic CRUD operations&#10;&lt;T&gt; T save(T entity)&#10;&lt;T&gt; T update(T entity)&#10;&lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id)&#10;&lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass)&#10;&lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id)&#10;&#10;// Query operations&#10;&lt;T&gt; List&lt;T&gt; findByColumn(Class&lt;T&gt; entityClass, String columnName, Object value)&#10;&lt;T&gt; List&lt;T&gt; executeQuery(String sql, Class&lt;T&gt; resultClass, Object... params)&#10;&#10;// Schema operations&#10;void createTablesFromEntities(Class&lt;?&gt;... entityClasses)&#10;void dropTable(String tableName)&#10;```&#10;&#10;#### BackupManager&#10;Advanced backup and export functionality.&#10;&#10;```java&#10;// Backup operations&#10;void createBackup(String backupPath)&#10;void createCompressedBackup(String backupPath)&#10;void restoreFromBackup(String backupPath)&#10;&#10;// Export operations&#10;void exportToCSV(String tableName, String filePath)&#10;void exportToJSON(String tableName, String filePath)&#10;void exportToExcel(String tableName, String filePath)&#10;&#10;// Scheduled backups&#10;void scheduleBackup(Duration interval, String backupDirectory)&#10;```&#10;&#10;### Annotations&#10;&#10;#### @Entity&#10;Marks a class as a database entity.&#10;&#10;```java&#10;@Entity&#10;public class MyEntity { ... }&#10;```&#10;&#10;#### @Table&#10;Specifies table details.&#10;&#10;```java&#10;@Table(name = &quot;custom_table_name&quot;)&#10;public class MyEntity { ... }&#10;```&#10;&#10;#### @Id&#10;Marks the primary key field.&#10;&#10;```java&#10;@Id&#10;private Long id;&#10;```&#10;&#10;#### @GeneratedValue&#10;Configures auto-generation of primary key values.&#10;&#10;```java&#10;@GeneratedValue(strategy = GenerationType.IDENTITY)&#10;private Long id;&#10;```&#10;&#10;#### @Column&#10;Configures column properties.&#10;&#10;```java&#10;@Column(name = &quot;custom_name&quot;, nullable = false, unique = true, length = 100)&#10;private String name;&#10;```&#10;&#10;##  Testing&#10;&#10;### Running Tests&#10;&#10;```bash&#10;# Run all tests&#10;./mvnw test&#10;&#10;# Run specific test class&#10;./mvnw test -Dtest=DatabaseManagerTest&#10;&#10;# Run tests with coverage&#10;./mvnw jacoco:prepare-agent test jacoco:report&#10;```&#10;&#10;### Test Categories&#10;&#10;- **Unit Tests**: Core functionality testing&#10;- **Integration Tests**: Database integration testing&#10;- **Performance Tests**: Load and performance testing&#10;&#10;### Sample Test&#10;&#10;```java&#10;@Test&#10;public void testSaveAndFindUser() {&#10;    // Given&#10;    User user = new User(&quot;testuser&quot;, &quot;test@example.com&quot;);&#10;    &#10;    // When&#10;    User savedUser = dbManager.save(user);&#10;    Optional&lt;User&gt; foundUser = dbManager.findById(User.class, savedUser.getId());&#10;    &#10;    // Then&#10;    assertTrue(foundUser.isPresent());&#10;    assertEquals(&quot;testuser&quot;, foundUser.get().getUsername());&#10;}&#10;```&#10;&#10;##  Release Process&#10;&#10;### Version Management&#10;&#10;The project follows [Semantic Versioning](https://semver.org/):&#10;- **MAJOR**: Incompatible API changes&#10;- **MINOR**: Backwards-compatible functionality additions&#10;- **PATCH**: Backwards-compatible bug fixes&#10;&#10;### Release Steps&#10;&#10;1. **Update Version**&#10;   ```bash&#10;   ./mvnw versions:set -DnewVersion=1.1.0&#10;   ```&#10;&#10;2. **Run Full Test Suite**&#10;   ```bash&#10;   ./mvnw clean test&#10;   ```&#10;&#10;3. **Create Release Build**&#10;   ```bash&#10;   ./release.sh&#10;   ```&#10;&#10;4. **Tag Release**&#10;   ```bash&#10;   git tag -a v1.1.0 -m &quot;Release version 1.1.0&quot;&#10;   git push origin v1.1.0&#10;   ```&#10;&#10;### Build Artifacts&#10;&#10;The release process generates:&#10;- `h2-orm-{version}.jar` - Main library&#10;- `h2-orm-{version}-sources.jar` - Source code&#10;- `h2-orm-{version}-javadoc.jar` - API documentation&#10;&#10;##  Configuration&#10;&#10;### Database Configuration&#10;&#10;Create `h2-orm-config.xml` in your resources directory:&#10;&#10;```xml&#10;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;configuration&gt;&#10;    &lt;database&gt;&#10;        &lt;url&gt;jdbc:h2:./data/myapp&lt;/url&gt;&#10;        &lt;username&gt;sa&lt;/username&gt;&#10;        &lt;password&gt;&lt;/password&gt;&#10;        &lt;dialect&gt;H2&lt;/dialect&gt;&#10;        &lt;showSql&gt;true&lt;/showSql&gt;&#10;        &lt;formatSql&gt;true&lt;/formatSql&gt;&#10;    &lt;/database&gt;&#10;    &#10;    &lt;backup&gt;&#10;        &lt;autoBackup&gt;true&lt;/autoBackup&gt;&#10;        &lt;backupInterval&gt;24h&lt;/backupInterval&gt;&#10;        &lt;backupDirectory&gt;./backups&lt;/backupDirectory&gt;&#10;        &lt;compressionEnabled&gt;true&lt;/compressionEnabled&gt;&#10;        &lt;maxBackupFiles&gt;10&lt;/maxBackupFiles&gt;&#10;    &lt;/backup&gt;&#10;    &#10;    &lt;logging&gt;&#10;        &lt;level&gt;INFO&lt;/level&gt;&#10;        &lt;file&gt;./logs/h2-orm.log&lt;/file&gt;&#10;    &lt;/logging&gt;&#10;&lt;/configuration&gt;&#10;```&#10;&#10;### Environment Variables&#10;&#10;| Variable | Description | Default |&#10;|----------|-------------|---------|&#10;| `H2_ORM_DB_URL` | Database URL | `jdbc:h2:./data/default` |&#10;| `H2_ORM_DB_USER` | Database username | `sa` |&#10;| `H2_ORM_DB_PASSWORD` | Database password | (empty) |&#10;| `H2_ORM_SHOW_SQL` | Show SQL queries | `false` |&#10;| `H2_ORM_BACKUP_DIR` | Backup directory | `./backups` |&#10;&#10;##  Advanced Features&#10;&#10;### Backup and Export&#10;&#10;```java&#10;// Create backup manager&#10;BackupManager backupManager = new BackupManager(dbManager);&#10;&#10;// Manual backup&#10;backupManager.createBackup(&quot;./backups/manual_backup.sql&quot;);&#10;&#10;// Compressed backup&#10;backupManager.createCompressedBackup(&quot;./backups/compressed_backup.gz&quot;);&#10;&#10;// Export to different formats&#10;backupManager.exportToCSV(&quot;users&quot;, &quot;./exports/users.csv&quot;);&#10;backupManager.exportToJSON(&quot;users&quot;, &quot;./exports/users.json&quot;);&#10;backupManager.exportToExcel(&quot;users&quot;, &quot;./exports/users.xlsx&quot;);&#10;&#10;// Scheduled backups&#10;backupManager.scheduleBackup(Duration.ofHours(24), &quot;./backups&quot;);&#10;```&#10;&#10;### Query Builder&#10;&#10;```java&#10;// Build complex queries&#10;List&lt;User&gt; activeUsers = dbManager.queryBuilder(User.class)&#10;    .where(&quot;status&quot;, &quot;ACTIVE&quot;)&#10;    .and(&quot;created_at&quot;, &quot;&gt;&quot;, LocalDateTime.now().minusDays(30))&#10;    .orderBy(&quot;created_at&quot;, &quot;DESC&quot;)&#10;    .limit(100)&#10;    .execute();&#10;```&#10;&#10;### Transaction Management&#10;&#10;```java&#10;// Manual transaction management&#10;dbManager.executeInTransaction(() -&gt; {&#10;    User user = new User(&quot;john&quot;, &quot;john@example.com&quot;);&#10;    dbManager.save(user);&#10;    &#10;    Profile profile = new Profile(user.getId(), &quot;John Doe&quot;);&#10;    dbManager.save(profile);&#10;    &#10;    return null; // Transaction will be committed&#10;});&#10;```&#10;&#10;## ️ Troubleshooting&#10;&#10;### Common Issues&#10;&#10;1. **Database Connection Failed**&#10;   - Check database URL format&#10;   - Verify database server is running&#10;   - Check credentials&#10;&#10;2. **Table Not Found**&#10;   - Ensure entities are properly annotated&#10;   - Call `createTablesFromEntities()` before operations&#10;&#10;3. **Primary Key Errors**&#10;   - Verify `@Id` annotation is present&#10;   - Check `@GeneratedValue` configuration&#10;&#10;### Debug Logging&#10;&#10;Enable debug logging in your configuration:&#10;&#10;```xml&#10;&lt;logging&gt;&#10;    &lt;level&gt;DEBUG&lt;/level&gt;&#10;&lt;/logging&gt;&#10;```&#10;&#10;Or set environment variable:&#10;```bash&#10;export H2_ORM_LOG_LEVEL=DEBUG&#10;```&#10;&#10;##  Examples&#10;&#10;Check the `examples/` directory for complete working examples:&#10;- Basic CRUD operations&#10;- Advanced querying&#10;- Backup and export&#10;- Multiple database types&#10;- Spring Boot integration&#10;&#10;##  Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch&#10;3. Make your changes&#10;4. Add tests for new functionality&#10;5. Run the test suite&#10;6. Submit a pull request&#10;&#10;##  License&#10;&#10;This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.&#10;&#10;##  Support&#10;&#10;-  Email: support@h2-orm.com&#10;-  Discord: [H2-ORM Community](https://discord.gg/h2-orm)&#10;-  Issues: [GitHub Issues](https://github.com/your-repo/h2-orm/issues)&#10;-  Documentation: [Full Documentation](https://docs.h2-orm.com)&#10;&#10;---&#10;&#10;Made with ❤️ by the H2-ORM Team" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# H2-ORM&#10;&#10; **Modern Spring Boot-style ORM Library** for Java - Simple, Fast, and Feature-Rich&#10;&#10;[![Java](https://img.shields.io/badge/Java-21+-orange.svg)](https://openjdk.java.net/)&#10;[![License](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)&#10;[![Build Status](https://img.shields.io/badge/Build-Passing-green.svg)](https://github.com/W1LDN16H7/h2-orm)&#10;[![Version](https://img.shields.io/badge/Version-1.0.0-brightgreen.svg)](https://github.com/W1LDN16H7/h2-orm/releases)&#10;&#10;H2-ORM is a lightweight, powerful Object-Relational Mapping library that brings **Spring Boot-style** repository patterns to any Java application. Built with modern Java features and designed for developer productivity.&#10;&#10;## ✨ Key Features&#10;&#10;-  **Spring Boot-like API** - Familiar repository patterns and annotations&#10;- ️ **Multi-Database Support** - H2, MySQL, PostgreSQL, SQLite&#10;-  **Zero Configuration** - Works out of the box with sensible defaults&#10;-  **High Performance** - Optimized query execution and connection pooling&#10;-  **Advanced Backup/Export** - CSV, JSON, Excel export with compression&#10;-  **Powerful Querying** - Dynamic queries, sorting, pagination&#10;- ️ **Transaction Management** - Automatic rollback and error handling&#10;-  **Rich Documentation** - Complete API docs and examples&#10;&#10;##  Quick Navigation&#10;&#10;- [ Installation](#-installation)&#10;- [ Quick Start](#-quick-start)&#10;- [️ Build from Source](#️-build-from-source)&#10;- [ API Documentation](#-api-documentation)&#10;- [ Testing](#-testing)&#10;- [ Contributing](#-contributing)&#10;- [ License](#-license)&#10;&#10;##  Installation&#10;&#10;### Maven Dependency&#10;&#10;```xml&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;```&#10;&#10;### Gradle Dependency&#10;&#10;```gradle&#10;implementation 'com.h2.orm:h2-orm:1.0.0'&#10;```&#10;&#10;### Manual Installation&#10;&#10;1. Download the latest JAR from [GitHub Releases](https://github.com/W1LDN16H7/h2-orm/releases)&#10;2. Use the **complete JAR** for easiest setup: `h2-orm-1.0.0-complete.jar`&#10;3. Add to your project classpath&#10;&#10;##  Quick Start&#10;&#10;### Step 1: Define Your Entity&#10;&#10;```java&#10;import h2.orm.annotations.*;&#10;&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(name = &quot;username&quot;, nullable = false, unique = true)&#10;    private String username;&#10;    &#10;    @Column(name = &quot;email&quot;)&#10;    private String email;&#10;    &#10;    @Column(name = &quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;    &#10;    // Constructors, getters, setters...&#10;    public User() {&#10;        this.createdAt = LocalDateTime.now();&#10;    }&#10;    &#10;    public User(String username, String email) {&#10;        this();&#10;        this.username = username;&#10;        this.email = email;&#10;    }&#10;    &#10;    // Getters and setters...&#10;}&#10;```&#10;&#10;### Step 2: Start H2-ORM and Get Repository&#10;&#10;```java&#10;import h2.orm.H2ORM;&#10;import h2.orm.core.repository.JpaRepository;&#10;&#10;// Start H2-ORM (automatic table creation)&#10;H2ORM.startInMemory(); // or H2ORM.start(&quot;./data/myapp&quot;) for file-based&#10;&#10;// Get repository - just like Spring Boot!&#10;JpaRepository&lt;User, Long&gt; userRepo = H2ORM.repository(User.class);&#10;```&#10;&#10;### Step 3: Perform CRUD Operations&#10;&#10;```java&#10;// Create users&#10;User alice = new User(&quot;alice&quot;, &quot;alice@example.com&quot;);&#10;User bob = new User(&quot;bob&quot;, &quot;bob@example.com&quot;);&#10;&#10;// Save (like Spring Data JPA)&#10;userRepo.saveAll(List.of(alice, bob));&#10;&#10;// Find users&#10;List&lt;User&gt; allUsers = userRepo.findAll();&#10;Optional&lt;User&gt; user = userRepo.findById(1L);&#10;List&lt;User&gt; sortedUsers = userRepo.findAll(Sort.by(&quot;username&quot;));&#10;&#10;// Advanced queries&#10;List&lt;User&gt; activeUsers = userRepo.findByField(&quot;isActive&quot;, true);&#10;Page&lt;User&gt; userPage = userRepo.findAll(PageRequest.of(0, 10));&#10;&#10;// Cleanup&#10;H2ORM.stop();&#10;```&#10;&#10;### Database Configuration&#10;&#10;```java&#10;// Different database types&#10;H2ORM.startInMemory();                    // H2 in-memory&#10;H2ORM.start(&quot;./data/myapp&quot;);              // H2 file-based&#10;H2ORM.startSQLite(&quot;./data/app.db&quot;);       // SQLite&#10;H2ORM.startMySQL(&quot;localhost&quot;, 3306, &quot;mydb&quot;, &quot;user&quot;, &quot;pass&quot;);     // MySQL&#10;H2ORM.startPostgreSQL(&quot;localhost&quot;, 5432, &quot;mydb&quot;, &quot;user&quot;, &quot;pass&quot;); // PostgreSQL&#10;```&#10;&#10;##  Advanced Features&#10;&#10;### Backup and Export&#10;&#10;```java&#10;// Easy backup and export&#10;H2ORM.backup(&quot;./backups/myapp_backup&quot;);&#10;H2ORM.backupCompressed(&quot;./backups/compressed&quot;);&#10;&#10;// Export to different formats&#10;H2ORM.exportToCsv(User.class, &quot;./exports/users.csv&quot;);&#10;H2ORM.exportToExcel(User.class, &quot;./exports/users.xlsx&quot;);&#10;H2ORM.exportToJson(User.class, &quot;./exports/users.json&quot;);&#10;```&#10;&#10;### Sorting and Pagination&#10;&#10;```java&#10;// Sorting&#10;Sort sort = Sort.by(&quot;username&quot;).and(Sort.by(&quot;createdAt&quot;).descending());&#10;List&lt;User&gt; sortedUsers = userRepo.findAll(sort);&#10;&#10;// Pagination&#10;PageRequest pageRequest = PageRequest.of(0, 20, Sort.by(&quot;username&quot;));&#10;Page&lt;User&gt; userPage = userRepo.findAll(pageRequest);&#10;&#10;System.out.println(&quot;Total users: &quot; + userPage.getTotalElements());&#10;System.out.println(&quot;Total pages: &quot; + userPage.getTotalPages());&#10;```&#10;&#10;### Advanced Querying&#10;&#10;```java&#10;// Field-based queries&#10;List&lt;User&gt; activeUsers = userRepo.findByField(&quot;isActive&quot;, true);&#10;List&lt;User&gt; recentUsers = userRepo.findByFieldBetween(&quot;createdAt&quot;, startDate, endDate);&#10;List&lt;User&gt; usersWithEmail = userRepo.findByFieldIsNotNull(&quot;email&quot;);&#10;&#10;// Multiple field queries&#10;Map&lt;String, Object&gt; criteria = Map.of(&#10;    &quot;isActive&quot;, true,&#10;    &quot;role&quot;, &quot;ADMIN&quot;&#10;);&#10;List&lt;User&gt; adminUsers = userRepo.findByFields(criteria);&#10;```&#10;&#10;## ️ Build from Source&#10;&#10;### Prerequisites&#10;&#10;- **Java 21+** - Required for building&#10;- **Maven 3.6+** - Build tool&#10;- **Git** - Version control&#10;&#10;### Build Steps&#10;&#10;```bash&#10;# Clone the repository&#10;git clone https://github.com/W1LDN16H7/h2-orm.git&#10;cd h2-orm&#10;&#10;# Build the project&#10;./mvnw clean package&#10;&#10;# Run tests&#10;./mvnw test&#10;&#10;# Install to local Maven repository&#10;./mvnw install&#10;```&#10;&#10;### Development Tools&#10;&#10;```bash&#10;# Use the development script (Linux/Mac)&#10;./dev-tools.sh compile  # Compile source code&#10;./dev-tools.sh test     # Run all tests&#10;./dev-tools.sh package  # Create JAR file&#10;./dev-tools.sh clean    # Clean build artifacts&#10;&#10;# Windows&#10;.\build.bat&#10;```&#10;&#10;##  Contributing&#10;&#10;We welcome contributions from the community! Whether you're fixing bugs, adding features, improving documentation, or spreading the word, every contribution is valuable.&#10;&#10;###  Quick Start for Contributors&#10;&#10;1. **Fork** the repository on GitHub&#10;2. **Clone** your fork locally&#10;3. **Create** a feature branch&#10;4. **Make** your changes&#10;5. **Submit** a pull request&#10;&#10;###  Ways to Contribute&#10;&#10;| Type | Description | Examples |&#10;|------|-------------|----------|&#10;|  **Bug Fixes** | Fix issues and improve stability | Fix query bugs, memory leaks, edge cases |&#10;| ✨ **Features** | Add new functionality | New database support, query methods, export formats |&#10;|  **Documentation** | Improve docs and examples | README updates, JavaDoc, tutorials |&#10;|  **Testing** | Add tests and improve coverage | Unit tests, integration tests, performance tests |&#10;|  **Code Quality** | Refactoring and optimization | Performance improvements, code cleanup |&#10;|  **Translations** | Help with internationalization | Error messages, documentation |&#10;&#10;### ️ Development Setup&#10;&#10;#### Prerequisites&#10;```bash&#10;# Required tools&#10;Java 21+                 # Development and runtime&#10;Maven 3.6+              # Build tool&#10;Git                     # Version control&#10;Your favorite IDE       # IntelliJ IDEA, Eclipse, VS Code&#10;```&#10;&#10;#### Local Development&#10;```bash&#10;# 1. Fork and clone the repository&#10;git clone https://github.com/YOUR_USERNAME/h2-orm.git&#10;cd h2-orm&#10;&#10;# 2. Build the project&#10;./mvnw clean compile&#10;&#10;# 3. Run tests to ensure everything works&#10;./mvnw test&#10;&#10;# 4. Create a feature branch&#10;git checkout -b feature/your-feature-name&#10;&#10;# 5. Make your changes and test&#10;./mvnw test&#10;&#10;# 6. Build the complete project&#10;./mvnw clean package&#10;```&#10;&#10;###  Contribution Guidelines&#10;&#10;#### Code Style&#10;- **Follow existing patterns** - Look at existing code for style guidance&#10;- **Java conventions** - Use standard Java naming and formatting&#10;- **Comments** - Add JavaDoc for public APIs and complex logic&#10;- **Consistency** - Maintain consistency with the existing codebase&#10;&#10;#### Commit Messages&#10;Use clear, descriptive commit messages:&#10;```bash&#10;# Good examples&#10;git commit -m &quot;feat: add SQLite database support&quot;&#10;git commit -m &quot;fix: resolve sorting issue with null values&quot;&#10;git commit -m &quot;docs: update README with pagination examples&quot;&#10;git commit -m &quot;test: add integration tests for backup functionality&quot;&#10;&#10;# Format: type(scope): description&#10;# Types: feat, fix, docs, test, refactor, style, chore&#10;```&#10;&#10;#### Pull Request Process&#10;&#10;1. **Update Documentation** - Ensure README, JavaDoc, and examples are updated&#10;2. **Add Tests** - Include tests for new features or bug fixes&#10;3. **Pass All Tests** - Ensure `./mvnw test` passes completely&#10;4. **One Feature Per PR** - Keep pull requests focused on a single change&#10;5. **Descriptive Title** - Use clear, concise PR titles&#10;6. **Detailed Description** - Explain what, why, and how&#10;&#10;#### Pull Request Template&#10;```markdown&#10;## Description&#10;Brief description of changes&#10;&#10;## Type of Change&#10;- [ ] Bug fix (non-breaking change which fixes an issue)&#10;- [ ] New feature (non-breaking change which adds functionality)&#10;- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)&#10;- [ ] Documentation update&#10;&#10;## Testing&#10;- [ ] Tests pass locally with my changes&#10;- [ ] I have added tests that prove my fix is effective or that my feature works&#10;- [ ] New and existing unit tests pass locally with my changes&#10;&#10;## Checklist&#10;- [ ] My code follows the style guidelines of this project&#10;- [ ] I have performed a self-review of my own code&#10;- [ ] I have commented my code, particularly in hard-to-understand areas&#10;- [ ] I have made corresponding changes to the documentation&#10;- [ ] My changes generate no new warnings&#10;```&#10;&#10;###  Testing Guidelines&#10;&#10;#### Running Tests&#10;```bash&#10;# Run all tests&#10;./mvnw test&#10;&#10;# Run specific test class&#10;./mvnw test -Dtest=H2ORMTest&#10;&#10;# Run tests with coverage report&#10;./mvnw jacoco:prepare-agent test jacoco:report&#10;&#10;# View coverage report&#10;open target/site/jacoco/index.html&#10;```&#10;&#10;#### Writing Tests&#10;- **Unit Tests** - Test individual methods and classes&#10;- **Integration Tests** - Test database operations and workflows&#10;- **Edge Cases** - Test boundary conditions and error scenarios&#10;- **Performance Tests** - Test with larger datasets when applicable&#10;&#10;#### Test Structure&#10;```java&#10;@Test&#10;@DisplayName(&quot;Should save user and generate ID&quot;)&#10;void shouldSaveUserAndGenerateId() {&#10;    // Given&#10;    User user = new User(&quot;testuser&quot;, &quot;test@example.com&quot;);&#10;    &#10;    // When&#10;    User savedUser = userRepo.save(user);&#10;    &#10;    // Then&#10;    assertNotNull(savedUser.getId());&#10;    assertEquals(&quot;testuser&quot;, savedUser.getUsername());&#10;}&#10;```&#10;&#10;###  Reporting Issues&#10;&#10;#### Before Reporting&#10;1. **Check existing issues** - Search for similar problems&#10;2. **Reproduce the issue** - Ensure it's consistently reproducible&#10;3. **Gather information** - Collect relevant details&#10;&#10;#### Issue Template&#10;```markdown&#10;**Bug Description**&#10;A clear and concise description of what the bug is.&#10;&#10;**To Reproduce**&#10;Steps to reproduce the behavior:&#10;1. Code example or configuration&#10;2. Expected behavior&#10;3. Actual behavior&#10;&#10;**Environment**&#10;- OS: [e.g., Windows 11, Ubuntu 20.04]&#10;- Java Version: [e.g., OpenJDK 21]&#10;- H2-ORM Version: [e.g., 1.0.0]&#10;- Database: [e.g., H2, MySQL 8.0]&#10;&#10;**Additional Context**&#10;Add any other context about the problem here.&#10;```&#10;&#10;###  Feature Requests&#10;&#10;We love hearing your ideas! When suggesting features:&#10;&#10;1. **Check existing issues** - Someone might have already suggested it&#10;2. **Describe the use case** - Explain why this feature would be valuable&#10;3. **Provide examples** - Show how you envision using the feature&#10;4. **Consider alternatives** - Think about different approaches&#10;&#10;###  Documentation Contributions&#10;&#10;Documentation is crucial for user adoption:&#10;&#10;- **README improvements** - Better examples, clearer explanations&#10;- **JavaDoc enhancements** - More detailed API documentation&#10;- **Tutorial creation** - Step-by-step guides for common use cases&#10;- **Example projects** - Real-world usage examples&#10;&#10;###  Community Guidelines&#10;&#10;- **Be respectful** - Treat everyone with kindness and respect&#10;- **Be constructive** - Provide helpful feedback and suggestions&#10;- **Be patient** - Remember that this is an open-source project&#10;- **Be inclusive** - Welcome contributors of all backgrounds and skill levels&#10;&#10;###  Recognition&#10;&#10;Contributors will be recognized in:&#10;- **README.md** - Contributors section&#10;- **Release notes** - Feature and fix acknowledgments&#10;- **GitHub contributors** - Automatic GitHub recognition&#10;&#10;###  Getting Help&#10;&#10;Need help contributing? Reach out:&#10;&#10;-  **GitHub Discussions** - [Ask questions and discuss ideas](https://github.com/W1LDN16H7/h2-orm/discussions)&#10;-  **GitHub Issues** - [Report bugs or request features](https://github.com/W1LDN16H7/h2-orm/issues)&#10;-  **Direct Contact** - [W1LDN16H7's GitHub Profile](https://github.com/W1LDN16H7)&#10;&#10;###  Thank You!&#10;&#10;Every contribution, no matter how small, makes H2-ORM better for everyone. Thank you for taking the time to contribute!&#10;&#10;---&#10;&#10;##  License&#10;" />
              <option name="updatedContent" value="# H2-ORM&#10;&#10; **Modern Spring Boot-style ORM Library** for Java - Simple, Fast, and Feature-Rich&#10;&#10;[![Java](https://img.shields.io/badge/Java-21+-orange.svg)](https://openjdk.java.net/)&#10;[![License](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)&#10;[![Build Status](https://img.shields.io/badge/Build-Passing-green.svg)](https://github.com/W1LDN16H7/h2-orm)&#10;[![Version](https://img.shields.io/badge/Version-1.0.0-brightgreen.svg)](https://github.com/W1LDN16H7/h2-orm/releases)&#10;&#10;H2-ORM is a lightweight, powerful Object-Relational Mapping library that brings **Spring Boot-style** repository patterns to any Java application. Built with modern Java features and designed for developer productivity.&#10;&#10;## ✨ Key Features&#10;&#10;-  **Spring Boot-like API** - Familiar repository patterns and annotations&#10;- ️ **Multi-Database Support** - H2, MySQL, PostgreSQL, SQLite&#10;-  **Zero Configuration** - Works out of the box with sensible defaults&#10;-  **High Performance** - Optimized query execution and connection pooling&#10;-  **Advanced Backup/Export** - CSV, JSON, Excel export with compression&#10;-  **Powerful Querying** - Dynamic queries, sorting, pagination&#10;- ️ **Transaction Management** - Automatic rollback and error handling&#10;-  **Rich Documentation** - Complete API docs and examples&#10;&#10;##  Quick Navigation&#10;&#10;- [ Installation](#-installation)&#10;- [ Quick Start](#-quick-start)&#10;- [️ Build from Source](#️-build-from-source)&#10;- [ API Documentation](#-api-documentation)&#10;- [ Testing](#-testing)&#10;- [ Contributing](#-contributing)&#10;- [ License](#-license)&#10;&#10;##  Installation&#10;&#10;### Maven Dependency&#10;&#10;```xml&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;```&#10;&#10;### Gradle Dependency&#10;&#10;```gradle&#10;implementation 'com.h2.orm:h2-orm:1.0.0'&#10;```&#10;&#10;### Manual Installation&#10;&#10;1. Download the latest JAR from [GitHub Releases](https://github.com/W1LDN16H7/h2-orm/releases)&#10;2. Use the **complete JAR** for easiest setup: `h2-orm-1.0.0-complete.jar`&#10;3. Add to your project classpath&#10;&#10;##  Quick Start&#10;&#10;### Step 1: Define Your Entity&#10;&#10;```java&#10;import h2.orm.annotations.*;&#10;&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(name = &quot;username&quot;, nullable = false, unique = true)&#10;    private String username;&#10;    &#10;    @Column(name = &quot;email&quot;)&#10;    private String email;&#10;    &#10;    @Column(name = &quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;    &#10;    // Constructors, getters, setters...&#10;    public User() {&#10;        this.createdAt = LocalDateTime.now();&#10;    }&#10;    &#10;    public User(String username, String email) {&#10;        this();&#10;        this.username = username;&#10;        this.email = email;&#10;    }&#10;    &#10;    // Getters and setters...&#10;}&#10;```&#10;&#10;### Step 2: Start H2-ORM and Get Repository&#10;&#10;```java&#10;import h2.orm.H2ORM;&#10;import h2.orm.core.repository.JpaRepository;&#10;&#10;// Start H2-ORM (automatic table creation)&#10;H2ORM.startInMemory(); // or H2ORM.start(&quot;./data/myapp&quot;) for file-based&#10;&#10;// Get repository - just like Spring Boot!&#10;JpaRepository&lt;User, Long&gt; userRepo = H2ORM.repository(User.class);&#10;```&#10;&#10;### Step 3: Perform CRUD Operations&#10;&#10;```java&#10;// Create users&#10;User alice = new User(&quot;alice&quot;, &quot;alice@example.com&quot;);&#10;User bob = new User(&quot;bob&quot;, &quot;bob@example.com&quot;);&#10;&#10;// Save (like Spring Data JPA)&#10;userRepo.saveAll(List.of(alice, bob));&#10;&#10;// Find users&#10;List&lt;User&gt; allUsers = userRepo.findAll();&#10;Optional&lt;User&gt; user = userRepo.findById(1L);&#10;List&lt;User&gt; sortedUsers = userRepo.findAll(Sort.by(&quot;username&quot;));&#10;&#10;// Advanced queries&#10;List&lt;User&gt; activeUsers = userRepo.findByField(&quot;isActive&quot;, true);&#10;Page&lt;User&gt; userPage = userRepo.findAll(PageRequest.of(0, 10));&#10;&#10;// Cleanup&#10;H2ORM.stop();&#10;```&#10;&#10;### Database Configuration&#10;&#10;```java&#10;// Different database types&#10;H2ORM.startInMemory();                    // H2 in-memory&#10;H2ORM.start(&quot;./data/myapp&quot;);              // H2 file-based&#10;H2ORM.startSQLite(&quot;./data/app.db&quot;);       // SQLite&#10;H2ORM.startMySQL(&quot;localhost&quot;, 3306, &quot;mydb&quot;, &quot;user&quot;, &quot;pass&quot;);     // MySQL&#10;H2ORM.startPostgreSQL(&quot;localhost&quot;, 5432, &quot;mydb&quot;, &quot;user&quot;, &quot;pass&quot;); // PostgreSQL&#10;```&#10;&#10;##  Advanced Features&#10;&#10;### Backup and Export&#10;&#10;```java&#10;// Easy backup and export&#10;H2ORM.backup(&quot;./backups/myapp_backup&quot;);&#10;H2ORM.backupCompressed(&quot;./backups/compressed&quot;);&#10;&#10;// Export to different formats&#10;H2ORM.exportToCsv(User.class, &quot;./exports/users.csv&quot;);&#10;H2ORM.exportToExcel(User.class, &quot;./exports/users.xlsx&quot;);&#10;H2ORM.exportToJson(User.class, &quot;./exports/users.json&quot;);&#10;```&#10;&#10;### Sorting and Pagination&#10;&#10;```java&#10;// Sorting&#10;Sort sort = Sort.by(&quot;username&quot;).and(Sort.by(&quot;createdAt&quot;).descending());&#10;List&lt;User&gt; sortedUsers = userRepo.findAll(sort);&#10;&#10;// Pagination&#10;PageRequest pageRequest = PageRequest.of(0, 20, Sort.by(&quot;username&quot;));&#10;Page&lt;User&gt; userPage = userRepo.findAll(pageRequest);&#10;&#10;System.out.println(&quot;Total users: &quot; + userPage.getTotalElements());&#10;System.out.println(&quot;Total pages: &quot; + userPage.getTotalPages());&#10;```&#10;&#10;### Advanced Querying&#10;&#10;```java&#10;// Field-based queries&#10;List&lt;User&gt; activeUsers = userRepo.findByField(&quot;isActive&quot;, true);&#10;List&lt;User&gt; recentUsers = userRepo.findByFieldBetween(&quot;createdAt&quot;, startDate, endDate);&#10;List&lt;User&gt; usersWithEmail = userRepo.findByFieldIsNotNull(&quot;email&quot;);&#10;&#10;// Multiple field queries&#10;Map&lt;String, Object&gt; criteria = Map.of(&#10;    &quot;isActive&quot;, true,&#10;    &quot;role&quot;, &quot;ADMIN&quot;&#10;);&#10;List&lt;User&gt; adminUsers = userRepo.findByFields(criteria);&#10;```&#10;&#10;## ️ Build from Source&#10;&#10;### Prerequisites&#10;&#10;- **Java 21+** - Required for building&#10;- **Maven 3.6+** - Build tool&#10;- **Git** - Version control&#10;&#10;### Build Steps&#10;&#10;```bash&#10;# Clone the repository&#10;git clone https://github.com/W1LDN16H7/h2-orm.git&#10;cd h2-orm&#10;&#10;# Build the project&#10;./mvnw clean package&#10;&#10;# Run tests&#10;./mvnw test&#10;&#10;# Install to local Maven repository&#10;./mvnw install&#10;```&#10;&#10;### Development Tools&#10;&#10;```bash&#10;# Use the development script (Linux/Mac)&#10;./dev-tools.sh compile  # Compile source code&#10;./dev-tools.sh test     # Run all tests&#10;./dev-tools.sh package  # Create JAR file&#10;./dev-tools.sh clean    # Clean build artifacts&#10;&#10;# Windows&#10;.\build.bat&#10;```&#10;&#10;##  Contributing&#10;&#10;We welcome contributions from the community! Whether you're fixing bugs, adding features, improving documentation, or spreading the word, every contribution is valuable.&#10;&#10;###  Quick Start for Contributors&#10;&#10;1. **Fork** the repository on GitHub&#10;2. **Clone** your fork locally&#10;3. **Create** a feature branch&#10;4. **Make** your changes&#10;5. **Submit** a pull request&#10;&#10;###  Ways to Contribute&#10;&#10;| Type | Description | Examples |&#10;|------|-------------|----------|&#10;|  **Bug Fixes** | Fix issues and improve stability | Fix query bugs, memory leaks, edge cases |&#10;| ✨ **Features** | Add new functionality | New database support, query methods, export formats |&#10;|  **Documentation** | Improve docs and examples | README updates, JavaDoc, tutorials |&#10;|  **Testing** | Add tests and improve coverage | Unit tests, integration tests, performance tests |&#10;|  **Code Quality** | Refactoring and optimization | Performance improvements, code cleanup |&#10;|  **Translations** | Help with internationalization | Error messages, documentation |&#10;&#10;### ️ Development Setup&#10;&#10;#### Prerequisites&#10;```bash&#10;# Required tools&#10;Java 21+                 # Development and runtime&#10;Maven 3.6+              # Build tool&#10;Git                     # Version control&#10;Your favorite IDE       # IntelliJ IDEA, Eclipse, VS Code&#10;```&#10;&#10;#### Local Development&#10;```bash&#10;# 1. Fork and clone the repository&#10;git clone https://github.com/YOUR_USERNAME/h2-orm.git&#10;cd h2-orm&#10;&#10;# 2. Build the project&#10;./mvnw clean compile&#10;&#10;# 3. Run tests to ensure everything works&#10;./mvnw test&#10;&#10;# 4. Create a feature branch&#10;git checkout -b feature/your-feature-name&#10;&#10;# 5. Make your changes and test&#10;./mvnw test&#10;&#10;# 6. Build the complete project&#10;./mvnw clean package&#10;```&#10;&#10;###  Contribution Guidelines&#10;&#10;#### Code Style&#10;- **Follow existing patterns** - Look at existing code for style guidance&#10;- **Java conventions** - Use standard Java naming and formatting&#10;- **Comments** - Add JavaDoc for public APIs and complex logic&#10;- **Consistency** - Maintain consistency with the existing codebase&#10;&#10;#### Commit Messages&#10;Use clear, descriptive commit messages:&#10;```bash&#10;# Good examples&#10;git commit -m &quot;feat: add SQLite database support&quot;&#10;git commit -m &quot;fix: resolve sorting issue with null values&quot;&#10;git commit -m &quot;docs: update README with pagination examples&quot;&#10;git commit -m &quot;test: add integration tests for backup functionality&quot;&#10;&#10;# Format: type(scope): description&#10;# Types: feat, fix, docs, test, refactor, style, chore&#10;```&#10;&#10;#### Pull Request Process&#10;&#10;1. **Update Documentation** - Ensure README, JavaDoc, and examples are updated&#10;2. **Add Tests** - Include tests for new features or bug fixes&#10;3. **Pass All Tests** - Ensure `./mvnw test` passes completely&#10;4. **One Feature Per PR** - Keep pull requests focused on a single change&#10;5. **Descriptive Title** - Use clear, concise PR titles&#10;6. **Detailed Description** - Explain what, why, and how&#10;&#10;#### Pull Request Template&#10;```markdown&#10;## Description&#10;Brief description of changes&#10;&#10;## Type of Change&#10;- [ ] Bug fix (non-breaking change which fixes an issue)&#10;- [ ] New feature (non-breaking change which adds functionality)&#10;- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)&#10;- [ ] Documentation update&#10;&#10;## Testing&#10;- [ ] Tests pass locally with my changes&#10;- [ ] I have added tests that prove my fix is effective or that my feature works&#10;- [ ] New and existing unit tests pass locally with my changes&#10;&#10;## Checklist&#10;- [ ] My code follows the style guidelines of this project&#10;- [ ] I have performed a self-review of my own code&#10;- [ ] I have commented my code, particularly in hard-to-understand areas&#10;- [ ] I have made corresponding changes to the documentation&#10;- [ ] My changes generate no new warnings&#10;```&#10;&#10;###  Testing Guidelines&#10;&#10;#### Running Tests&#10;```bash&#10;# Run all tests&#10;./mvnw test&#10;&#10;# Run specific test class&#10;./mvnw test -Dtest=H2ORMTest&#10;&#10;# Run tests with coverage report&#10;./mvnw jacoco:prepare-agent test jacoco:report&#10;&#10;# View coverage report&#10;open target/site/jacoco/index.html&#10;```&#10;&#10;#### Writing Tests&#10;- **Unit Tests** - Test individual methods and classes&#10;- **Integration Tests** - Test database operations and workflows&#10;- **Edge Cases** - Test boundary conditions and error scenarios&#10;- **Performance Tests** - Test with larger datasets when applicable&#10;&#10;#### Test Structure&#10;```java&#10;@Test&#10;@DisplayName(&quot;Should save user and generate ID&quot;)&#10;void shouldSaveUserAndGenerateId() {&#10;    // Given&#10;    User user = new User(&quot;testuser&quot;, &quot;test@example.com&quot;);&#10;    &#10;    // When&#10;    User savedUser = userRepo.save(user);&#10;    &#10;    // Then&#10;    assertNotNull(savedUser.getId());&#10;    assertEquals(&quot;testuser&quot;, savedUser.getUsername());&#10;}&#10;```&#10;&#10;###  Reporting Issues&#10;&#10;#### Before Reporting&#10;1. **Check existing issues** - Search for similar problems&#10;2. **Reproduce the issue** - Ensure it's consistently reproducible&#10;3. **Gather information** - Collect relevant details&#10;&#10;#### Issue Template&#10;```markdown&#10;**Bug Description**&#10;A clear and concise description of what the bug is.&#10;&#10;**To Reproduce**&#10;Steps to reproduce the behavior:&#10;1. Code example or configuration&#10;2. Expected behavior&#10;3. Actual behavior&#10;&#10;**Environment**&#10;- OS: [e.g., Windows 11, Ubuntu 20.04]&#10;- Java Version: [e.g., OpenJDK 21]&#10;- H2-ORM Version: [e.g., 1.0.0]&#10;- Database: [e.g., H2, MySQL 8.0]&#10;&#10;**Additional Context**&#10;Add any other context about the problem here.&#10;```&#10;&#10;###  Feature Requests&#10;&#10;We love hearing your ideas! When suggesting features:&#10;&#10;1. **Check existing issues** - Someone might have already suggested it&#10;2. **Describe the use case** - Explain why this feature would be valuable&#10;3. **Provide examples** - Show how you envision using the feature&#10;4. **Consider alternatives** - Think about different approaches&#10;&#10;###  Documentation Contributions&#10;&#10;Documentation is crucial for user adoption:&#10;&#10;- **README improvements** - Better examples, clearer explanations&#10;- **JavaDoc enhancements** - More detailed API documentation&#10;- **Tutorial creation** - Step-by-step guides for common use cases&#10;- **Example projects** - Real-world usage examples&#10;&#10;###  Community Guidelines&#10;&#10;- **Be respectful** - Treat everyone with kindness and respect&#10;- **Be constructive** - Provide helpful feedback and suggestions&#10;- **Be patient** - Remember that this is an open-source project&#10;- **Be inclusive** - Welcome contributors of all backgrounds and skill levels&#10;&#10;###  Recognition&#10;&#10;Contributors will be recognized in:&#10;- **README.md** - Contributors section&#10;- **Release notes** - Feature and fix acknowledgments&#10;- **GitHub contributors** - Automatic GitHub recognition&#10;&#10;###  Getting Help&#10;&#10;Need help contributing? Reach out:&#10;&#10;-  **GitHub Discussions** - [Ask questions and discuss ideas](https://github.com/W1LDN16H7/h2-orm/discussions)&#10;-  **GitHub Issues** - [Report bugs or request features](https://github.com/W1LDN16H7/h2-orm/issues)&#10;-  **Direct Contact** - [W1LDN16H7's GitHub Profile](https://github.com/W1LDN16H7)&#10;&#10;###  Thank You!&#10;&#10;Every contribution, no matter how small, makes H2-ORM better for everyone. Thank you for taking the time to contribute!&#10;&#10;##  Exciting Features We're Building&#10;&#10;H2-ORM is constantly evolving! Here are some awesome features and improvements we're working on. **Pick one and help us build the future!**&#10;&#10;###  High-Priority Features (Help Wanted!)&#10;&#10;| Feature | Difficulty | Impact | Description |&#10;|---------|------------|--------|-------------|&#10;|  **Database Migration Tool** | ⭐⭐⭐ |  High | Automatic schema migrations like Flyway/Liquibase |&#10;|  **Query Builder API** | ⭐⭐ |  High | Fluent query builder: `Query.select().from().where().build()` |&#10;|  **Performance Monitoring** | ⭐⭐⭐ |  High | Built-in query performance tracking and metrics |&#10;|  **Connection Pool Dashboard** | ⭐⭐ |  Medium | Web UI for monitoring connection pools |&#10;|  **Advanced Search** | ⭐⭐ |  Medium | Full-text search capabilities with indexing |&#10;|  **REST API Generator** | ⭐⭐⭐⭐ |  High | Auto-generate REST APIs from entities |&#10;|  **Schema Documentation** | ⭐ |  Medium | Auto-generate database schema docs |&#10;|  **Row-Level Security** | ⭐⭐⭐⭐ |  Security | Fine-grained access control |&#10;&#10;###  Known Issues (Great for First-Time Contributors!)&#10;&#10;| Issue | Difficulty | Type | Description |&#10;|-------|------------|------|-------------|&#10;|  **Null Sorting Edge Case** | ⭐ | Bug | Fix null value handling in complex sorts |&#10;| ⚡ **Memory Leak in Batch Operations** | ⭐⭐ | Performance | Optimize memory usage in large batch inserts |&#10;|  **Windows Path Handling** | ⭐ | Bug | Fix file path issues on Windows systems |&#10;|  **Better Error Messages** | ⭐ | UX | More helpful error messages with suggestions |&#10;|  **Code Formatting** | ⭐ | Code Quality | Standardize code formatting across project |&#10;|  **Test Coverage Gaps** | ⭐⭐ | Testing | Increase test coverage to 90%+ |&#10;&#10;###  Community-Requested Features&#10;&#10;Vote and contribute to features requested by the community:&#10;&#10;-  **Reactive Programming Support** - Non-blocking database operations&#10;-  **Docker Integration** - Pre-configured Docker containers&#10;- ☁️ **Cloud Database Support** - AWS RDS, Azure SQL, Google Cloud SQL&#10;-  **Event Sourcing** - Built-in event sourcing capabilities&#10;-  **Encryption at Rest** - Automatic data encryption&#10;-  **Audit Logging** - Track all database changes&#10;-  **Multi-tenancy** - Support for multi-tenant applications&#10;&#10;##  Contribution Gamification&#10;&#10;###  Contributor Levels&#10;&#10;| Level | Badge | Requirements | Perks |&#10;|-------|-------|--------------|-------|&#10;|  **Newcomer** | ![Newcomer](https://img.shields.io/badge/Level-Newcomer-green) | First PR merged | Welcome package, mentorship |&#10;|  **Developer** | ![Developer](https://img.shields.io/badge/Level-Developer-blue) | 3+ PRs, 1 feature | Early access to new features |&#10;|  **Expert** | ![Expert](https://img.shields.io/badge/Level-Expert-purple) | 10+ PRs, major contribution | Design input, beta testing |&#10;|  **Maintainer** | ![Maintainer](https://img.shields.io/badge/Level-Maintainer-gold) | Long-term contributor | Repository access, decision making |&#10;&#10;###  Achievement System&#10;&#10;Unlock achievements as you contribute:&#10;&#10;-  **First Steps** - Submit your first PR&#10;-  **Bug Hunter** - Fix 5 bugs&#10;- ✨ **Feature Creator** - Add a major feature&#10;-  **Documentation Hero** - Improve docs significantly&#10;-  **Test Master** - Add comprehensive test coverage&#10;-  **Community Champion** - Help other contributors&#10;-  **Performance Booster** - Optimize critical performance&#10;-  **Security Guardian** - Fix security vulnerabilities&#10;&#10;## ️ Easy Ways to Get Started&#10;&#10;###  For First-Time Contributors&#10;&#10;**Never contributed to open source? No problem!** Here are beginner-friendly tasks:&#10;&#10;1. ** Fix Typos** - Find and fix typos in documentation&#10;2. ** Improve Examples** - Add more code examples to README&#10;3. ** Write Tests** - Add test cases for existing features&#10;4. ** Update JavaDoc** - Improve API documentation&#10;5. ** Reproduce Bugs** - Help confirm and document issues&#10;&#10;###  For Experienced Developers&#10;&#10;Ready for bigger challenges? Try these:&#10;&#10;1. ** Performance Optimization** - Profile and optimize hot paths&#10;2. ** New Database Support** - Add support for new databases&#10;3. ** Monitoring Integration** - Add Prometheus/Micrometer metrics&#10;4. ** Security Features** - Implement security enhancements&#10;5. ** API Extensions** - Expand the repository API&#10;&#10;##  Innovation Labs&#10;&#10;###  Experimental Features&#10;&#10;Help us experiment with cutting-edge features:&#10;&#10;- ** AI-Powered Query Optimization** - Machine learning for query hints&#10;- ** Real-time Synchronization** - Live data sync between databases&#10;- ** Mobile-First Design** - Optimizations for mobile applications&#10;- ** Streaming Data** - Support for real-time data streams&#10;- ** Smart Caching** - Intelligent caching strategies&#10;&#10;###  Future Roadmap&#10;&#10;What's coming next in H2-ORM:&#10;&#10;- **Q3 2025**: Database migration tool, Advanced query builder&#10;- **Q4 2025**: Performance monitoring, REST API generator&#10;- **Q1 2026**: Cloud integrations, Multi-tenancy support&#10;- **Q2 2026**: Reactive programming, Event sourcing&#10;&#10;##  Contribution Rewards&#10;&#10;###  What You Get&#10;&#10;Contributing to H2-ORM comes with awesome benefits:&#10;&#10;- ** GitHub Profile Badge** - Show off your H2-ORM contributions&#10;- ** Early Access** - Be first to try new features&#10;- **️ Conference Tickets** - Sponsorship for tech conferences (major contributors)&#10;- ** Learning Resources** - Access to premium learning materials&#10;- ** Networking** - Connect with other talented developers&#10;- ** Career Opportunities** - Potential job referrals and recommendations&#10;&#10;###  Hall of Fame&#10;&#10;Top contributors will be featured in our Hall of Fame:&#10;&#10;```markdown&#10;##  Top Contributors&#10;&#10;| Contributor | Contributions | Specialty |&#10;|-------------|---------------|-----------|&#10;| W1LDN16H7 | 100+ commits | Creator &amp; Lead Developer |&#10;| [Your Name] | ? commits | ? |&#10;```&#10;&#10;##  Automated Contribution Tools&#10;&#10;###  Dev Tools Available&#10;&#10;We provide tools to make contributing easier:&#10;&#10;```bash&#10;# Auto-format code&#10;./dev-tools.sh format&#10;&#10;# Run all checks before PR&#10;./dev-tools.sh pre-commit&#10;&#10;# Generate test coverage report&#10;./dev-tools.sh coverage&#10;&#10;# Performance benchmarks&#10;./dev-tools.sh benchmark&#10;&#10;# Security scan&#10;./dev-tools.sh security-scan&#10;```&#10;&#10;###  GitHub Actions&#10;&#10;Our CI/CD pipeline automatically:&#10;&#10;- ✅ **Runs Tests** - All tests on multiple Java versions&#10;-  **Code Quality** - SpotBugs, PMD, and Checkstyle&#10;-  **Coverage** - Tracks and reports test coverage&#10;-  **Security** - Scans for vulnerabilities&#10;-  **Build Artifacts** - Creates distributable JARs&#10;-  **Documentation** - Updates JavaDoc automatically&#10;&#10;##  Community Channels&#10;&#10;###  Join Our Community&#10;&#10;-  **Discord Server** - [H2-ORM Community](https://discord.gg/h2-orm) (Coming Soon!)&#10;-  **Twitter** - Follow [@H2ORM_Dev](https://twitter.com/H2ORM_Dev) for updates&#10;-  **GitHub Issues** - [Report bugs and request features](https://github.com/W1LDN16H7/h2-orm/issues)&#10;-  **GitHub Discussions** - [Ask questions and share ideas](https://github.com/W1LDN16H7/h2-orm/discussions)&#10;-  **Mailing List** - Subscribe for release announcements&#10;&#10;###  Regular Events&#10;&#10;- **️ Monthly Contributors Meeting** - First Friday of each month&#10;- ** Quarterly Hackathon** - Build awesome features together&#10;- ** Weekly Office Hours** - Get help with contributions&#10;- ** Annual Contributor Conference** - Celebrate our community&#10;&#10;##  Special Contribution Opportunities&#10;&#10;###  Google Summer of Code&#10;&#10;H2-ORM participates in GSoC! Students can work on:&#10;- Database migration framework&#10;- Performance monitoring dashboard&#10;- Machine learning query optimization&#10;&#10;###  University Partnerships&#10;&#10;- **Senior Projects** - Use H2-ORM for capstone projects&#10;- **Research Collaboration** - Database performance research&#10;- **Internship Opportunities** - Work directly with the core team&#10;&#10;---&#10;&#10;##  License" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;packaging&gt;jar&lt;/packaging&gt;&#10;&#10;    &lt;name&gt;H2-ORM&lt;/name&gt;&#10;    &lt;description&gt;Modern Spring Boot-style ORM library supporting H2, MySQL, PostgreSQL, and SQLite with advanced backup/export features&lt;/description&gt;&#10;    &lt;url&gt;https://github.com/W1LDN16H7/h2-orm&lt;/url&gt;&#10;    &lt;inceptionYear&gt;2025&lt;/inceptionYear&gt;&#10;&#10;    &lt;licenses&gt;&#10;        &lt;license&gt;&#10;            &lt;name&gt;MIT License&lt;/name&gt;&#10;            &lt;url&gt;https://opensource.org/licenses/MIT&lt;/url&gt;&#10;            &lt;distribution&gt;repo&lt;/distribution&gt;&#10;        &lt;/license&gt;&#10;    &lt;/licenses&gt;&#10;&#10;    &lt;developers&gt;&#10;        &lt;developer&gt;&#10;            &lt;id&gt;w1ldn16h7&lt;/id&gt;&#10;            &lt;name&gt;W1LDN16H7&lt;/name&gt;&#10;            &lt;email&gt;developer@h2orm.com&lt;/email&gt;&#10;            &lt;organization&gt;H2-ORM&lt;/organization&gt;&#10;            &lt;organizationUrl&gt;https://github.com/W1LDN16H7&lt;/organizationUrl&gt;&#10;            &lt;roles&gt;&#10;                &lt;role&gt;Lead Developer&lt;/role&gt;&#10;                &lt;role&gt;Architect&lt;/role&gt;&#10;            &lt;/roles&gt;&#10;            &lt;timezone&gt;+0&lt;/timezone&gt;&#10;        &lt;/developer&gt;&#10;    &lt;/developers&gt;&#10;&#10;    &lt;scm&gt;&#10;        &lt;url&gt;https://github.com/W1LDN16H7/h2-orm&lt;/url&gt;&#10;        &lt;connection&gt;scm:git:git://github.com/W1LDN16H7/h2-orm.git&lt;/connection&gt;&#10;        &lt;developerConnection&gt;scm:git:ssh://git@github.com/W1LDN16H7/h2-orm.git&lt;/developerConnection&gt;&#10;        &lt;tag&gt;HEAD&lt;/tag&gt;&#10;    &lt;/scm&gt;&#10;&#10;    &lt;issueManagement&gt;&#10;        &lt;system&gt;GitHub Issues&lt;/system&gt;&#10;        &lt;url&gt;https://github.com/W1LDN16H7/h2-orm/issues&lt;/url&gt;&#10;    &lt;/issueManagement&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&#10;        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;&#10;        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.release&gt;21&lt;/maven.compiler.release&gt;&#10;        &lt;junit.version&gt;5.13.2&lt;/junit.version&gt;&#10;&#10;        &lt;!-- Core Dependencies --&gt;&#10;        &lt;hibernate.version&gt;6.6.3.Final&lt;/hibernate.version&gt;&#10;        &lt;jakarta.persistence.version&gt;3.2.0&lt;/jakarta.persistence.version&gt;&#10;        &lt;hikaricp.version&gt;6.2.1&lt;/hikaricp.version&gt;&#10;&#10;        &lt;!-- Database Drivers --&gt;&#10;        &lt;h2.version&gt;2.3.232&lt;/h2.version&gt;&#10;        &lt;mysql.version&gt;8.4.0&lt;/mysql.version&gt;&#10;        &lt;postgresql.version&gt;42.7.4&lt;/postgresql.version&gt;&#10;        &lt;sqlite.version&gt;3.46.1.3&lt;/sqlite.version&gt;&#10;&#10;        &lt;!-- Utils --&gt;&#10;        &lt;jackson.version&gt;2.19.0&lt;/jackson.version&gt;&#10;        &lt;poi.version&gt;5.4.1&lt;/poi.version&gt;&#10;        &lt;slf4j.version&gt;2.0.17&lt;/slf4j.version&gt;&#10;        &lt;logback.version&gt;1.5.18&lt;/logback.version&gt;&#10;&#10;        &lt;!-- Plugin Versions --&gt;&#10;        &lt;maven.compiler.plugin.version&gt;3.13.0&lt;/maven.compiler.plugin.version&gt;&#10;        &lt;maven.surefire.plugin.version&gt;3.5.2&lt;/maven.surefire.plugin.version&gt;&#10;        &lt;maven.failsafe.plugin.version&gt;3.5.2&lt;/maven.failsafe.plugin.version&gt;&#10;        &lt;maven.source.plugin.version&gt;3.3.1&lt;/maven.source.plugin.version&gt;&#10;        &lt;maven.javadoc.plugin.version&gt;3.11.1&lt;/maven.javadoc.plugin.version&gt;&#10;        &lt;maven.gpg.plugin.version&gt;3.2.7&lt;/maven.gpg.plugin.version&gt;&#10;        &lt;maven.release.plugin.version&gt;3.1.1&lt;/maven.release.plugin.version&gt;&#10;        &lt;maven.assembly.plugin.version&gt;3.7.1&lt;/maven.assembly.plugin.version&gt;&#10;        &lt;jacoco.plugin.version&gt;0.8.12&lt;/jacoco.plugin.version&gt;&#10;        &lt;spotbugs.plugin.version&gt;4.8.6.4&lt;/spotbugs.plugin.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- JPA &amp; Hibernate --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${jakarta.persistence.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;!-- https://mvnrepository.com/artifact/org.jboss.logmanager/jboss-logmanager --&gt;&#10;        &lt;!--&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.jboss.logmanager&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jboss-logmanager&lt;/artifactId&gt;&#10;            &lt;version&gt;3.1.2.Final&lt;/version&gt;&#10;            &lt;scope&gt;compile&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-hikaricp&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Connection Pool --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;&#10;            &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;&#10;            &lt;version&gt;${hikaricp.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Database Drivers --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.h2database&lt;/groupId&gt;&#10;            &lt;artifactId&gt;h2&lt;/artifactId&gt;&#10;            &lt;version&gt;${h2.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.mysql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;&#10;            &lt;version&gt;9.4.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;            &lt;version&gt;${postgresql.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.xerial&lt;/groupId&gt;&#10;            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;&#10;            &lt;version&gt;${sqlite.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JSON Processing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Excel Export --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Logging --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${slf4j.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;&#10;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;&#10;            &lt;version&gt;${logback.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Log4j to SLF4J Bridge - Routes Log4j calls to SLF4J --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt;&#10;            &lt;version&gt;2.24.3&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JUL to SLF4J Bridge - Routes Java Util Logging to SLF4J --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;&#10;            &lt;version&gt;${slf4j.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Testing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;&#10;            &lt;version&gt;5.11.4&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;!-- Compiler Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.compiler.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;release&gt;${maven.compiler.release}&lt;/release&gt;&#10;                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;&#10;                    &lt;compilerArgs&gt;&#10;                        &lt;arg&gt;-parameters&lt;/arg&gt;&#10;                        &lt;arg&gt;-Xlint:all&lt;/arg&gt;&#10;                        &lt;arg&gt;-Xlint:-processing&lt;/arg&gt;&#10;                    &lt;/compilerArgs&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Surefire Plugin for Unit Tests --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.surefire.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;includes&gt;&#10;                        &lt;include&gt;**/*Test.java&lt;/include&gt;&#10;                        &lt;include&gt;**/*Tests.java&lt;/include&gt;&#10;                    &lt;/includes&gt;&#10;                    &lt;excludes&gt;&#10;                        &lt;exclude&gt;**/*IntegrationTest.java&lt;/exclude&gt;&#10;                    &lt;/excludes&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Failsafe Plugin for Integration Tests --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.failsafe.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;includes&gt;&#10;                        &lt;include&gt;**/*IntegrationTest.java&lt;/include&gt;&#10;                        &lt;include&gt;**/*IT.java&lt;/include&gt;&#10;                    &lt;/includes&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;integration-test&lt;/goal&gt;&#10;                            &lt;goal&gt;verify&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Source Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.source.plugin.version}&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-sources&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Javadoc Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.javadoc.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;${maven.compiler.source}&lt;/source&gt;&#10;                    &lt;target&gt;${maven.compiler.target}&lt;/target&gt;&#10;                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;&#10;                    &lt;doctitle&gt;${project.name} ${project.version} API&lt;/doctitle&gt;&#10;                    &lt;windowTitle&gt;${project.name} ${project.version} API&lt;/windowTitle&gt;&#10;                    &lt;show&gt;public&lt;/show&gt;&#10;                    &lt;nohelp&gt;true&lt;/nohelp&gt;&#10;                    &lt;failOnError&gt;false&lt;/failOnError&gt;&#10;                    &lt;failOnWarnings&gt;false&lt;/failOnWarnings&gt;&#10;                    &lt;additionalJOptions&gt;&#10;                        &lt;additionalJOption&gt;-Xdoclint:none&lt;/additionalJOption&gt;&#10;                    &lt;/additionalJOptions&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-javadocs&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Assembly Plugin for Distribution --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.assembly.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;descriptorRefs&gt;&#10;                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;&#10;                    &lt;/descriptorRefs&gt;&#10;                    &lt;finalName&gt;${project.artifactId}-${project.version}-complete&lt;/finalName&gt;&#10;                    &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;make-assembly&lt;/id&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;single&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- JaCoCo for Code Coverage --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.jacoco&lt;/groupId&gt;&#10;                &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${jacoco.plugin.version}&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;prepare-agent&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;report&lt;/id&gt;&#10;                        &lt;phase&gt;test&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;report&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- SpotBugs for Static Analysis --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;com.github.spotbugs&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spotbugs-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${spotbugs.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;effort&gt;Max&lt;/effort&gt;&#10;                    &lt;threshold&gt;Low&lt;/threshold&gt;&#10;                    &lt;failOnError&gt;false&lt;/failOnError&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;    &lt;profiles&gt;&#10;        &lt;!-- Release Profile --&gt;&#10;        &lt;profile&gt;&#10;            &lt;id&gt;release&lt;/id&gt;&#10;            &lt;build&gt;&#10;                &lt;plugins&gt;&#10;                    &lt;!-- GPG Plugin for Signing --&gt;&#10;                    &lt;plugin&gt;&#10;                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                        &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;&#10;                        &lt;version&gt;${maven.gpg.plugin.version}&lt;/version&gt;&#10;                        &lt;executions&gt;&#10;                            &lt;execution&gt;&#10;                                &lt;id&gt;sign-artifacts&lt;/id&gt;&#10;                                &lt;phase&gt;verify&lt;/phase&gt;&#10;                                &lt;goals&gt;&#10;                                    &lt;goal&gt;sign&lt;/goal&gt;&#10;                                &lt;/goals&gt;&#10;                            &lt;/execution&gt;&#10;                        &lt;/executions&gt;&#10;                    &lt;/plugin&gt;&#10;                &lt;/plugins&gt;&#10;            &lt;/build&gt;&#10;        &lt;/profile&gt;&#10;&#10;        &lt;!-- Development Profile --&gt;&#10;        &lt;profile&gt;&#10;            &lt;id&gt;dev&lt;/id&gt;&#10;            &lt;activation&gt;&#10;                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;&#10;            &lt;/activation&gt;&#10;            &lt;properties&gt;&#10;                &lt;maven.test.skip&gt;false&lt;/maven.test.skip&gt;&#10;            &lt;/properties&gt;&#10;        &lt;/profile&gt;&#10;&#10;        &lt;!-- Fast Build Profile --&gt;&#10;        &lt;profile&gt;&#10;            &lt;id&gt;fast&lt;/id&gt;&#10;            &lt;properties&gt;&#10;                &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt;&#10;                &lt;maven.javadoc.skip&gt;true&lt;/maven.javadoc.skip&gt;&#10;                &lt;spotbugs.skip&gt;true&lt;/spotbugs.skip&gt;&#10;                &lt;jacoco.skip&gt;true&lt;/jacoco.skip&gt;&#10;            &lt;/properties&gt;&#10;        &lt;/profile&gt;&#10;    &lt;/profiles&gt;&#10;&#10;    &lt;distributionManagement&gt;&#10;        &lt;snapshotRepository&gt;&#10;            &lt;id&gt;ossrh&lt;/id&gt;&#10;            &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;&#10;        &lt;/snapshotRepository&gt;&#10;        &lt;repository&gt;&#10;            &lt;id&gt;ossrh&lt;/id&gt;&#10;            &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;&#10;        &lt;/repository&gt;&#10;    &lt;/distributionManagement&gt;&#10;&lt;/project&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;h2-orm&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;packaging&gt;jar&lt;/packaging&gt;&#10;&#10;    &lt;name&gt;H2-ORM&lt;/name&gt;&#10;    &lt;description&gt;Modern Spring Boot-style ORM library supporting H2, MySQL, PostgreSQL, and SQLite with advanced backup/export features&lt;/description&gt;&#10;    &lt;url&gt;https://github.com/W1LDN16H7/h2-orm&lt;/url&gt;&#10;    &lt;inceptionYear&gt;2025&lt;/inceptionYear&gt;&#10;&#10;    &lt;licenses&gt;&#10;        &lt;license&gt;&#10;            &lt;name&gt;MIT License&lt;/name&gt;&#10;            &lt;url&gt;https://opensource.org/licenses/MIT&lt;/url&gt;&#10;            &lt;distribution&gt;repo&lt;/distribution&gt;&#10;        &lt;/license&gt;&#10;    &lt;/licenses&gt;&#10;&#10;    &lt;developers&gt;&#10;        &lt;developer&gt;&#10;            &lt;id&gt;w1ldn16h7&lt;/id&gt;&#10;            &lt;name&gt;W1LDN16H7&lt;/name&gt;&#10;            &lt;url&gt;https://github.com/W1LDN16H7&lt;/url&gt;&#10;            &lt;organization&gt;W1LDN16H7 Development&lt;/organization&gt;&#10;            &lt;organizationUrl&gt;https://github.com/W1LDN16H7&lt;/organizationUrl&gt;&#10;            &lt;roles&gt;&#10;                &lt;role&gt;Lead Developer&lt;/role&gt;&#10;                &lt;role&gt;Architect&lt;/role&gt;&#10;                &lt;role&gt;Maintainer&lt;/role&gt;&#10;            &lt;/roles&gt;&#10;            &lt;timezone&gt;+5:30&lt;/timezone&gt;&#10;        &lt;/developer&gt;&#10;    &lt;/developers&gt;&#10;&#10;    &lt;scm&gt;&#10;        &lt;url&gt;https://github.com/W1LDN16H7/h2-orm&lt;/url&gt;&#10;        &lt;connection&gt;scm:git:git://github.com/W1LDN16H7/h2-orm.git&lt;/connection&gt;&#10;        &lt;developerConnection&gt;scm:git:ssh://git@github.com/W1LDN16H7/h2-orm.git&lt;/developerConnection&gt;&#10;        &lt;tag&gt;HEAD&lt;/tag&gt;&#10;    &lt;/scm&gt;&#10;&#10;    &lt;issueManagement&gt;&#10;        &lt;system&gt;GitHub Issues&lt;/system&gt;&#10;        &lt;url&gt;https://github.com/W1LDN16H7/h2-orm/issues&lt;/url&gt;&#10;    &lt;/issueManagement&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&#10;        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;&#10;        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.release&gt;21&lt;/maven.compiler.release&gt;&#10;        &lt;junit.version&gt;5.13.2&lt;/junit.version&gt;&#10;&#10;        &lt;!-- Core Dependencies --&gt;&#10;        &lt;hibernate.version&gt;6.6.3.Final&lt;/hibernate.version&gt;&#10;        &lt;jakarta.persistence.version&gt;3.2.0&lt;/jakarta.persistence.version&gt;&#10;        &lt;hikaricp.version&gt;6.2.1&lt;/hikaricp.version&gt;&#10;&#10;        &lt;!-- Database Drivers --&gt;&#10;        &lt;h2.version&gt;2.3.232&lt;/h2.version&gt;&#10;        &lt;mysql.version&gt;8.4.0&lt;/mysql.version&gt;&#10;        &lt;postgresql.version&gt;42.7.4&lt;/postgresql.version&gt;&#10;        &lt;sqlite.version&gt;3.46.1.3&lt;/sqlite.version&gt;&#10;&#10;        &lt;!-- Utils --&gt;&#10;        &lt;jackson.version&gt;2.19.0&lt;/jackson.version&gt;&#10;        &lt;poi.version&gt;5.4.1&lt;/poi.version&gt;&#10;        &lt;slf4j.version&gt;2.0.17&lt;/slf4j.version&gt;&#10;        &lt;logback.version&gt;1.5.18&lt;/logback.version&gt;&#10;&#10;        &lt;!-- Plugin Versions --&gt;&#10;        &lt;maven.compiler.plugin.version&gt;3.13.0&lt;/maven.compiler.plugin.version&gt;&#10;        &lt;maven.surefire.plugin.version&gt;3.5.2&lt;/maven.surefire.plugin.version&gt;&#10;        &lt;maven.failsafe.plugin.version&gt;3.5.2&lt;/maven.failsafe.plugin.version&gt;&#10;        &lt;maven.source.plugin.version&gt;3.3.1&lt;/maven.source.plugin.version&gt;&#10;        &lt;maven.javadoc.plugin.version&gt;3.11.1&lt;/maven.javadoc.plugin.version&gt;&#10;        &lt;maven.gpg.plugin.version&gt;3.2.7&lt;/maven.gpg.plugin.version&gt;&#10;        &lt;maven.release.plugin.version&gt;3.1.1&lt;/maven.release.plugin.version&gt;&#10;        &lt;maven.assembly.plugin.version&gt;3.7.1&lt;/maven.assembly.plugin.version&gt;&#10;        &lt;jacoco.plugin.version&gt;0.8.12&lt;/jacoco.plugin.version&gt;&#10;        &lt;spotbugs.plugin.version&gt;4.8.6.4&lt;/spotbugs.plugin.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- JPA &amp; Hibernate --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${jakarta.persistence.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;!-- https://mvnrepository.com/artifact/org.jboss.logmanager/jboss-logmanager --&gt;&#10;        &lt;!--&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.jboss.logmanager&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jboss-logmanager&lt;/artifactId&gt;&#10;            &lt;version&gt;3.1.2.Final&lt;/version&gt;&#10;            &lt;scope&gt;compile&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;&#10;            &lt;artifactId&gt;hibernate-hikaricp&lt;/artifactId&gt;&#10;            &lt;version&gt;${hibernate.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Connection Pool --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;&#10;            &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;&#10;            &lt;version&gt;${hikaricp.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Database Drivers --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.h2database&lt;/groupId&gt;&#10;            &lt;artifactId&gt;h2&lt;/artifactId&gt;&#10;            &lt;version&gt;${h2.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.mysql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;&#10;            &lt;version&gt;9.4.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;            &lt;version&gt;${postgresql.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.xerial&lt;/groupId&gt;&#10;            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;&#10;            &lt;version&gt;${sqlite.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JSON Processing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;&#10;            &lt;version&gt;${jackson.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Excel Export --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;&#10;            &lt;version&gt;${poi.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Logging --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${slf4j.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;&#10;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;&#10;            &lt;version&gt;${logback.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Log4j to SLF4J Bridge - Routes Log4j calls to SLF4J --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt;&#10;            &lt;version&gt;2.24.3&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JUL to SLF4J Bridge - Routes Java Util Logging to SLF4J --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;&#10;            &lt;version&gt;${slf4j.version}&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Testing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;&#10;            &lt;version&gt;5.11.4&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;!-- Compiler Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.compiler.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;release&gt;${maven.compiler.release}&lt;/release&gt;&#10;                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;&#10;                    &lt;compilerArgs&gt;&#10;                        &lt;arg&gt;-parameters&lt;/arg&gt;&#10;                        &lt;arg&gt;-Xlint:all&lt;/arg&gt;&#10;                        &lt;arg&gt;-Xlint:-processing&lt;/arg&gt;&#10;                    &lt;/compilerArgs&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Surefire Plugin for Unit Tests --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.surefire.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;includes&gt;&#10;                        &lt;include&gt;**/*Test.java&lt;/include&gt;&#10;                        &lt;include&gt;**/*Tests.java&lt;/include&gt;&#10;                    &lt;/includes&gt;&#10;                    &lt;excludes&gt;&#10;                        &lt;exclude&gt;**/*IntegrationTest.java&lt;/exclude&gt;&#10;                    &lt;/excludes&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Failsafe Plugin for Integration Tests --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.failsafe.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;includes&gt;&#10;                        &lt;include&gt;**/*IntegrationTest.java&lt;/include&gt;&#10;                        &lt;include&gt;**/*IT.java&lt;/include&gt;&#10;                    &lt;/includes&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;integration-test&lt;/goal&gt;&#10;                            &lt;goal&gt;verify&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Source Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.source.plugin.version}&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-sources&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Javadoc Plugin --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.javadoc.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;${maven.compiler.source}&lt;/source&gt;&#10;                    &lt;target&gt;${maven.compiler.target}&lt;/target&gt;&#10;                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;&#10;                    &lt;doctitle&gt;${project.name} ${project.version} API&lt;/doctitle&gt;&#10;                    &lt;windowTitle&gt;${project.name} ${project.version} API&lt;/windowTitle&gt;&#10;                    &lt;show&gt;public&lt;/show&gt;&#10;                    &lt;nohelp&gt;true&lt;/nohelp&gt;&#10;                    &lt;failOnError&gt;false&lt;/failOnError&gt;&#10;                    &lt;failOnWarnings&gt;false&lt;/failOnWarnings&gt;&#10;                    &lt;additionalJOptions&gt;&#10;                        &lt;additionalJOption&gt;-Xdoclint:none&lt;/additionalJOption&gt;&#10;                    &lt;/additionalJOptions&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;attach-javadocs&lt;/id&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;jar&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- Assembly Plugin for Distribution --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${maven.assembly.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;descriptorRefs&gt;&#10;                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;&#10;                    &lt;/descriptorRefs&gt;&#10;                    &lt;finalName&gt;${project.artifactId}-${project.version}-complete&lt;/finalName&gt;&#10;                    &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;&#10;                &lt;/configuration&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;make-assembly&lt;/id&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;single&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- JaCoCo for Code Coverage --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.jacoco&lt;/groupId&gt;&#10;                &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${jacoco.plugin.version}&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;prepare-agent&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;id&gt;report&lt;/id&gt;&#10;                        &lt;phase&gt;test&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;report&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;!-- SpotBugs for Static Analysis --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;com.github.spotbugs&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spotbugs-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;${spotbugs.plugin.version}&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;effort&gt;Max&lt;/effort&gt;&#10;                    &lt;threshold&gt;Low&lt;/threshold&gt;&#10;                    &lt;failOnError&gt;false&lt;/failOnError&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;    &lt;profiles&gt;&#10;        &lt;!-- Release Profile --&gt;&#10;        &lt;profile&gt;&#10;            &lt;id&gt;release&lt;/id&gt;&#10;            &lt;build&gt;&#10;                &lt;plugins&gt;&#10;                    &lt;!-- GPG Plugin for Signing --&gt;&#10;                    &lt;plugin&gt;&#10;                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                        &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;&#10;                        &lt;version&gt;${maven.gpg.plugin.version}&lt;/version&gt;&#10;                        &lt;executions&gt;&#10;                            &lt;execution&gt;&#10;                                &lt;id&gt;sign-artifacts&lt;/id&gt;&#10;                                &lt;phase&gt;verify&lt;/phase&gt;&#10;                                &lt;goals&gt;&#10;                                    &lt;goal&gt;sign&lt;/goal&gt;&#10;                                &lt;/goals&gt;&#10;                            &lt;/execution&gt;&#10;                        &lt;/executions&gt;&#10;                    &lt;/plugin&gt;&#10;                &lt;/plugins&gt;&#10;            &lt;/build&gt;&#10;        &lt;/profile&gt;&#10;&#10;        &lt;!-- Development Profile --&gt;&#10;        &lt;profile&gt;&#10;            &lt;id&gt;dev&lt;/id&gt;&#10;            &lt;activation&gt;&#10;                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;&#10;            &lt;/activation&gt;&#10;            &lt;properties&gt;&#10;                &lt;maven.test.skip&gt;false&lt;/maven.test.skip&gt;&#10;            &lt;/properties&gt;&#10;        &lt;/profile&gt;&#10;&#10;        &lt;!-- Fast Build Profile --&gt;&#10;        &lt;profile&gt;&#10;            &lt;id&gt;fast&lt;/id&gt;&#10;            &lt;properties&gt;&#10;                &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt;&#10;                &lt;maven.javadoc.skip&gt;true&lt;/maven.javadoc.skip&gt;&#10;                &lt;spotbugs.skip&gt;true&lt;/spotbugs.skip&gt;&#10;                &lt;jacoco.skip&gt;true&lt;/jacoco.skip&gt;&#10;            &lt;/properties&gt;&#10;        &lt;/profile&gt;&#10;    &lt;/profiles&gt;&#10;&#10;    &lt;distributionManagement&gt;&#10;        &lt;snapshotRepository&gt;&#10;            &lt;id&gt;ossrh&lt;/id&gt;&#10;            &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;&#10;        &lt;/snapshotRepository&gt;&#10;        &lt;repository&gt;&#10;            &lt;id&gt;ossrh&lt;/id&gt;&#10;            &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;&#10;        &lt;/repository&gt;&#10;    &lt;/distributionManagement&gt;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/EntityManagerProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/EntityManagerProvider.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.config.DatabaseProperties;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Enhanced EntityManager Provider for H2-ORM library&#10; * Supports H2, SQLite, MySQL, PostgreSQL with advanced configuration management&#10; */&#10;public class EntityManagerProvider {&#10;    private static final Logger logger = LoggerFactory.getLogger(EntityManagerProvider.class);&#10;    private static final Map&lt;String, EntityManagerFactory&gt; factories = new ConcurrentHashMap&lt;&gt;();&#10;    private static final ThreadLocal&lt;EntityManager&gt; entityManagerThreadLocal = new ThreadLocal&lt;&gt;();&#10;    private static String defaultConfigName = &quot;default&quot;;&#10;    private static DatabaseConfiguration currentConfig;&#10;&#10;    /**&#10;     * Initialize with default configuration from properties&#10;     */&#10;    public static void initialize() {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromProperties();&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with custom properties file&#10;     */&#10;    public static void initialize(String propertiesFile) {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with specific configuration&#10;     */&#10;    public static void initialize(DatabaseConfiguration config) {&#10;        initialize(defaultConfigName, config);&#10;        currentConfig = config;&#10;    }&#10;&#10;    /**&#10;     * Initialize with named configuration for multi-database support&#10;     */&#10;    public static void initialize(String configName, DatabaseConfiguration config) {&#10;        EntityManagerFactory existingFactory = factories.get(configName);&#10;        if (existingFactory != null &amp;&amp; existingFactory.isOpen()) {&#10;            existingFactory.close();&#10;        }&#10;&#10;        try {&#10;            Map&lt;String, Object&gt; properties = buildJpaProperties(config);&#10;&#10;            logger.info(&quot;Initializing EntityManagerFactory for config: {} with database: {}&quot;,&#10;                    configName, config.getUrl());&#10;&#10;            EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;h2-orm-pu&quot;, properties);&#10;            factories.put(configName, factory);&#10;&#10;            logger.info(&quot;EntityManagerFactory initialized successfully for config: {}&quot;, configName);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to initialize EntityManagerFactory for config: {}&quot;, configName, e);&#10;            throw new RuntimeException(&quot;Failed to initialize database connection&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for default configuration&#10;     */&#10;    public static EntityManager getEntityManager() {&#10;        return getEntityManager(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for named configuration&#10;     */&#10;    public static EntityManager getEntityManager(String configName) {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em == null || !em.isOpen()) {&#10;            EntityManagerFactory factory = factories.get(configName);&#10;            if (factory == null) {&#10;                throw new IllegalStateException(&quot;EntityManagerFactory not initialized for config: &quot; + configName);&#10;            }&#10;            em = factory.createEntityManager();&#10;            entityManagerThreadLocal.set(em);&#10;        }&#10;        return em;&#10;    }&#10;&#10;    /**&#10;     * Close current thread's EntityManager&#10;     */&#10;    public static void closeEntityManager() {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em != null &amp;&amp; em.isOpen()) {&#10;            try {&#10;                if (em.getTransaction().isActive()) {&#10;                    em.getTransaction().rollback();&#10;                }&#10;                em.close();&#10;            } catch (Exception e) {&#10;                logger.warn(&quot;Error closing EntityManager&quot;, e);&#10;            } finally {&#10;                entityManagerThreadLocal.remove();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(TransactionCallback&lt;T&gt; callback) {&#10;        return executeInTransaction(defaultConfigName, callback);&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, TransactionCallback&lt;T&gt; callback) {&#10;        EntityManager em = getEntityManager(configName);&#10;        try {&#10;            em.getTransaction().begin();&#10;            T result = callback.execute(em);&#10;            em.getTransaction().commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;            }&#10;            throw new RuntimeException(&quot;Transaction failed&quot;, e);&#10;        } finally {&#10;            closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown all EntityManagerFactories&#10;     */&#10;    public static void shutdown() {&#10;        closeEntityManager();&#10;        factories.values().forEach(factory -&gt; {&#10;            if (factory.isOpen()) {&#10;                try {&#10;                    factory.close();&#10;                } catch (Exception e) {&#10;                    logger.warn(&quot;Error closing EntityManagerFactory&quot;, e);&#10;                }&#10;            }&#10;        });&#10;        factories.clear();&#10;        logger.info(&quot;All EntityManagerFactories shut down&quot;);&#10;    }&#10;&#10;    /**&#10;     * Check if provider is initialized&#10;     */&#10;    public static boolean isInitialized() {&#10;        return isInitialized(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Check if named configuration is initialized&#10;     */&#10;    public static boolean isInitialized(String configName) {&#10;        EntityManagerFactory factory = factories.get(configName);&#10;        return factory != null &amp;&amp; factory.isOpen();&#10;    }&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public static DatabaseConfiguration getCurrentConfiguration() {&#10;        return currentConfig;&#10;    }&#10;&#10;    private static Map&lt;String, Object&gt; buildJpaProperties(DatabaseConfiguration config) {&#10;        Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();&#10;&#10;        // Basic connection properties&#10;        properties.put(&quot;jakarta.persistence.jdbc.driver&quot;, config.getDriverClass());&#10;        properties.put(&quot;jakarta.persistence.jdbc.url&quot;, config.getUrl());&#10;        properties.put(&quot;jakarta.persistence.jdbc.user&quot;, config.getUsername());&#10;        properties.put(&quot;jakarta.persistence.jdbc.password&quot;, config.getPassword());&#10;&#10;        // Hibernate specific properties&#10;        properties.put(&quot;hibernate.dialect&quot;, config.getDialect());&#10;        properties.put(&quot;hibernate.hbm2ddl.auto&quot;, config.getDdlAuto());&#10;        properties.put(&quot;hibernate.show_sql&quot;, String.valueOf(config.isShowSql()));&#10;        properties.put(&quot;hibernate.format_sql&quot;, String.valueOf(config.isFormatSql()));&#10;        properties.put(&quot;hibernate.use_sql_comments&quot;, &quot;true&quot;);&#10;&#10;        // Connection pool settings (HikariCP)&#10;        properties.put(&quot;hibernate.connection.provider_class&quot;, &quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;);&#10;        properties.put(&quot;hibernate.hikari.maximumPoolSize&quot;, String.valueOf(config.getPoolSize()));&#10;        properties.put(&quot;hibernate.hikari.minimumIdle&quot;, String.valueOf(config.getMinimumIdle()));&#10;        properties.put(&quot;hibernate.hikari.connectionTimeout&quot;, String.valueOf(config.getConnectionTimeout()));&#10;        properties.put(&quot;hibernate.hikari.idleTimeout&quot;, String.valueOf(config.getIdleTimeout()));&#10;        properties.put(&quot;hibernate.hikari.maxLifetime&quot;, String.valueOf(config.getMaxLifetime()));&#10;        properties.put(&quot;hibernate.hikari.poolName&quot;, config.getPoolName());&#10;&#10;        // Performance settings&#10;        properties.put(&quot;hibernate.jdbc.batch_size&quot;, String.valueOf(config.getBatchSize()));&#10;        properties.put(&quot;hibernate.order_inserts&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.order_updates&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.jdbc.batch_versioned_data&quot;, &quot;true&quot;);&#10;&#10;        // Cache settings - Disable caching by default for simplicity&#10;        properties.put(&quot;hibernate.cache.use_second_level_cache&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.cache.use_query_cache&quot;, &quot;false&quot;);&#10;&#10;        if (config.isUseSecondLevelCache()) {&#10;            // Use Hibernate's built-in cache instead of JCache&#10;            properties.put(&quot;hibernate.cache.region.factory_class&quot;, &quot;org.hibernate.cache.internal.NoCacheRegionFactory&quot;);&#10;        }&#10;&#10;        // Additional optimizations&#10;        properties.put(&quot;hibernate.connection.autocommit&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.jdbc.lob.non_contextual_creation&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.temp.use_jdbc_metadata_defaults&quot;, &quot;false&quot;);&#10;&#10;        return properties;&#10;    }&#10;&#10;    /**&#10;     * Functional interface for transaction callbacks&#10;     */&#10;    @FunctionalInterface&#10;    public interface TransactionCallback&lt;T&gt; {&#10;        T execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.config.DatabaseProperties;&#10;import h2.orm.exception.DatabaseNotInitializedException;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Enhanced EntityManager Provider for H2-ORM library&#10; * Supports H2, SQLite, MySQL, PostgreSQL with advanced configuration management&#10; */&#10;public class EntityManagerProvider {&#10;    private static final Logger logger = LoggerFactory.getLogger(EntityManagerProvider.class);&#10;    private static final Map&lt;String, EntityManagerFactory&gt; factories = new ConcurrentHashMap&lt;&gt;();&#10;    private static final ThreadLocal&lt;EntityManager&gt; entityManagerThreadLocal = new ThreadLocal&lt;&gt;();&#10;    private static String defaultConfigName = &quot;default&quot;;&#10;    private static DatabaseConfiguration currentConfig;&#10;&#10;    /**&#10;     * Initialize with default configuration from properties&#10;     */&#10;    public static void initialize() {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromProperties();&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with custom properties file&#10;     */&#10;    public static void initialize(String propertiesFile) {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with specific configuration&#10;     */&#10;    public static void initialize(DatabaseConfiguration config) {&#10;        initialize(defaultConfigName, config);&#10;        currentConfig = config;&#10;    }&#10;&#10;    /**&#10;     * Initialize with named configuration for multi-database support&#10;     */&#10;    public static void initialize(String configName, DatabaseConfiguration config) {&#10;        EntityManagerFactory existingFactory = factories.get(configName);&#10;        if (existingFactory != null &amp;&amp; existingFactory.isOpen()) {&#10;            existingFactory.close();&#10;        }&#10;&#10;        try {&#10;            Map&lt;String, Object&gt; properties = buildJpaProperties(config);&#10;&#10;            logger.info(&quot;Initializing EntityManagerFactory for config: {} with database: {}&quot;,&#10;                    configName, config.getUrl());&#10;&#10;            EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;h2-orm-pu&quot;, properties);&#10;            factories.put(configName, factory);&#10;&#10;            logger.info(&quot;EntityManagerFactory initialized successfully for config: {}&quot;, configName);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to initialize EntityManagerFactory for config: {}&quot;, configName, e);&#10;            throw new RuntimeException(&quot;Failed to initialize database connection&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for default configuration&#10;     */&#10;    public static EntityManager getEntityManager() {&#10;        return getEntityManager(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for named configuration&#10;     */&#10;    public static EntityManager getEntityManager(String configName) {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em == null || !em.isOpen()) {&#10;            EntityManagerFactory factory = factories.get(configName);&#10;            if (factory == null) {&#10;                throw new DatabaseNotInitializedException();&#10;            }&#10;            em = factory.createEntityManager();&#10;            entityManagerThreadLocal.set(em);&#10;        }&#10;        return em;&#10;    }&#10;&#10;    /**&#10;     * Close current thread's EntityManager&#10;     */&#10;    public static void closeEntityManager() {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em != null &amp;&amp; em.isOpen()) {&#10;            try {&#10;                if (em.getTransaction().isActive()) {&#10;                    em.getTransaction().rollback();&#10;                }&#10;                em.close();&#10;            } catch (Exception e) {&#10;                logger.warn(&quot;Error closing EntityManager&quot;, e);&#10;            } finally {&#10;                entityManagerThreadLocal.remove();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(TransactionCallback&lt;T&gt; callback) {&#10;        return executeInTransaction(defaultConfigName, callback);&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, TransactionCallback&lt;T&gt; callback) {&#10;        EntityManager em = getEntityManager(configName);&#10;        try {&#10;            em.getTransaction().begin();&#10;            T result = callback.execute(em);&#10;            em.getTransaction().commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;            }&#10;            throw new RuntimeException(&quot;Transaction failed&quot;, e);&#10;        } finally {&#10;            closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown all EntityManagerFactories&#10;     */&#10;    public static void shutdown() {&#10;        closeEntityManager();&#10;        factories.values().forEach(factory -&gt; {&#10;            if (factory.isOpen()) {&#10;                try {&#10;                    factory.close();&#10;                } catch (Exception e) {&#10;                    logger.warn(&quot;Error closing EntityManagerFactory&quot;, e);&#10;                }&#10;            }&#10;        });&#10;        factories.clear();&#10;        logger.info(&quot;All EntityManagerFactories shut down&quot;);&#10;    }&#10;&#10;    /**&#10;     * Check if provider is initialized&#10;     */&#10;    public static boolean isInitialized() {&#10;        return isInitialized(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Check if named configuration is initialized&#10;     */&#10;    public static boolean isInitialized(String configName) {&#10;        EntityManagerFactory factory = factories.get(configName);&#10;        return factory != null &amp;&amp; factory.isOpen();&#10;    }&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public static DatabaseConfiguration getCurrentConfiguration() {&#10;        return currentConfig;&#10;    }&#10;&#10;    private static Map&lt;String, Object&gt; buildJpaProperties(DatabaseConfiguration config) {&#10;        Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();&#10;&#10;        // Basic connection properties&#10;        properties.put(&quot;jakarta.persistence.jdbc.driver&quot;, config.getDriverClass());&#10;        properties.put(&quot;jakarta.persistence.jdbc.url&quot;, config.getUrl());&#10;        properties.put(&quot;jakarta.persistence.jdbc.user&quot;, config.getUsername());&#10;        properties.put(&quot;jakarta.persistence.jdbc.password&quot;, config.getPassword());&#10;&#10;        // Hibernate specific properties&#10;        properties.put(&quot;hibernate.dialect&quot;, config.getDialect());&#10;        properties.put(&quot;hibernate.hbm2ddl.auto&quot;, config.getDdlAuto());&#10;        properties.put(&quot;hibernate.show_sql&quot;, String.valueOf(config.isShowSql()));&#10;        properties.put(&quot;hibernate.format_sql&quot;, String.valueOf(config.isFormatSql()));&#10;        properties.put(&quot;hibernate.use_sql_comments&quot;, &quot;true&quot;);&#10;&#10;        // Connection pool settings (HikariCP)&#10;        properties.put(&quot;hibernate.connection.provider_class&quot;, &quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;);&#10;        properties.put(&quot;hibernate.hikari.maximumPoolSize&quot;, String.valueOf(config.getPoolSize()));&#10;        properties.put(&quot;hibernate.hikari.minimumIdle&quot;, String.valueOf(config.getMinimumIdle()));&#10;        properties.put(&quot;hibernate.hikari.connectionTimeout&quot;, String.valueOf(config.getConnectionTimeout()));&#10;        properties.put(&quot;hibernate.hikari.idleTimeout&quot;, String.valueOf(config.getIdleTimeout()));&#10;        properties.put(&quot;hibernate.hikari.maxLifetime&quot;, String.valueOf(config.getMaxLifetime()));&#10;        properties.put(&quot;hibernate.hikari.poolName&quot;, config.getPoolName());&#10;&#10;        // Performance settings&#10;        properties.put(&quot;hibernate.jdbc.batch_size&quot;, String.valueOf(config.getBatchSize()));&#10;        properties.put(&quot;hibernate.order_inserts&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.order_updates&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.jdbc.batch_versioned_data&quot;, &quot;true&quot;);&#10;&#10;        // Cache settings - Disable caching by default for simplicity&#10;        properties.put(&quot;hibernate.cache.use_second_level_cache&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.cache.use_query_cache&quot;, &quot;false&quot;);&#10;&#10;        if (config.isUseSecondLevelCache()) {&#10;            // Use Hibernate's built-in cache instead of JCache&#10;            properties.put(&quot;hibernate.cache.region.factory_class&quot;, &quot;org.hibernate.cache.internal.NoCacheRegionFactory&quot;);&#10;        }&#10;&#10;        // Additional optimizations&#10;        properties.put(&quot;hibernate.connection.autocommit&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.jdbc.lob.non_contextual_creation&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.temp.use_jdbc_metadata_defaults&quot;, &quot;false&quot;);&#10;&#10;        return properties;&#10;    }&#10;&#10;    /**&#10;     * Functional interface for transaction callbacks&#10;     */&#10;    @FunctionalInterface&#10;    public interface TransactionCallback&lt;T&gt; {&#10;        T execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/H2ORM.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/H2ORM.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.core.DatabaseInitializer;&#10;import h2.orm.core.TransactionManager;&#10;import h2.orm.core.repository.JpaRepository;&#10;import h2.orm.core.repository.Repositories;&#10;import h2.orm.core.service.BackupService;&#10;import h2.orm.core.service.ExportService;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Main entry point for H2-ORM library - makes it super easy to use!&#10; *&#10; * Usage:&#10; * 1. H2ORM.start() - Initialize with defaults&#10; * 2. H2ORM.repository(EntityClass.class) - Get repository&#10; * 3. Use repository methods like Spring Boot JPA&#10; * 4. H2ORM.backup() / H2ORM.export() - Easy backup and export&#10; * 5. H2ORM.stop() - Clean shutdown&#10; */&#10;public class H2ORM {&#10;&#10;    private static final BackupService backupService = new BackupService();&#10;    private static final ExportService exportService = new ExportService();&#10;&#10;    /**&#10;     * Start H2-ORM with default H2 in-memory database&#10;     */&#10;    public static void start() {&#10;        DatabaseInitializer.initialize(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Start H2-ORM with H2 file-based database&#10;     */&#10;    public static void start(String databasePath) {&#10;        DatabaseInitializer.initialize(DatabaseConfiguration.h2File(databasePath));&#10;    }&#10;&#10;    /**&#10;     * Start H2-ORM with custom configuration&#10;     */&#10;    public static void start(DatabaseConfiguration config) {&#10;        DatabaseInitializer.initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Start H2-ORM from properties file&#10;     */&#10;    public static void startFromProperties(String propertiesFile) {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#10;        DatabaseInitializer.initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Get repository for entity class - exactly like Spring Boot @Autowired&#10;     */&#10;    public static &lt;T, ID extends java.io.Serializable&gt; JpaRepository&lt;T, ID&gt; repository(Class&lt;T&gt; entityClass) {&#10;        return Repositories.of(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Stop H2-ORM and cleanup resources&#10;     */&#10;    public static void stop() {&#10;        DatabaseInitializer.shutdown();&#10;    }&#10;&#10;    /**&#10;     * Check if H2-ORM is running&#10;     */&#10;    public static boolean isRunning() {&#10;        return h2.orm.core.EntityManagerProvider.isInitialized();&#10;    }&#10;&#10;    // Quick setup methods for different databases&#10;&#10;    /**&#10;     * Start with H2 in-memory database (perfect for testing)&#10;     */&#10;    public static void startInMemory() {&#10;        start(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Start with SQLite database&#10;     */&#10;    public static void startSQLite(String dbPath) {&#10;        start(DatabaseConfiguration.sqlite(dbPath));&#10;    }&#10;&#10;    /**&#10;     * Start with MySQL database&#10;     */&#10;    public static void startMySQL(String host, int port, String database, String username, String password) {&#10;        start(DatabaseConfiguration.mysql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Start with PostgreSQL database&#10;     */&#10;    public static void startPostgreSQL(String host, int port, String database, String username, String password) {&#10;        start(DatabaseConfiguration.postgresql(host, port, database, username, password));&#10;    }&#10;&#10;    // ===== BACKUP SERVICES =====&#10;    &#10;    /**&#10;     * Create a database backup&#10;     * Usage: H2ORM.backup(&quot;./backups/myapp_backup&quot;);&#10;     */&#10;    public static void backup(String backupPath) {&#10;        backupService.backup(backupPath);&#10;    }&#10;    &#10;    /**&#10;     * Create a compressed database backup (saves space)&#10;     * Usage: H2ORM.backupCompressed(&quot;./backups/myapp_backup&quot;);&#10;     */&#10;    public static void backupCompressed(String backupPath) {&#10;        backupService.compressed(backupPath);&#10;    }&#10;    &#10;    /**&#10;     * Restore database from backup&#10;     * Usage: H2ORM.restore(&quot;./backups/myapp_backup_20250806_120000.sql&quot;);&#10;     */&#10;    public static void restore(String backupPath) {&#10;        backupService.restore(backupPath);&#10;    }&#10;    &#10;    /**&#10;     * Restore database from compressed backup&#10;     * Usage: H2ORM.restoreCompressed(&quot;./backups/myapp_backup.gz&quot;);&#10;     */&#10;    public static void restoreCompressed(String backupPath) {&#10;        backupService.restoreCompressed(backupPath);&#10;    }&#10;    &#10;    /**&#10;     * Get backup file information&#10;     * Usage: BackupInfo info = H2ORM.getBackupInfo(&quot;./backups/myapp_backup.sql&quot;);&#10;     */&#10;    public static BackupService.BackupInfo getBackupInfo(String backupPath) {&#10;        return backupService.getBackupInfo(backupPath);&#10;    }&#10;&#10;    // ===== EXPORT SERVICES =====&#10;    &#10;    /**&#10;     * Export all data from an entity to CSV&#10;     * Usage: H2ORM.exportToCsv(User.class, &quot;./exports/users.csv&quot;);&#10;     */&#10;    public static &lt;T&gt; void exportToCsv(Class&lt;T&gt; entityClass, String filePath) {&#10;        TransactionManager.executeInTransaction(em -&gt; {&#10;            JpaRepository&lt;T, ?&gt; repo = repository(entityClass);&#10;            List&lt;T&gt; data = repo.findAll();&#10;            // Process export within the same transaction to avoid LazyInitializationException&#10;            exportService.toCsv(data, filePath);&#10;            return null;&#10;        });&#10;    }&#10;    &#10;    /**&#10;     * Export specific data to CSV&#10;     * Usage: H2ORM.exportToCsv(userList, &quot;./exports/users.csv&quot;);&#10;     */&#10;    public static &lt;T&gt; void exportToCsv(List&lt;T&gt; data, String filePath) {&#10;        // Ensure export happens within a transaction to handle any lazy-loaded data&#10;        TransactionManager.executeInTransaction(em -&gt; {&#10;            exportService.toCsv(data, filePath);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Export all data from an entity to Excel&#10;     * Usage: H2ORM.exportToExcel(User.class, &quot;./exports/users.xlsx&quot;);&#10;     */&#10;    public static &lt;T&gt; void exportToExcel(Class&lt;T&gt; entityClass, String filePath) {&#10;        TransactionManager.executeInTransaction(em -&gt; {&#10;            JpaRepository&lt;T, ?&gt; repo = repository(entityClass);&#10;            List&lt;T&gt; data = repo.findAll();&#10;            exportService.toExcel(data, filePath);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Export specific data to Excel&#10;     * Usage: H2ORM.exportToExcel(userList, &quot;./exports/users.xlsx&quot;);&#10;     */&#10;    public static &lt;T&gt; void exportToExcel(List&lt;T&gt; data, String filePath) {&#10;        TransactionManager.executeInTransaction(em -&gt; {&#10;            exportService.toExcel(data, filePath);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Export all data from an entity to JSON&#10;     * Usage: H2ORM.exportToJson(User.class, &quot;./exports/users.json&quot;);&#10;     */&#10;    public static &lt;T&gt; void exportToJson(Class&lt;T&gt; entityClass, String filePath) {&#10;        TransactionManager.executeInTransaction(em -&gt; {&#10;            JpaRepository&lt;T, ?&gt; repo = repository(entityClass);&#10;            List&lt;T&gt; data = repo.findAll();&#10;            exportService.toJson(data, filePath);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Export specific data to JSON&#10;     * Usage: H2ORM.exportToJson(userList, &quot;./exports/users.json&quot;);&#10;     */&#10;    public static &lt;T&gt; void exportToJson(List&lt;T&gt; data, String filePath) {&#10;        TransactionManager.executeInTransaction(em -&gt; {&#10;            exportService.toJson(data, filePath);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    // ===== UTILITY SERVICES =====&#10;    &#10;    /**&#10;     * Get backup service for advanced operations&#10;     */&#10;    public static BackupService getBackupService() {&#10;        return backupService;&#10;    }&#10;    &#10;    /**&#10;     * Get export service for advanced operations&#10;     */&#10;    public static ExportService getExportService() {&#10;        return exportService;&#10;    }&#10;&#10;    // ===== TABLE MANAGEMENT SERVICES =====&#10;&#10;    /**&#10;     * Create tables for all registered entities&#10;     * Usage: H2ORM.createAll();&#10;     */&#10;    public static void createAllTables() {&#10;        h2.orm.core.service.TableManager.createAll();&#10;    }&#10;&#10;    /**&#10;     * Create table for specific entity&#10;     * Usage: H2ORM.createTable(User.class);&#10;     */&#10;    public static void createTable(Class&lt;?&gt; entityClass) {&#10;        h2.orm.core.service.TableManager.create(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Drop table for specific entity&#10;     * Usage: H2ORM.dropTable(User.class);&#10;     */&#10;    public static void dropTable(Class&lt;?&gt; entityClass) {&#10;        h2.orm.core.service.TableManager.drop(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Drop all tables&#10;     * Usage: H2ORM.dropAllTables();&#10;     */&#10;    public static void dropAllTables() {&#10;        h2.orm.core.service.TableManager.dropAll();&#10;    }&#10;&#10;    /**&#10;     * Truncate table (remove all data but keep structure)&#10;     * Usage: H2ORM.truncateTable(User.class);&#10;     */&#10;    public static void truncateTable(Class&lt;?&gt; entityClass) {&#10;        h2.orm.core.service.TableManager.truncate(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Truncate all tables&#10;     * Usage: H2ORM.truncateAllTables();&#10;     */&#10;    public static void truncateAllTables() {&#10;        h2.orm.core.service.TableManager.truncateAll();&#10;    }&#10;&#10;    /**&#10;     * Check if table exists&#10;     * Usage: boolean exists = H2ORM.tableExists(&quot;users&quot;);&#10;     */&#10;    public static boolean tableExists(String tableName) {&#10;        return h2.orm.core.service.TableManager.exists(tableName);&#10;    }&#10;&#10;    /**&#10;     * Get table row count&#10;     * Usage: long count = H2ORM.getTableRowCount(User.class);&#10;     */&#10;    public static long getTableRowCount(Class&lt;?&gt; entityClass) {&#10;        return h2.orm.core.service.TableManager.getByRowCount(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Get table information&#10;     * Usage: TableInfo info = H2ORM.getTableInfo(User.class);&#10;     */&#10;    public static h2.orm.core.service.TableManager.TableInfo getTableInfo(Class&lt;?&gt; entityClass) {&#10;        return h2.orm.core.service.TableManager.getInfo(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Get all table information&#10;     * Usage: List&lt;TableInfo&gt; allTables = H2ORM.getAllTableInfo();&#10;     */&#10;    public static java.util.List&lt;h2.orm.core.service.TableManager.TableInfo&gt; getAllTableInfo() {&#10;        return h2.orm.core.service.TableManager.getAllTableInfo();&#10;    }&#10;&#10;    /**&#10;     * Reset auto-increment counter for table&#10;     * Usage: H2ORM.resetAutoIncrement(User.class);&#10;     */&#10;    public static void resetAutoIncrement(Class&lt;?&gt; entityClass) {&#10;        h2.orm.core.service.TableManager.resetAutoIncrement(entityClass);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#13;&#10;&#13;&#10;import h2.orm.config.DatabaseConfiguration;&#13;&#10;import h2.orm.core.DatabaseInitializer;&#13;&#10;import h2.orm.core.TransactionManager;&#13;&#10;import h2.orm.core.repository.JpaRepository;&#13;&#10;import h2.orm.core.repository.Repositories;&#13;&#10;import h2.orm.core.service.BackupService;&#13;&#10;import h2.orm.core.service.ExportService;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;/**&#13;&#10; * Main entry point for H2-ORM library - makes it super easy to use!&#13;&#10; *&#13;&#10; * Usage:&#13;&#10; * 1. H2ORM.start() - Initialize with defaults&#13;&#10; * 2. H2ORM.repository(EntityClass.class) - Get repository&#13;&#10; * 3. Use repository methods like Spring Boot JPA&#13;&#10; * 4. H2ORM.backup() / H2ORM.export() - Easy backup and export&#13;&#10; * 5. H2ORM.stop() - Clean shutdown&#13;&#10; */&#13;&#10;public class H2ORM {&#13;&#10;&#13;&#10;    private static final BackupService backupService = new BackupService();&#13;&#10;    private static final ExportService exportService = new ExportService();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Private constructor to prevent instantiation&#13;&#10;     */&#13;&#10;    private H2ORM() {&#13;&#10;        // Utility class - prevent instantiation&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Start H2-ORM with default H2 in-memory database&#13;&#10;     */&#13;&#10;    public static void start() {&#13;&#10;        DatabaseInitializer.initialize(DatabaseConfiguration.h2InMemory());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Start H2-ORM with H2 file-based database&#13;&#10;     */&#13;&#10;    public static void start(String databasePath) {&#13;&#10;        DatabaseInitializer.initialize(DatabaseConfiguration.h2File(databasePath));&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Start H2-ORM with custom configuration&#13;&#10;     */&#13;&#10;    public static void start(DatabaseConfiguration config) {&#13;&#10;        DatabaseInitializer.initialize(config);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Start H2-ORM from properties file&#13;&#10;     */&#13;&#10;    public static void startFromProperties(String propertiesFile) {&#13;&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#13;&#10;        DatabaseInitializer.initialize(config);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get repository for entity class - exactly like Spring Boot @Autowired&#13;&#10;     */&#13;&#10;    public static &lt;T, ID extends java.io.Serializable&gt; JpaRepository&lt;T, ID&gt; repository(Class&lt;T&gt; entityClass) {&#13;&#10;        return Repositories.of(entityClass);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Stop H2-ORM and cleanup resources&#13;&#10;     */&#13;&#10;    public static void stop() {&#13;&#10;        DatabaseInitializer.shutdown();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Check if H2-ORM is running&#13;&#10;     */&#13;&#10;    public static boolean isRunning() {&#13;&#10;        return h2.orm.core.EntityManagerProvider.isInitialized();&#13;&#10;    }&#13;&#10;&#13;&#10;    // Quick setup methods for different databases&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Start with H2 in-memory database (perfect for testing)&#13;&#10;     */&#13;&#10;    public static void startInMemory() {&#13;&#10;        start(DatabaseConfiguration.h2InMemory());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Start with SQLite database&#13;&#10;     */&#13;&#10;    public static void startSQLite(String dbPath) {&#13;&#10;        start(DatabaseConfiguration.sqlite(dbPath));&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Start with MySQL database&#13;&#10;     */&#13;&#10;    public static void startMySQL(String host, int port, String database, String username, String password) {&#13;&#10;        start(DatabaseConfiguration.mysql(host, port, database, username, password));&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Start with PostgreSQL database&#13;&#10;     */&#13;&#10;    public static void startPostgreSQL(String host, int port, String database, String username, String password) {&#13;&#10;        start(DatabaseConfiguration.postgresql(host, port, database, username, password));&#13;&#10;    }&#13;&#10;&#13;&#10;    // ===== BACKUP SERVICES =====&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Create a database backup&#13;&#10;     * Usage: H2ORM.backup(&quot;./backups/myapp_backup&quot;);&#13;&#10;     */&#13;&#10;    public static void backup(String backupPath) {&#13;&#10;        backupService.backup(backupPath);&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Create a compressed database backup (saves space)&#13;&#10;     * Usage: H2ORM.backupCompressed(&quot;./backups/myapp_backup&quot;);&#13;&#10;     */&#13;&#10;    public static void backupCompressed(String backupPath) {&#13;&#10;        backupService.compressed(backupPath);&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Restore database from backup&#13;&#10;     * Usage: H2ORM.restore(&quot;./backups/myapp_backup_20250806_120000.sql&quot;);&#13;&#10;     */&#13;&#10;    public static void restore(String backupPath) {&#13;&#10;        backupService.restore(backupPath);&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Restore database from compressed backup&#13;&#10;     * Usage: H2ORM.restoreCompressed(&quot;./backups/myapp_backup.gz&quot;);&#13;&#10;     */&#13;&#10;    public static void restoreCompressed(String backupPath) {&#13;&#10;        backupService.restoreCompressed(backupPath);&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Get backup file information&#13;&#10;     * Usage: BackupInfo info = H2ORM.getBackupInfo(&quot;./backups/myapp_backup.sql&quot;);&#13;&#10;     */&#13;&#10;    public static BackupService.BackupInfo getBackupInfo(String backupPath) {&#13;&#10;        return backupService.getBackupInfo(backupPath);&#13;&#10;    }&#13;&#10;&#13;&#10;    // ===== EXPORT SERVICES =====&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Export all data from an entity to CSV&#13;&#10;     * Usage: H2ORM.exportToCsv(User.class, &quot;./exports/users.csv&quot;);&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; void exportToCsv(Class&lt;T&gt; entityClass, String filePath) {&#13;&#10;        TransactionManager.executeInTransaction(em -&gt; {&#13;&#10;            JpaRepository&lt;T, ?&gt; repo = repository(entityClass);&#13;&#10;            List&lt;T&gt; data = repo.findAll();&#13;&#10;            // Process export within the same transaction to avoid LazyInitializationException&#13;&#10;            exportService.toCsv(data, filePath);&#13;&#10;            return null;&#13;&#10;        });&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Export specific data to CSV&#13;&#10;     * Usage: H2ORM.exportToCsv(userList, &quot;./exports/users.csv&quot;);&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; void exportToCsv(List&lt;T&gt; data, String filePath) {&#13;&#10;        // Ensure export happens within a transaction to handle any lazy-loaded data&#13;&#10;        TransactionManager.executeInTransaction(em -&gt; {&#13;&#10;            exportService.toCsv(data, filePath);&#13;&#10;            return null;&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Export all data from an entity to Excel&#13;&#10;     * Usage: H2ORM.exportToExcel(User.class, &quot;./exports/users.xlsx&quot;);&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; void exportToExcel(Class&lt;T&gt; entityClass, String filePath) {&#13;&#10;        TransactionManager.executeInTransaction(em -&gt; {&#13;&#10;            JpaRepository&lt;T, ?&gt; repo = repository(entityClass);&#13;&#10;            List&lt;T&gt; data = repo.findAll();&#13;&#10;            exportService.toExcel(data, filePath);&#13;&#10;            return null;&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Export specific data to Excel&#13;&#10;     * Usage: H2ORM.exportToExcel(userList, &quot;./exports/users.xlsx&quot;);&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; void exportToExcel(List&lt;T&gt; data, String filePath) {&#13;&#10;        TransactionManager.executeInTransaction(em -&gt; {&#13;&#10;            exportService.toExcel(data, filePath);&#13;&#10;            return null;&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Export all data from an entity to JSON&#13;&#10;     * Usage: H2ORM.exportToJson(User.class, &quot;./exports/users.json&quot;);&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; void exportToJson(Class&lt;T&gt; entityClass, String filePath) {&#13;&#10;        TransactionManager.executeInTransaction(em -&gt; {&#13;&#10;            JpaRepository&lt;T, ?&gt; repo = repository(entityClass);&#13;&#10;            List&lt;T&gt; data = repo.findAll();&#13;&#10;            exportService.toJson(data, filePath);&#13;&#10;            return null;&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Export specific data to JSON&#13;&#10;     * Usage: H2ORM.exportToJson(userList, &quot;./exports/users.json&quot;);&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; void exportToJson(List&lt;T&gt; data, String filePath) {&#13;&#10;        TransactionManager.executeInTransaction(em -&gt; {&#13;&#10;            exportService.toJson(data, filePath);&#13;&#10;            return null;&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    // ===== UTILITY SERVICES =====&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Get backup service for advanced operations&#13;&#10;     */&#13;&#10;    public static BackupService getBackupService() {&#13;&#10;        return backupService;&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Get export service for advanced operations&#13;&#10;     */&#13;&#10;    public static ExportService getExportService() {&#13;&#10;        return exportService;&#13;&#10;    }&#13;&#10;&#13;&#10;    // ===== TABLE MANAGEMENT SERVICES =====&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create tables for all registered entities&#13;&#10;     * Usage: H2ORM.createAll();&#13;&#10;     */&#13;&#10;    public static void createAllTables() {&#13;&#10;        h2.orm.core.service.TableManager.createAll();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create table for specific entity&#13;&#10;     * Usage: H2ORM.createTable(User.class);&#13;&#10;     */&#13;&#10;    public static void createTable(Class&lt;?&gt; entityClass) {&#13;&#10;        h2.orm.core.service.TableManager.create(entityClass);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Drop table for specific entity&#13;&#10;     * Usage: H2ORM.dropTable(User.class);&#13;&#10;     */&#13;&#10;    public static void dropTable(Class&lt;?&gt; entityClass) {&#13;&#10;        h2.orm.core.service.TableManager.drop(entityClass);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Drop all tables&#13;&#10;     * Usage: H2ORM.dropAllTables();&#13;&#10;     */&#13;&#10;    public static void dropAllTables() {&#13;&#10;        h2.orm.core.service.TableManager.dropAll();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Truncate table (remove all data but keep structure)&#13;&#10;     * Usage: H2ORM.truncateTable(User.class);&#13;&#10;     */&#13;&#10;    public static void truncateTable(Class&lt;?&gt; entityClass) {&#13;&#10;        h2.orm.core.service.TableManager.truncate(entityClass);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Truncate all tables&#13;&#10;     * Usage: H2ORM.truncateAllTables();&#13;&#10;     */&#13;&#10;    public static void truncateAllTables() {&#13;&#10;        h2.orm.core.service.TableManager.truncateAll();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Check if table exists&#13;&#10;     * Usage: boolean exists = H2ORM.tableExists(&quot;users&quot;);&#13;&#10;     */&#13;&#10;    public static boolean tableExists(String tableName) {&#13;&#10;        return h2.orm.core.service.TableManager.exists(tableName);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get table row count&#13;&#10;     * Usage: long count = H2ORM.getTableRowCount(User.class);&#13;&#10;     */&#13;&#10;    public static long getTableRowCount(Class&lt;?&gt; entityClass) {&#13;&#10;        return h2.orm.core.service.TableManager.getByRowCount(entityClass);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get table information&#13;&#10;     * Usage: TableInfo info = H2ORM.getTableInfo(User.class);&#13;&#10;     */&#13;&#10;    public static h2.orm.core.service.TableManager.TableInfo getTableInfo(Class&lt;?&gt; entityClass) {&#13;&#10;        return h2.orm.core.service.TableManager.getInfo(entityClass);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get all table information&#13;&#10;     * Usage: List&lt;TableInfo&gt; allTables = H2ORM.getAllTableInfo();&#13;&#10;     */&#13;&#10;    public static java.util.List&lt;h2.orm.core.service.TableManager.TableInfo&gt; getAllTableInfo() {&#13;&#10;        return h2.orm.core.service.TableManager.getAllTableInfo();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Reset auto-increment counter for table&#13;&#10;     * Usage: H2ORM.resetAutoIncrement(User.class);&#13;&#10;     */&#13;&#10;    public static void resetAutoIncrement(Class&lt;?&gt; entityClass) {&#13;&#10;        h2.orm.core.service.TableManager.resetAutoIncrement(entityClass);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/JpaAdvancedDatabaseHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/JpaAdvancedDatabaseHandler.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.open.autobot.database.jpa.repository.AbstractRepository;&#10;import com.open.autobot.database.jpa.repository.Repository;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.Query;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Modern JPA-based Database Handler&#10; * High-performance replacement for the original H2DatabaseHandler&#10; * Supports H2, MySQL, PostgreSQL, SQLite and other JPA-compatible databases&#10; */&#10;public class JpaAdvancedDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(JpaAdvancedDatabaseHandler.class);&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;    private final Map&lt;Class&lt;?&gt;, Repository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Initialize the database with configuration&#10;     */&#10;    public void initialize(DatabaseConfig config) {&#10;        EntityManagerProvider.initialize(config);&#10;        logger.info(&quot;JPA Advanced Database Handler initialized successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Get or create repository for entity class&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T, ID extends Serializable&gt; Repository&lt;T, ID&gt; getRepository(Class&lt;T&gt; entityClass) {&#10;        return (Repository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, clazz -&gt;&#10;            new GenericRepository&lt;&gt;((Class&lt;T&gt;) clazz)&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        return repo.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save multiple entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return new ArrayList&lt;&gt;();&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        return repo.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findAll();&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findAll(offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByAttribute(Class&lt;T&gt; entityClass, String attributeName, Object value) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByAttribute(attributeName, value);&#10;    }&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByNativeQuery(Class&lt;T&gt; entityClass, String sqlQuery, Object... params) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByNativeQuery(sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByQuery(Class&lt;T&gt; entityClass, String jpqlQuery, Object... params) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByQuery(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.count();&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean existsById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.existsById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    public &lt;T&gt; boolean existsByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.existsByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        return repo.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        repo.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    public &lt;T&gt; void deleteAll(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteAll();&#10;    }&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    public &lt;T&gt; void deleteByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    public int executeUpdate(String jpqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            Query query = em.createQuery(jpqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            int result = query.executeUpdate();&#10;            tx.commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to execute update query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Execute update operation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    public int executeNativeUpdate(String sqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            Query query = em.createNativeQuery(sqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            int result = query.executeUpdate();&#10;            tx.commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to execute native update query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Execute native update operation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Batch insert entities for high performance&#10;     */&#10;    public &lt;T&gt; void batchInsert(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return;&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        repo.batchInsert(entities);&#10;    }&#10;&#10;    /**&#10;     * Batch update entities for high performance&#10;     */&#10;    public &lt;T&gt; void batchUpdate(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return;&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        repo.batchUpdate(entities);&#10;    }&#10;&#10;    /**&#10;     * Create database schema/tables&#10;     */&#10;    public void createSchema() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            // Schema creation is handled by JPA/Hibernate automatically&#10;            // based on the ddl-auto configuration&#10;            tx.commit();&#10;            logger.info(&quot;Database schema created/updated successfully&quot;);&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to create schema: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Schema creation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Drop all tables&#10;     */&#10;    public void dropSchema() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            em.createNativeQuery(&quot;DROP ALL OBJECTS&quot;).executeUpdate();&#10;            tx.commit();&#10;            logger.info(&quot;Database schema dropped successfully&quot;);&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to drop schema: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Schema drop failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get database version&#10;     */&#10;    public String getVersion() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(&quot;SELECT VERSION()&quot;);&#10;            Object result = query.getSingleResult();&#10;            return result != null ? result.toString() : &quot;Unknown&quot;;&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Could not retrieve database version: {}&quot;, e.getMessage());&#10;            return &quot;Unknown&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute custom SQL query and return raw results&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomQuery(String sqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            @SuppressWarnings(&quot;unchecked&quot;)&#10;            List&lt;Object[]&gt; results = query.getResultList();&#10;            return results;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to execute custom query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Custom query execution failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query and return raw results&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomJpql(String jpqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createQuery(jpqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            @SuppressWarnings(&quot;unchecked&quot;)&#10;            List&lt;Object[]&gt; results = query.getResultList();&#10;            return results;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to execute custom JPQL: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Custom JPQL execution failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown the database handler&#10;     */&#10;    public void shutdown() {&#10;        EntityManagerProvider.shutdown();&#10;        logger.info(&quot;JPA Advanced Database Handler shutdown completed&quot;);&#10;    }&#10;&#10;    /**&#10;     * Generic Repository Implementation&#10;     */&#10;    private static class GenericRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;&#10;        public GenericRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;&#10;        // getEntityClass() method is inherited from AbstractRepository&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import h2.orm.repository.AbstractRepository;&#10;import h2.orm.repository.Repository;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.Query;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Advanced JPA-based Database Handler for H2-ORM Standalone Library&#10; * High-performance replacement for traditional database handlers&#10; * Supports H2, MySQL, PostgreSQL, SQLite and other JPA-compatible databases&#10; */&#10;public class JpaAdvancedDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(JpaAdvancedDatabaseHandler.class);&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;    private final Map&lt;Class&lt;?&gt;, Repository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get or create repository for entity class&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T, ID extends Serializable&gt; Repository&lt;T, ID&gt; getRepository(Class&lt;T&gt; entityClass) {&#10;        return (Repository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, clazz -&gt;&#10;            new GenericRepository&lt;&gt;((Class&lt;T&gt;) clazz)&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            em.persist(entity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity saved: {}&quot;, entity.getClass().getSimpleName());&#10;            return entity;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Save all entities in batch&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        if (entities == null || entities.isEmpty()) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;            int batchSize = 20; // Default batch size&#10;            &#10;            for (int i = 0; i &lt; entities.size(); i++) {&#10;                T entity = entities.get(i);&#10;                em.persist(entity);&#10;                savedEntities.add(entity);&#10;                &#10;                if (i % batchSize == 0 &amp;&amp; i &gt; 0) {&#10;                    em.flush();&#10;                    em.clear();&#10;                }&#10;            }&#10;            &#10;            em.flush();&#10;            logger.debug(&quot;Batch saved {} entities&quot;, entities.size());&#10;            return savedEntities;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T updated = em.merge(entity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity updated: {}&quot;, entity.getClass().getSimpleName());&#10;            return updated;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Delete an entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;            em.remove(managedEntity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity deleted: {}&quot;, entity.getClass().getSimpleName());&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T entity = em.find(entityClass, id);&#10;            if (entity != null) {&#10;                em.remove(entity);&#10;                em.flush();&#10;                logger.debug(&quot;Entity deleted by ID: {} - {}&quot;, entityClass.getSimpleName(), id);&#10;            }&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            T entity = em.find(entityClass, id);&#10;            return Optional.ofNullable(entity);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find all entities of a given class&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(root);&#10;            &#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(root);&#10;            &#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            typedQuery.setFirstResult(offset);&#10;            typedQuery.setMaxResults(limit);&#10;            &#10;            return typedQuery.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Count entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;Long&gt; query = cb.createQuery(Long.class);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(cb.count(root));&#10;            &#10;            TypedQuery&lt;Long&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getSingleResult();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean exists(Class&lt;T&gt; entityClass, Object id) {&#10;        return findById(entityClass, id).isPresent();&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            TypedQuery&lt;T&gt; query = em.createQuery(jpql, resultClass);&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            TypedQuery&lt;T&gt; query = em.createQuery(jpql, resultClass);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sql, resultClass);&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query with parameters&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sql, resultClass);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute update query&#10;     */&#10;    public int executeUpdate(String jpql) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            Query query = em.createQuery(jpql);&#10;            return query.executeUpdate();&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute update query with parameters&#10;     */&#10;    public int executeUpdate(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            Query query = em.createQuery(jpql);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.executeUpdate();&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Clear entity manager cache&#10;     */&#10;    public void clearCache() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            em.clear();&#10;            logger.debug(&quot;Entity manager cache cleared&quot;);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Flush pending changes&#10;     */&#10;    public void flush() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            em.flush();&#10;            logger.debug(&quot;Entity manager flushed&quot;);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generic Repository Implementation&#10;     */&#10;    private static class GenericRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;        &#10;        public GenericRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;        &#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/ModernJpaDatabaseHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/ModernJpaDatabaseHandler.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import com.open.autobot.database.jpa.service.BackupService;&#10;import com.open.autobot.database.jpa.service.ChatService;&#10;import com.open.autobot.database.jpa.service.ExportService;&#10;import com.open.autobot.model.Conversation;&#10;import com.open.autobot.model.Message;&#10;import com.open.autobot.model.SenderRole;&#10;import jakarta.persistence.EntityManager;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Modern JPA Advanced Database Handler&#10; *&#10; * A complete replacement for H2DatabaseHandler with modern JPA architecture&#10; * Features:&#10; * - High-performance JPA operations with connection pooling&#10; * - Support for H2, MySQL, PostgreSQL, SQLite&#10; * - Comprehensive CRUD operations&#10; * - Chat system with conversations and messages&#10; * - Backup and restore functionality&#10; * - Export to CSV, Excel, JSON&#10; * - Batch operations for optimal performance&#10; * - Transaction management&#10; * - Query caching and optimization&#10; *&#10; * Usage:&#10; * 1. Initialize with database configuration&#10; * 2. Use save(), findAll(), findById() etc. for basic operations&#10; * 3. Use chat methods for conversation management&#10; * 4. Use backup methods for data protection&#10; * 5. Use export methods for data analysis&#10; */&#10;public class ModernJpaDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(ModernJpaDatabaseHandler.class);&#10;&#10;    private final JpaAdvancedDatabaseHandler coreHandler;&#10;    private final ChatService chatService;&#10;    private final BackupService backupService;&#10;    private final ExportService exportService;&#10;&#10;    /**&#10;     * Constructor - Initialize with H2 database (default)&#10;     */&#10;    public ModernJpaDatabaseHandler() {&#10;        this(DatabaseConfig.h2());&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with custom database configuration&#10;     */&#10;    public ModernJpaDatabaseHandler(DatabaseConfig config) {&#10;        this.coreHandler = new JpaAdvancedDatabaseHandler();&#10;        this.chatService = new ChatService();&#10;        this.backupService = new BackupService();&#10;        this.exportService = new ExportService();&#10;&#10;        // Initialize the database&#10;        this.coreHandler.initialize(config);&#10;&#10;        logger.info(&quot;Modern JPA Database Handler initialized with {}&quot;,&#10;                   config.getUrl().contains(&quot;h2&quot;) ? &quot;H2&quot; :&#10;                   config.getUrl().contains(&quot;mysql&quot;) ? &quot;MySQL&quot; :&#10;                   config.getUrl().contains(&quot;postgresql&quot;) ? &quot;PostgreSQL&quot; : &quot;Other database&quot;);&#10;    }&#10;&#10;    // =====================&#10;    // CORE CRUD OPERATIONS&#10;    // =====================&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return coreHandler.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save multiple entities with batch optimization&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        return coreHandler.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.findById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.findAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination (high performance for large datasets)&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        return coreHandler.findAll(entityClass, offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByAttribute(Class&lt;T&gt; entityClass, String attributeName, Object value) {&#10;        return coreHandler.findByAttribute(entityClass, attributeName, value);&#10;    }&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        return coreHandler.findByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByNativeQuery(Class&lt;T&gt; entityClass, String sqlQuery, Object... params) {&#10;        return coreHandler.findByNativeQuery(entityClass, sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByQuery(Class&lt;T&gt; entityClass, String jpqlQuery, Object... params) {&#10;        return coreHandler.findByQuery(entityClass, jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.count(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean existsById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.existsById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    public &lt;T&gt; boolean existsByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        return coreHandler.existsByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return coreHandler.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        coreHandler.deleteById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        coreHandler.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete all entities of a type&#10;     */&#10;    public &lt;T&gt; void deleteAll(Class&lt;T&gt; entityClass) {&#10;        coreHandler.deleteAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    public &lt;T&gt; void deleteByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        coreHandler.deleteByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Batch insert for high performance&#10;     */&#10;    public &lt;T&gt; void batchInsert(List&lt;T&gt; entities) {&#10;        coreHandler.batchInsert(entities);&#10;    }&#10;&#10;    /**&#10;     * Batch update for high performance&#10;     */&#10;    public &lt;T&gt; void batchUpdate(List&lt;T&gt; entities) {&#10;        coreHandler.batchUpdate(entities);&#10;    }&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    public int executeUpdate(String jpqlQuery, Object... params) {&#10;        return coreHandler.executeUpdate(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    public int executeNativeUpdate(String sqlQuery, Object... params) {&#10;        return coreHandler.executeNativeUpdate(sqlQuery, params);&#10;    }&#10;&#10;    // =====================&#10;    // CHAT SYSTEM METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Initialize chat system (called automatically)&#10;     */&#10;    public void initializeChatTables() {&#10;        chatService.initializeChatTables();&#10;    }&#10;&#10;    /**&#10;     * Start a new conversation&#10;     */&#10;    public String startNewConversation(String userId, String title) {&#10;        return chatService.startNewConversation(userId, title);&#10;    }&#10;&#10;    /**&#10;     * Add message to conversation&#10;     */&#10;    public void addMessage(String conversationId, SenderRole role, String content) {&#10;        chatService.addMessage(conversationId, role, content);&#10;    }&#10;&#10;    /**&#10;     * Get conversation history&#10;     */&#10;    public List&lt;Message&gt; getConversationHistory(String conversationId) {&#10;        return chatService.getConversationHistory(conversationId);&#10;    }&#10;&#10;    /**&#10;     * List user conversations&#10;     */&#10;    public List&lt;Conversation&gt; listUserConversations(String userId) {&#10;        return chatService.listUserConversations(userId);&#10;    }&#10;&#10;    /**&#10;     * Rename conversation&#10;     */&#10;    public void renameConversation(String conversationId, String newTitle) {&#10;        chatService.renameConversation(conversationId, newTitle);&#10;    }&#10;&#10;    /**&#10;     * Delete conversation&#10;     */&#10;    public void deleteConversation(String conversationId) {&#10;        chatService.deleteConversation(conversationId);&#10;    }&#10;&#10;    /**&#10;     * Add simple chat message (legacy compatibility)&#10;     */&#10;    public void addChatMessage(String message) {&#10;        chatService.addChatMessage(message);&#10;    }&#10;&#10;    /**&#10;     * Load simple chat history (legacy compatibility)&#10;     */&#10;    public List&lt;String&gt; loadChatHistory() {&#10;        return chatService.loadChatHistory();&#10;    }&#10;&#10;    /**&#10;     * Clear simple chat history (legacy compatibility)&#10;     */&#10;    public void clearChatHistory() {&#10;        chatService.clearChatHistory();&#10;    }&#10;&#10;    // =====================&#10;    // BACKUP &amp; RESTORE METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Create backup of a table&#10;     */&#10;    public String backup(String tableName) {&#10;        return backupService.backup(tableName);&#10;    }&#10;&#10;    /**&#10;     * Create backup of all tables&#10;     */&#10;    public List&lt;String&gt; backupAll() {&#10;        return backupService.backupAll();&#10;    }&#10;&#10;    /**&#10;     * List backup tables&#10;     */&#10;    public List&lt;String&gt; listBackups(String baseTableName) {&#10;        return backupService.listBackups(baseTableName);&#10;    }&#10;&#10;    /**&#10;     * Restore table from backup&#10;     */&#10;    public boolean restore(String backupTableName, String targetTableName) {&#10;        return backupService.restore(backupTableName, targetTableName);&#10;    }&#10;&#10;    /**&#10;     * Delete backup table&#10;     */&#10;    public boolean deleteBackup(String backupTableName) {&#10;        return backupService.deleteBackup(backupTableName);&#10;    }&#10;&#10;    /**&#10;     * Schedule periodic backup&#10;     */&#10;    public void schedulePeriodicBackup(String tableName, long intervalMinutes) {&#10;        backupService.schedulePeriodicBackup(tableName, intervalMinutes);&#10;    }&#10;&#10;    /**&#10;     * Schedule periodic backup for all tables&#10;     */&#10;    public void schedulePeriodicBackupAll(long intervalMinutes) {&#10;        backupService.schedulePeriodicBackupAll(intervalMinutes);&#10;    }&#10;&#10;    /**&#10;     * Create database dump&#10;     */&#10;    public String createDatabaseDump(String filePath) {&#10;        return backupService.createDatabaseDump(filePath);&#10;    }&#10;&#10;    /**&#10;     * Restore from database dump&#10;     */&#10;    public boolean restoreFromDump(String filePath) {&#10;        return backupService.restoreFromDump(filePath);&#10;    }&#10;&#10;    // =====================&#10;    // EXPORT METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Export table to CSV&#10;     */&#10;    public void exportToCSV(String tableName, String filePath) {&#10;        exportService.exportToCSV(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export table to Excel&#10;     */&#10;    public void exportToExcel(String tableName, String filePath) {&#10;        exportService.exportToExcel(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export table to JSON&#10;     */&#10;    public void exportToJSON(String tableName, String filePath) {&#10;        exportService.exportToJSON(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export query results to CSV&#10;     */&#10;    public void exportQueryToCSV(String sqlQuery, String filePath, Object... params) {&#10;        exportService.exportQueryToCSV(sqlQuery, filePath, params);&#10;    }&#10;&#10;    /**&#10;     * Export multiple tables to Excel&#10;     */&#10;    public void exportMultipleTablesToExcel(List&lt;String&gt; tableNames, String filePath) {&#10;        exportService.exportMultipleTablesToExcel(tableNames, filePath);&#10;    }&#10;&#10;    /**&#10;     * Get database statistics&#10;     */&#10;    public Map&lt;String, Object&gt; getDatabaseStatistics() {&#10;        return exportService.getDatabaseStatistics();&#10;    }&#10;&#10;    /**&#10;     * Export database statistics to JSON&#10;     */&#10;    public void exportStatisticsToJSON(String filePath) {&#10;        exportService.exportStatisticsToJSON(filePath);&#10;    }&#10;&#10;    // =====================&#10;    // UTILITY METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Get database version&#10;     */&#10;    public String getVersion() {&#10;        return coreHandler.getVersion();&#10;    }&#10;&#10;    /**&#10;     * Execute custom SQL query&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomQuery(String sqlQuery, Object... params) {&#10;        return coreHandler.executeCustomQuery(sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomJpql(String jpqlQuery, Object... params) {&#10;        return coreHandler.executeCustomJpql(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for advanced operations&#10;     */&#10;    public EntityManager getEntityManager() {&#10;        return EntityManagerProvider.getEntityManager();&#10;    }&#10;&#10;    /**&#10;     * Close current EntityManager&#10;     */&#10;    public void closeEntityManager() {&#10;        EntityManagerProvider.closeEntityManager();&#10;    }&#10;&#10;    /**&#10;     * Create database schema&#10;     */&#10;    public void createSchema() {&#10;        coreHandler.createSchema();&#10;    }&#10;&#10;    /**&#10;     * Drop database schema&#10;     */&#10;    public void dropSchema() {&#10;        coreHandler.dropSchema();&#10;    }&#10;&#10;    /**&#10;     * Shutdown the database handler&#10;     */&#10;    public void shutdown() {&#10;        try {&#10;            backupService.shutdown();&#10;            coreHandler.shutdown();&#10;            logger.info(&quot;Modern JPA Database Handler shutdown completed&quot;);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error during shutdown: {}&quot;, e.getMessage());&#10;        }&#10;    }&#10;&#10;    // =====================&#10;    // FACTORY METHODS FOR DIFFERENT DATABASES&#10;    // =====================&#10;&#10;    /**&#10;     * Create handler for H2 database&#10;     */&#10;    public static ModernJpaDatabaseHandler forH2() {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.h2());&#10;    }&#10;&#10;    /**&#10;     * Create handler for MySQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler forMySQL(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.mysql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Create handler for PostgreSQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler forPostgreSQL(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.postgresql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Create handler for SQLite database&#10;     */&#10;    public static ModernJpaDatabaseHandler forSQLite(String filePath) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.sqlite(filePath));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.service.BackupService;&#10;import h2.orm.service.ExportService;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.function.Consumer;&#10;&#10;/**&#10; * Modern JPA Database Handler for H2-ORM Standalone Library&#10; *&#10; * A complete JPA-based database handler with modern architecture&#10; * Features:&#10; * - High-performance JPA operations with connection pooling&#10; * - Support for H2, MySQL, PostgreSQL, SQLite&#10; * - Comprehensive CRUD operations&#10; * - Backup and restore functionality&#10; * - Export to CSV, Excel, JSON&#10; * - Batch operations for optimal performance&#10; * - Transaction management&#10; * - Query caching and optimization&#10; * - Easy integration as standalone library&#10; *&#10; * Usage:&#10; * 1. Initialize with database configuration&#10; * 2. Use save(), findAll(), findById() etc. for basic operations&#10; * 3. Use backup methods for data protection&#10; * 4. Use export methods for data analysis&#10; */&#10;public class ModernJpaDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(ModernJpaDatabaseHandler.class);&#10;&#10;    private final JpaAdvancedDatabaseHandler coreHandler;&#10;    private final BackupService backupService;&#10;    private final ExportService exportService;&#10;    private final DatabaseConfiguration configuration;&#10;&#10;    /**&#10;     * Constructor - Initialize with default H2 configuration&#10;     */&#10;    public ModernJpaDatabaseHandler() {&#10;        this(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with H2 file-based database&#10;     */&#10;    public ModernJpaDatabaseHandler(String databasePath) {&#10;        this(DatabaseConfiguration.h2File(databasePath));&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with custom configuration&#10;     */&#10;    public ModernJpaDatabaseHandler(DatabaseConfiguration config) {&#10;        this.configuration = config;&#10;&#10;        logger.info(&quot;Initializing ModernJpaDatabaseHandler with configuration: {}&quot;, config);&#10;&#10;        // Initialize EntityManager Provider&#10;        EntityManagerProvider.initialize(config);&#10;&#10;        // Initialize core components&#10;        this.coreHandler = new JpaAdvancedDatabaseHandler();&#10;        this.backupService = new BackupService();&#10;        this.exportService = new ExportService();&#10;&#10;        logger.info(&quot;ModernJpaDatabaseHandler initialized successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Factory method for H2 in-memory database&#10;     */&#10;    public static ModernJpaDatabaseHandler h2InMemory() {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Factory method for H2 file-based database&#10;     */&#10;    public static ModernJpaDatabaseHandler h2File(String path) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.h2File(path));&#10;    }&#10;&#10;    /**&#10;     * Factory method for SQLite database&#10;     */&#10;    public static ModernJpaDatabaseHandler sqlite(String path) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.sqlite(path));&#10;    }&#10;&#10;    /**&#10;     * Factory method for MySQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler mysql(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.mysql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Factory method for PostgreSQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler postgresql(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.postgresql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Factory method from properties file&#10;     */&#10;    public static ModernJpaDatabaseHandler fromProperties(String propertiesFile) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.fromPropertiesFile(propertiesFile));&#10;    }&#10;&#10;    // ===== CRUD Operations =====&#10;&#10;    /**&#10;     * Save entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return coreHandler.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save entity with validation&#10;     */&#10;    public &lt;T&gt; T save(T entity, Consumer&lt;T&gt; validator) {&#10;        if (validator != null) {&#10;            validator.accept(entity);&#10;        }&#10;        return save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        return coreHandler.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Update entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return coreHandler.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        coreHandler.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        coreHandler.deleteById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.findById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.findAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Find with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        return coreHandler.findAll(entityClass, offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Count entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.count(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists&#10;     */&#10;    public &lt;T&gt; boolean exists(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.exists(entityClass, id);&#10;    }&#10;&#10;    // ===== Query Operations =====&#10;&#10;    /**&#10;     * Execute JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass) {&#10;        return coreHandler.query(jpql, resultClass);&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.query(jpql, resultClass, parameters);&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass) {&#10;        return coreHandler.nativeQuery(sql, resultClass);&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.nativeQuery(sql, resultClass, parameters);&#10;    }&#10;&#10;    /**&#10;     * Execute update query&#10;     */&#10;    public int executeUpdate(String jpql) {&#10;        return coreHandler.executeUpdate(jpql);&#10;    }&#10;&#10;    /**&#10;     * Execute update query with parameters&#10;     */&#10;    public int executeUpdate(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.executeUpdate(jpql, parameters);&#10;    }&#10;&#10;    // ===== Criteria API =====&#10;&#10;    /**&#10;     * Create criteria query builder&#10;     */&#10;    public &lt;T&gt; CriteriaQueryBuilder&lt;T&gt; criteriaBuilder(Class&lt;T&gt; entityClass) {&#10;        return new CriteriaQueryBuilder&lt;&gt;(entityClass);&#10;    }&#10;&#10;    // ===== Transaction Management =====&#10;&#10;    /**&#10;     * Execute in transaction&#10;     */&#10;    public &lt;T&gt; T executeInTransaction(EntityManagerProvider.TransactionCallback&lt;T&gt; callback) {&#10;        return EntityManagerProvider.executeInTransaction(callback);&#10;    }&#10;&#10;    /**&#10;     * Execute without result in transaction&#10;     */&#10;    public void executeInTransaction(TransactionCallback callback) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            callback.execute(em);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    // ===== Export Operations =====&#10;&#10;    /**&#10;     * Export to CSV&#10;     */&#10;    public &lt;T&gt; void exportToCsv(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToCsv(data, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export to Excel&#10;     */&#10;    public &lt;T&gt; void exportToExcel(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToExcel(data, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export to JSON&#10;     */&#10;    public &lt;T&gt; void exportToJson(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToJson(data, filePath);&#10;    }&#10;&#10;    // ===== Backup Operations =====&#10;&#10;    /**&#10;     * Create database backup&#10;     */&#10;    public void backup(String backupPath) {&#10;        backupService.createBackup(backupPath);&#10;    }&#10;&#10;    /**&#10;     * Restore database from backup&#10;     */&#10;    public void restore(String backupPath) {&#10;        backupService.restoreBackup(backupPath);&#10;    }&#10;&#10;    // ===== Utility Methods =====&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public DatabaseConfiguration getConfiguration() {&#10;        return configuration;&#10;    }&#10;&#10;    /**&#10;     * Check if handler is initialized&#10;     */&#10;    public boolean isInitialized() {&#10;        return EntityManagerProvider.isInitialized();&#10;    }&#10;&#10;    /**&#10;     * Shutdown handler and cleanup resources&#10;     */&#10;    public void shutdown() {&#10;        logger.info(&quot;Shutting down ModernJpaDatabaseHandler&quot;);&#10;        EntityManagerProvider.shutdown();&#10;        logger.info(&quot;ModernJpaDatabaseHandler shutdown completed&quot;);&#10;    }&#10;&#10;    // ===== Inner Classes =====&#10;&#10;    /**&#10;     * Criteria Query Builder for type-safe queries&#10;     */&#10;    public class CriteriaQueryBuilder&lt;T&gt; {&#10;        private final Class&lt;T&gt; entityClass;&#10;        private final CriteriaBuilder criteriaBuilder;&#10;        private final CriteriaQuery&lt;T&gt; query;&#10;        private final Root&lt;T&gt; root;&#10;&#10;        public CriteriaQueryBuilder(Class&lt;T&gt; entityClass) {&#10;            this.entityClass = entityClass;&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            this.criteriaBuilder = em.getCriteriaBuilder();&#10;            this.query = criteriaBuilder.createQuery(entityClass);&#10;            this.root = query.from(entityClass);&#10;        }&#10;&#10;        public CriteriaQueryBuilder&lt;T&gt; where(String fieldName, Object value) {&#10;            query.where(criteriaBuilder.equal(root.get(fieldName), value));&#10;            return this;&#10;        }&#10;&#10;        public CriteriaQueryBuilder&lt;T&gt; orderBy(String fieldName, boolean ascending) {&#10;            if (ascending) {&#10;                query.orderBy(criteriaBuilder.asc(root.get(fieldName)));&#10;            } else {&#10;                query.orderBy(criteriaBuilder.desc(root.get(fieldName)));&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public List&lt;T&gt; getResultList() {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getResultList();&#10;        }&#10;&#10;        public List&lt;T&gt; getResultList(int maxResults) {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            typedQuery.setMaxResults(maxResults);&#10;            return typedQuery.getResultList();&#10;        }&#10;&#10;        public Optional&lt;T&gt; getSingleResult() {&#10;            List&lt;T&gt; results = getResultList(1);&#10;            return results.isEmpty() ? Optional.empty() : Optional.of(results.get(0));&#10;        }&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface TransactionCallback {&#10;        void execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/MetadataManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/MetadataManager.java" />
              <option name="originalContent" value="package h2.orm.core;&#10;&#10;import jakarta.persistence.*;&#10;import jakarta.persistence.metamodel.EntityType;&#10;import jakarta.persistence.metamodel.Metamodel;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.lang.reflect.Field;&#10;import java.util.*;&#10;&#10;/**&#10; * Core metadata manager for H2-ORM&#10; * Handles entity metadata, reflection, and schema information&#10; */&#10;public class MetadataManager {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(MetadataManager.class);&#10;    private static final Map&lt;Class&lt;?&gt;, EntityMetadata&gt; metadataCache = new HashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get entity metadata with caching&#10;     */&#10;    public static EntityMetadata getEntityMetadata(Class&lt;?&gt; entityClass) {&#10;        return metadataCache.computeIfAbsent(entityClass, MetadataManager::buildEntityMetadata);&#10;    }&#10;&#10;    /**&#10;     * Get all managed entity types&#10;     */&#10;    public static Set&lt;EntityType&lt;?&gt;&gt; getAllEntityTypes() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Metamodel metamodel = em.getMetamodel();&#10;            return metamodel.getEntities();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get table name for entity&#10;     */&#10;    public static String getTableName(Class&lt;?&gt; entityClass) {&#10;        Table tableAnnotation = entityClass.getAnnotation(Table.class);&#10;        if (tableAnnotation != null &amp;&amp; !tableAnnotation.name().isEmpty()) {&#10;            return tableAnnotation.name();&#10;        }&#10;        return entityClass.getSimpleName().toLowerCase();&#10;    }&#10;&#10;    public static String getColumnName(Field field) {&#10;        Column columnAnnotation = field.getAnnotation(Column.class);&#10;        if (columnAnnotation != null &amp;&amp; !columnAnnotation.name().isEmpty()) {&#10;            return columnAnnotation.name();&#10;        }&#10;        return field.getName();&#10;    }&#10;&#10;    /**&#10;     * Build entity metadata&#10;     */&#10;    private static EntityMetadata buildEntityMetadata(Class&lt;?&gt; entityClass) {&#10;        logger.debug(&quot;Building metadata for entity: {}&quot;, entityClass.getSimpleName());&#10;&#10;        EntityMetadata metadata = new EntityMetadata();&#10;        metadata.setEntityClass(entityClass);&#10;        metadata.setTableName(getTableName(entityClass));&#10;&#10;        List&lt;Field&gt; jpaFields = new ArrayList&lt;&gt;();&#10;        Field idField = null;&#10;&#10;        // Process all fields including inherited ones&#10;        Class&lt;?&gt; currentClass = entityClass;&#10;        while (currentClass != null &amp;&amp; !currentClass.equals(Object.class)) {&#10;            for (Field field : currentClass.getDeclaredFields()) {&#10;                if (hasJpaAnnotation(field)) {&#10;    public static boolean isEntityNew(Object entity) {&#10;&#10;                    if (field.isAnnotationPresent(Id.class)) {&#10;                        idField = field;&#10;                    }&#10;                }&#10;            }&#10;            currentClass = currentClass.getSuperclass();&#10;        }&#10;&#10;        metadata.setJpaFields(jpaFields);&#10;        metadata.setIdField(idField);&#10;&#10;        return metadata;&#10;    }&#10;&#10;    /**&#10;     * Check if field has JPA annotations&#10;     */&#10;    private static boolean hasJpaAnnotation(Field field) {&#10;        return field.isAnnotationPresent(Id.class) ||&#10;               field.isAnnotationPresent(Column.class) ||&#10;               field.isAnnotationPresent(JoinColumn.class) ||&#10;               field.isAnnotationPresent(OneToOne.class) ||&#10;               field.isAnnotationPresent(OneToMany.class) ||&#10;               field.isAnnotationPresent(ManyToOne.class) ||&#10;               field.isAnnotationPresent(ManyToMany.class) ||&#10;               field.isAnnotationPresent(Embedded.class) ||&#10;               field.isAnnotationPresent(GeneratedValue.class);&#10;    }&#10;&#10;    /**&#10;     * Clear metadata cache&#10;     */&#10;    public static void clearCache() {&#10;        metadataCache.clear();&#10;        logger.debug(&quot;Metadata cache cleared&quot;);&#10;    }&#10;&#10;    /**&#10;     * Entity metadata holder class&#10;     */&#10;    public static class EntityMetadata {&#10;        private Class&lt;?&gt; entityClass;&#10;        private String tableName;&#10;        private Field idField;&#10;        private List&lt;Field&gt; jpaFields;&#10;&#10;        // Getters and setters&#10;        public Class&lt;?&gt; getEntityClass() { return entityClass; }&#10;        public void setEntityClass(Class&lt;?&gt; entityClass) { this.entityClass = entityClass; }&#10;&#10;        public String getTableName() { return tableName; }&#10;        public void setTableName(String tableName) { this.tableName = tableName; }&#10;&#10;        public Field getIdField() { return idField; }&#10;        public void setIdField(Field idField) { this.idField = idField; }&#10;&#10;        public List&lt;Field&gt; getJpaFields() { return jpaFields; }&#10;        public void setJpaFields(List&lt;Field&gt; jpaFields) { this.jpaFields = jpaFields; }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return &quot;EntityMetadata{&quot; +&#10;                    &quot;entityClass=&quot; + entityClass.getSimpleName() +&#10;                    &quot;, tableName='&quot; + tableName + '\'' +&#10;                    &quot;, idField=&quot; + (idField != null ? idField.getName() : &quot;null&quot;) +&#10;                    &quot;, jpaFieldsCount=&quot; + (jpaFields != null ? jpaFields.size() : 0) +&#10;                    '}';&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.core;&#10;&#10;import jakarta.persistence.*;&#10;import jakarta.persistence.metamodel.EntityType;&#10;import jakarta.persistence.metamodel.Metamodel;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.lang.reflect.Field;&#10;import java.util.*;&#10;&#10;/**&#10; * Core metadata manager for H2-ORM&#10; * Handles entity metadata, reflection, and schema information&#10; */&#10;public class MetadataManager {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(MetadataManager.class);&#10;    private static final Map&lt;Class&lt;?&gt;, EntityMetadata&gt; metadataCache = new HashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get entity metadata with caching&#10;     */&#10;    public static EntityMetadata getEntityMetadata(Class&lt;?&gt; entityClass) {&#10;        return metadataCache.computeIfAbsent(entityClass, MetadataManager::buildEntityMetadata);&#10;    }&#10;&#10;    /**&#10;     * Get all managed entity types&#10;     */&#10;    public static Set&lt;EntityType&lt;?&gt;&gt; getAllEntityTypes() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Metamodel metamodel = em.getMetamodel();&#10;            return metamodel.getEntities();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get table name for entity&#10;     */&#10;    public static String getTableName(Class&lt;?&gt; entityClass) {&#10;        Table tableAnnotation = entityClass.getAnnotation(Table.class);&#10;        if (tableAnnotation != null &amp;&amp; !tableAnnotation.name().isEmpty()) {&#10;            return tableAnnotation.name();&#10;        }&#10;        return entityClass.getSimpleName().toLowerCase();&#10;    }&#10;&#10;    /**&#10;     * Get entity ID value using reflection&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;ID&gt; ID getEntityId(Object entity) {&#10;        if (entity == null) {&#10;            return null;&#10;        }&#10;&#10;        try {&#10;            EntityMetadata metadata = getEntityMetadata(entity.getClass());&#10;            Field idField = metadata.getIdField();&#10;            if (idField != null) {&#10;                idField.setAccessible(true);&#10;                return (ID) idField.get(entity);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Failed to get entity ID for {}: {}&quot;, entity.getClass().getSimpleName(), e.getMessage());&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Check if entity is new (has null or default ID)&#10;     */&#10;    public static boolean isEntityNew(Object entity) {&#10;        if (entity == null) {&#10;            return false;&#10;        }&#10;&#10;        Object id = getEntityId(entity);&#10;        if (id == null) {&#10;            return true;&#10;        }&#10;&#10;        // Check for default values that indicate new entity&#10;        if (id instanceof Number) {&#10;            return ((Number) id).longValue() == 0;&#10;        }&#10;&#10;        if (id instanceof String) {&#10;            return ((String) id).isEmpty();&#10;        }&#10;&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Get ID field for entity&#10;     */&#10;    public static Field getIdField(Class&lt;?&gt; entityClass) {&#10;        return getEntityMetadata(entityClass).getIdField();&#10;    }&#10;&#10;    /**&#10;     * Get ID value from entity instance&#10;     */&#10;    public static Object getIdValue(Object entity) {&#10;        try {&#10;            Field idField = getIdField(entity.getClass());&#10;            if (idField != null) {&#10;                idField.setAccessible(true);&#10;                return idField.get(entity);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Failed to get ID value from entity&quot;, e);&#10;        }&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Check if entity is new (ID is null or zero)&#10;     */&#10;    public static boolean isEntityNewById(Object entity) {&#10;        Object idValue = getIdValue(entity);&#10;        if (idValue == null) {&#10;            return true;&#10;        }&#10;        if (idValue instanceof Number) {&#10;            return ((Number) idValue).longValue() == 0;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    /**&#10;     * Get all fields with JPA annotations&#10;     */&#10;    public static List&lt;Field&gt; getJpaFields(Class&lt;?&gt; entityClass) {&#10;        return getEntityMetadata(entityClass).getJpaFields();&#10;    }&#10;&#10;    /**&#10;     * Get column name for field&#10;     */&#10;    public static String getColumnName(Field field) {&#10;        Column columnAnnotation = field.getAnnotation(Column.class);&#10;        if (columnAnnotation != null &amp;&amp; !columnAnnotation.name().isEmpty()) {&#10;            return columnAnnotation.name();&#10;        }&#10;        return field.getName();&#10;    }&#10;&#10;    /**&#10;     * Build entity metadata&#10;     */&#10;    private static EntityMetadata buildEntityMetadata(Class&lt;?&gt; entityClass) {&#10;        logger.debug(&quot;Building metadata for entity: {}&quot;, entityClass.getSimpleName());&#10;&#10;        EntityMetadata metadata = new EntityMetadata();&#10;        metadata.setEntityClass(entityClass);&#10;        metadata.setTableName(getTableName(entityClass));&#10;&#10;        List&lt;Field&gt; jpaFields = new ArrayList&lt;&gt;();&#10;        Field idField = null;&#10;&#10;        // Process all fields including inherited ones&#10;        Class&lt;?&gt; currentClass = entityClass;&#10;        while (currentClass != null &amp;&amp; !currentClass.equals(Object.class)) {&#10;            for (Field field : currentClass.getDeclaredFields()) {&#10;                if (hasJpaAnnotation(field)) {&#10;                    jpaFields.add(field);&#10;&#10;                    if (field.isAnnotationPresent(Id.class)) {&#10;                        idField = field;&#10;                    }&#10;                }&#10;            }&#10;            currentClass = currentClass.getSuperclass();&#10;        }&#10;&#10;        metadata.setJpaFields(jpaFields);&#10;        metadata.setIdField(idField);&#10;&#10;        return metadata;&#10;    }&#10;&#10;    /**&#10;     * Check if field has JPA annotations&#10;     */&#10;    private static boolean hasJpaAnnotation(Field field) {&#10;        return field.isAnnotationPresent(Id.class) ||&#10;               field.isAnnotationPresent(Column.class) ||&#10;               field.isAnnotationPresent(JoinColumn.class) ||&#10;               field.isAnnotationPresent(OneToOne.class) ||&#10;               field.isAnnotationPresent(OneToMany.class) ||&#10;               field.isAnnotationPresent(ManyToOne.class) ||&#10;               field.isAnnotationPresent(ManyToMany.class) ||&#10;               field.isAnnotationPresent(Embedded.class) ||&#10;               field.isAnnotationPresent(GeneratedValue.class);&#10;    }&#10;&#10;    /**&#10;     * Clear metadata cache&#10;     */&#10;    public static void clearCache() {&#10;        metadataCache.clear();&#10;        logger.debug(&quot;Metadata cache cleared&quot;);&#10;    }&#10;&#10;    /**&#10;     * Entity metadata holder class&#10;     */&#10;    public static class EntityMetadata {&#10;        private Class&lt;?&gt; entityClass;&#10;        private String tableName;&#10;        private Field idField;&#10;        private List&lt;Field&gt; jpaFields;&#10;&#10;        // Getters and setters&#10;        public Class&lt;?&gt; getEntityClass() { return entityClass; }&#10;        public void setEntityClass(Class&lt;?&gt; entityClass) { this.entityClass = entityClass; }&#10;&#10;        public String getTableName() { return tableName; }&#10;        public void setTableName(String tableName) { this.tableName = tableName; }&#10;&#10;        public Field getIdField() { return idField; }&#10;        public void setIdField(Field idField) { this.idField = idField; }&#10;&#10;        public List&lt;Field&gt; getJpaFields() { return jpaFields; }&#10;        public void setJpaFields(List&lt;Field&gt; jpaFields) { this.jpaFields = jpaFields; }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return &quot;EntityMetadata{&quot; +&#10;                    &quot;entityClass=&quot; + entityClass.getSimpleName() +&#10;                    &quot;, tableName='&quot; + tableName + '\'' +&#10;                    &quot;, idField=&quot; + (idField != null ? idField.getName() : &quot;null&quot;) +&#10;                    &quot;, jpaFieldsCount=&quot; + (jpaFields != null ? jpaFields.size() : 0) +&#10;                    '}';&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/TransactionManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/TransactionManager.java" />
              <option name="originalContent" value="package h2.orm.core;&#10;&#10;import jakarta.persistence.EntityManager;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;/**&#10; * Core transaction manager for H2-ORM&#10; * Handles transaction lifecycle and ensures proper rollback on errors&#10; */&#10;public class TransactionManager {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(TransactionManager.class);&#10;&#10;    /**&#10;     * Execute operation in transaction with automatic rollback on error&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(EntityManagerProvider.TransactionCallback&lt;T&gt; callback) {&#10;        return EntityManagerProvider.executeInTransaction(callback);&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, EntityManagerProvider.TransactionCallback&lt;T&gt; callback) {&#10;        return EntityManagerProvider.executeInTransaction(configName, callback);&#10;    }&#10;&#10;    /**&#10;     * Execute void operation in transaction&#10;     */&#10;    public static void executeInTransaction(VoidTransactionCallback callback) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            callback.execute(em);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Check if current thread has active transaction&#10;     */&#10;    public static boolean hasActiveTransaction() {&#10;        try {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            return em.getTransaction().isActive();&#10;        } catch (Exception e) {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Begin transaction manually (advanced usage)&#10;     */&#10;    public static void beginTransaction() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        if (!em.getTransaction().isActive()) {&#10;            em.getTransaction().begin();&#10;            logger.debug(&quot;Transaction started manually&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Commit transaction manually (advanced usage)&#10;     */&#10;    public static void commitTransaction() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().commit();&#10;                logger.debug(&quot;Transaction committed manually&quot;);&#10;            }&#10;        }&#10;        catch (Exception e) {&#10;            logger.error(&quot;Failed to commit transaction&quot;, e);&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;                logger.debug(&quot;Transaction rolled back due to commit failure&quot;);&#10;            }&#10;            throw e; // rethrow to propagate the error&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Rollback transaction manually (advanced usage)&#10;     */&#10;    public static void rollbackTransaction() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;                logger.debug(&quot;Transaction rolled back manually&quot;);&#10;            }&#10;        }&#10;        catch (Exception e) {&#10;            logger.error(&quot;Failed to rollback transaction&quot;, e);&#10;            throw e; // rethrow to propagate the error&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface VoidTransactionCallback {&#10;        void execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.core;&#13;&#10;&#13;&#10;import jakarta.persistence.EntityManager;&#13;&#10;import org.slf4j.Logger;&#13;&#10;import org.slf4j.LoggerFactory;&#13;&#10;&#13;&#10;/**&#13;&#10; * Core transaction manager for H2-ORM&#13;&#10; * Handles transaction lifecycle and ensures proper rollback on errors&#13;&#10; */&#13;&#10;public class TransactionManager {&#13;&#10;&#13;&#10;    private static final Logger logger = LoggerFactory.getLogger(TransactionManager.class);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Execute operation in transaction with automatic rollback on error&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; T executeInTransaction(EntityManagerProvider.TransactionCallback&lt;T&gt; callback) {&#13;&#10;        return EntityManagerProvider.executeInTransaction(callback);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Execute operation in transaction with named configuration&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; T executeInTransaction(String configName, EntityManagerProvider.TransactionCallback&lt;T&gt; callback) {&#13;&#10;        return EntityManagerProvider.executeInTransaction(configName, callback);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Execute void operation in transaction&#13;&#10;     */&#13;&#10;    public static void executeVoidInTransaction(VoidTransactionCallback callback) {&#13;&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#13;&#10;            callback.execute(em);&#13;&#10;            return null;&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Execute void operation in transaction with named configuration&#13;&#10;     */&#13;&#10;    public static void executeVoidInTransaction(String configName, VoidTransactionCallback callback) {&#13;&#10;        EntityManagerProvider.executeInTransaction(configName, em -&gt; {&#13;&#10;            callback.execute(em);&#13;&#10;            return null;&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Check if current thread has active transaction&#13;&#10;     */&#13;&#10;    public static boolean hasActiveTransaction() {&#13;&#10;        try {&#13;&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#13;&#10;            return em.getTransaction().isActive();&#13;&#10;        } catch (Exception e) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Begin transaction manually (advanced usage)&#13;&#10;     */&#13;&#10;    public static void beginTransaction() {&#13;&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#13;&#10;        if (!em.getTransaction().isActive()) {&#13;&#10;            em.getTransaction().begin();&#13;&#10;            logger.debug(&quot;Transaction started manually&quot;);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Commit transaction manually (advanced usage)&#13;&#10;     */&#13;&#10;    public static void commitTransaction() {&#13;&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#13;&#10;        try {&#13;&#10;            if (em.getTransaction().isActive()) {&#13;&#10;                em.getTransaction().commit();&#13;&#10;                logger.debug(&quot;Transaction committed manually&quot;);&#13;&#10;            }&#13;&#10;        }&#13;&#10;        catch (Exception e) {&#13;&#10;            logger.error(&quot;Failed to commit transaction&quot;, e);&#13;&#10;            if (em.getTransaction().isActive()) {&#13;&#10;                em.getTransaction().rollback();&#13;&#10;                logger.debug(&quot;Transaction rolled back due to commit failure&quot;);&#13;&#10;            }&#13;&#10;            throw e; // rethrow to propagate the error&#13;&#10;        } finally {&#13;&#10;            EntityManagerProvider.closeEntityManager();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Rollback transaction manually (advanced usage)&#13;&#10;     */&#13;&#10;    public static void rollbackTransaction() {&#13;&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#13;&#10;        try {&#13;&#10;            if (em.getTransaction().isActive()) {&#13;&#10;                em.getTransaction().rollback();&#13;&#10;                logger.debug(&quot;Transaction rolled back manually&quot;);&#13;&#10;            }&#13;&#10;        }&#13;&#10;        catch (Exception e) {&#13;&#10;            logger.error(&quot;Failed to rollback transaction&quot;, e);&#13;&#10;            throw e; // rethrow to propagate the error&#13;&#10;        } finally {&#13;&#10;            EntityManagerProvider.closeEntityManager();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @FunctionalInterface&#13;&#10;    public interface VoidTransactionCallback {&#13;&#10;        void execute(EntityManager entityManager) throws Exception;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/service/TableManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/service/TableManager.java" />
              <option name="originalContent" value="package h2.orm.core.service;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import h2.orm.core.MetadataManager;&#10;import h2.orm.core.TransactionManager;&#10;import h2.orm.exception.ExceptionHandler;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.Query;&#10;import jakarta.persistence.metamodel.EntityType;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Professional table management utility for H2-ORM&#10; * Provides comprehensive database schema operations&#10; */&#10;public class TableManager {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(TableManager.class);&#10;&#10;    /**&#10;     * Create tables for all registered entities&#10;     */&#10;    public static void createAll() {&#10;        ExceptionHandler.safeExecute(&quot;create all tables&quot;, () -&gt; {&#10;            Set&lt;EntityType&lt;?&gt;&gt; entityTypes = MetadataManager.getAllEntityTypes();&#10;            logger.info(&quot;Creating tables for {} entities&quot;, entityTypes.size());&#10;&#10;            for (EntityType&lt;?&gt; entityType : entityTypes) {&#10;                create(entityType.getJavaType());&#10;            }&#10;&#10;            logger.info(&quot;Successfully created all tables&quot;);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create table for specific entity&#10;     */&#10;    public static void create(Class&lt;?&gt; entityClass) {&#10;        ExceptionHandler.safeExecute(&quot;create table for &quot; + entityClass.getSimpleName(), () -&gt; {&#10;            String tableName = MetadataManager.getTableName(entityClass);&#10;&#10;            if (exists(tableName)) {&#10;                logger.info(&quot;Table {} already exists&quot;, tableName);&#10;                return;&#10;            }&#10;&#10;            String createTableSql = generateCreateTableSql(entityClass);&#10;            executeDDL(createTableSql);&#10;&#10;            logger.info(&quot;Created table: {}&quot;, tableName);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Drop table for specific entity&#10;     */&#10;    public static void drop(Class&lt;?&gt; entityClass) {&#10;        ExceptionHandler.safeExecute(&quot;drop table for &quot; + entityClass.getSimpleName(), () -&gt; {&#10;            String tableName = MetadataManager.getTableName(entityClass);&#10;&#10;            if (!exists(tableName)) {&#10;                logger.warn(&quot;Table {} does not exist&quot;, tableName);&#10;                return;&#10;            }&#10;&#10;            String dropTableSql = &quot;DROP TABLE IF EXISTS &quot; + tableName;&#10;            executeDDL(dropTableSql);&#10;&#10;            logger.info(&quot;Dropped table: {}&quot;, tableName);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Drop all tables&#10;     */&#10;    public static void dropAll() {&#10;        ExceptionHandler.safeExecute(&quot;drop all tables&quot;, () -&gt; {&#10;            Set&lt;EntityType&lt;?&gt;&gt; entityTypes = MetadataManager.getAllEntityTypes();&#10;            logger.info(&quot;Dropping tables for {} entities&quot;, entityTypes.size());&#10;&#10;            // Drop in reverse order to handle foreign key constraints&#10;            List&lt;EntityType&lt;?&gt;&gt; entityList = new ArrayList&lt;&gt;(entityTypes);&#10;            Collections.reverse(entityList);&#10;&#10;            for (EntityType&lt;?&gt; entityType : entityList) {&#10;                drop(entityType.getJavaType());&#10;            }&#10;&#10;            logger.info(&quot;Successfully dropped all tables&quot;);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Truncate table (remove all data but keep structure)&#10;     */&#10;    public static void truncate(Class&lt;?&gt; entityClass) {&#10;        ExceptionHandler.safeExecute(&quot;truncate table for &quot; + entityClass.getSimpleName(), () -&gt; {&#10;            String tableName = MetadataManager.getTableName(entityClass);&#10;&#10;            if (!exists(tableName)) {&#10;                logger.warn(&quot;Table {} does not exist&quot;, tableName);&#10;                return;&#10;            }&#10;&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                // Use DELETE instead of TRUNCATE for better compatibility&#10;                String deleteSql = &quot;DELETE FROM &quot; + tableName;&#10;                Query query = em.createNativeQuery(deleteSql);&#10;                int deletedRows = query.executeUpdate();&#10;&#10;                logger.info(&quot;Truncated table {}: {} rows deleted&quot;, tableName, deletedRows);&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Truncate all tables&#10;     */&#10;    public static void truncateAll() {&#10;        ExceptionHandler.safeExecute(&quot;truncate all tables&quot;, () -&gt; {&#10;            Set&lt;EntityType&lt;?&gt;&gt; entityTypes = MetadataManager.getAllEntityTypes();&#10;            logger.info(&quot;Truncating tables for {} entities&quot;, entityTypes.size());&#10;&#10;            for (EntityType&lt;?&gt; entityType : entityTypes) {&#10;                truncate(entityType.getJavaType());&#10;            }&#10;&#10;            logger.info(&quot;Successfully truncated all tables&quot;);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Check if table exists&#10;     */&#10;    public static boolean exists(String tableName) {&#10;        return ExceptionHandler.safeExecute(&quot;check table exists: &quot; + tableName, () -&gt; {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            try {&#10;                String sql = &quot;SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = UPPER(?)&quot;;&#10;                Query query = em.createNativeQuery(sql);&#10;                query.setParameter(1, tableName);&#10;&#10;                Number count = (Number) query.getSingleResult();&#10;                return count.intValue() &gt; 0;&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get all table names&#10;     */&#10;    public static List&lt;String&gt; getAllTableNames() {&#10;        return ExceptionHandler.safeExecute(&quot;get all table names&quot;, () -&gt; {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            try {&#10;                String sql = &quot;SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'PUBLIC'&quot;;&#10;                Query query = em.createNativeQuery(sql);&#10;&#10;                @SuppressWarnings(&quot;unchecked&quot;)&#10;                List&lt;String&gt; tableNames = query.getResultList();&#10;                return tableNames;&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get table row count&#10;     */&#10;    public static long getByRowCount(Class&lt;?&gt; entityClass) {&#10;        return ExceptionHandler.safeExecute(&quot;get table row count for &quot; + entityClass.getSimpleName(), () -&gt; {&#10;            String tableName = MetadataManager.getTableName(entityClass);&#10;&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            try {&#10;                String sql = &quot;SELECT COUNT(*) FROM &quot; + tableName;&#10;                Query query = em.createNativeQuery(sql);&#10;&#10;                Number count = (Number) query.getSingleResult();&#10;                return count.longValue();&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get table information&#10;     */&#10;    public static TableInfo getInfo(Class&lt;?&gt; entityClass) {&#10;        return ExceptionHandler.safeExecute(&quot;get table info for &quot; + entityClass.getSimpleName(), () -&gt; {&#10;            String tableName = MetadataManager.getTableName(entityClass);&#10;&#10;            TableInfo info = new TableInfo();&#10;            info.setTableName(tableName);&#10;            info.setEntityClass(entityClass);&#10;            info.setExists(exists(tableName));&#10;&#10;            if (info.isExists()) {&#10;                info.setRowCount(getByRowCount(entityClass));&#10;                info.setColumns(getTableColumns(tableName));&#10;            }&#10;&#10;            return info;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get all table information&#10;     */&#10;    public static List&lt;TableInfo&gt; getAllTableInfo() {&#10;        return ExceptionHandler.safeExecute(&quot;get all table info&quot;, () -&gt; {&#10;            Set&lt;EntityType&lt;?&gt;&gt; entityTypes = MetadataManager.getAllEntityTypes();&#10;&#10;            return entityTypes.stream()&#10;                    .map(entityType -&gt; getInfo(entityType.getJavaType()))&#10;                    .collect(Collectors.toList());&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Reset auto-increment counter for table&#10;     */&#10;    public static void resetAutoIncrement(Class&lt;?&gt; entityClass) {&#10;        ExceptionHandler.safeExecute(&quot;reset auto increment for &quot; + entityClass.getSimpleName(), () -&gt; {&#10;            String tableName = MetadataManager.getTableName(entityClass);&#10;&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                // H2 specific syntax for resetting auto increment&#10;                String sql = &quot;ALTER TABLE &quot; + tableName + &quot; ALTER COLUMN ID RESTART WITH 1&quot;;&#10;                try {&#10;                    Query query = em.createNativeQuery(sql);&#10;                    query.executeUpdate();&#10;                    logger.info(&quot;Reset auto increment for table: {}&quot;, tableName);&#10;                } catch (Exception e) {&#10;                    logger.warn(&quot;Could not reset auto increment for table {}: {}&quot;, tableName, e.getMessage());&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    // Private helper methods&#10;&#10;    private static void executeDDL(String sql) {&#10;        TransactionManager.executeInTransaction(em -&gt; {&#10;            Query query = em.createNativeQuery(sql);&#10;            query.executeUpdate();&#10;            return null;&#10;        });&#10;    }&#10;&#10;    private static String generateCreateTableSql(Class&lt;?&gt; entityClass) {&#10;        // This is a simplified version - in a real implementation,&#10;        // you would analyze the entity annotations to generate proper DDL&#10;        String tableName = MetadataManager.getTableName(entityClass);&#10;        return &quot;CREATE TABLE IF NOT EXISTS &quot; + tableName + &quot; (id BIGINT PRIMARY KEY AUTO_INCREMENT)&quot;;&#10;    }&#10;&#10;    private static List&lt;String&gt; getTableColumns(String tableName) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            String sql = &quot;SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = UPPER(?) ORDER BY ORDINAL_POSITION&quot;;&#10;            Query query = em.createNativeQuery(sql);&#10;            query.setParameter(1, tableName);&#10;&#10;            @SuppressWarnings(&quot;unchecked&quot;)&#10;            List&lt;String&gt; columns = query.getResultList();&#10;            return columns;&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Table information holder class&#10;     */&#10;    public static class TableInfo {&#10;        private String tableName;&#10;        private Class&lt;?&gt; entityClass;&#10;        private boolean exists;&#10;        private long rowCount;&#10;        private List&lt;String&gt; columns;&#10;&#10;        // Getters and setters&#10;        public String getTableName() { return tableName; }&#10;        public void setTableName(String tableName) { this.tableName = tableName; }&#10;&#10;        public Class&lt;?&gt; getEntityClass() { return entityClass; }&#10;        public void setEntityClass(Class&lt;?&gt; entityClass) { this.entityClass = entityClass; }&#10;&#10;        public boolean isExists() { return exists; }&#10;        public void setExists(boolean exists) { this.exists = exists; }&#10;&#10;        public long getRowCount() { return rowCount; }&#10;        public void setRowCount(long rowCount) { this.rowCount = rowCount; }&#10;&#10;        public List&lt;String&gt; getColumns() { return columns; }&#10;        public void setColumns(List&lt;String&gt; columns) { this.columns = columns; }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return &quot;TableInfo{&quot; +&#10;                    &quot;tableName='&quot; + tableName + '\'' +&#10;                    &quot;, entityClass=&quot; + (entityClass != null ? entityClass.getSimpleName() : &quot;null&quot;) +&#10;                    &quot;, exists=&quot; + exists +&#10;                    &quot;, rowCount=&quot; + rowCount +&#10;                    &quot;, columns=&quot; + (columns != null ? columns.size() : 0) +&#10;                    '}';&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.core.service;&#13;&#10;&#13;&#10;import h2.orm.core.EntityManagerProvider;&#13;&#10;import h2.orm.core.MetadataManager;&#13;&#10;import h2.orm.core.TransactionManager;&#13;&#10;import h2.orm.exception.ExceptionHandler;&#13;&#10;import jakarta.persistence.EntityManager;&#13;&#10;import jakarta.persistence.Query;&#13;&#10;import jakarta.persistence.metamodel.EntityType;&#13;&#10;import org.slf4j.Logger;&#13;&#10;import org.slf4j.LoggerFactory;&#13;&#10;&#13;&#10;import java.util.*;&#13;&#10;import java.util.stream.Collectors;&#13;&#10;&#13;&#10;/**&#13;&#10; * Professional table management utility for H2-ORM&#13;&#10; * Provides comprehensive database schema operations&#13;&#10; */&#13;&#10;public class TableManager {&#13;&#10;&#13;&#10;    private static final Logger logger = LoggerFactory.getLogger(TableManager.class);&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Private constructor to prevent instantiation&#13;&#10;     */&#13;&#10;    private TableManager() {&#13;&#10;        // Utility class - prevent instantiation&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create tables for all registered entities&#13;&#10;     */&#13;&#10;    public static void createAll() {&#13;&#10;        ExceptionHandler.safeExecute(&quot;create all tables&quot;, () -&gt; {&#13;&#10;            Set&lt;EntityType&lt;?&gt;&gt; entityTypes = MetadataManager.getAllEntityTypes();&#13;&#10;            logger.info(&quot;Creating tables for {} entities&quot;, entityTypes.size());&#13;&#10;&#13;&#10;            for (EntityType&lt;?&gt; entityType : entityTypes) {&#13;&#10;                create(entityType.getJavaType());&#13;&#10;            }&#13;&#10;&#13;&#10;            logger.info(&quot;Successfully created all tables&quot;);&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create table for specific entity&#13;&#10;     */&#13;&#10;    public static void create(Class&lt;?&gt; entityClass) {&#13;&#10;        ExceptionHandler.safeExecute(&quot;create table for &quot; + entityClass.getSimpleName(), () -&gt; {&#13;&#10;            String tableName = MetadataManager.getTableName(entityClass);&#13;&#10;&#13;&#10;            if (exists(tableName)) {&#13;&#10;                logger.info(&quot;Table {} already exists&quot;, tableName);&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            String createTableSql = generateCreateTableSql(entityClass);&#13;&#10;            executeDDL(createTableSql);&#13;&#10;&#13;&#10;            logger.info(&quot;Created table: {}&quot;, tableName);&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Drop table for specific entity&#13;&#10;     */&#13;&#10;    public static void drop(Class&lt;?&gt; entityClass) {&#13;&#10;        ExceptionHandler.safeExecute(&quot;drop table for &quot; + entityClass.getSimpleName(), () -&gt; {&#13;&#10;            String tableName = MetadataManager.getTableName(entityClass);&#13;&#10;&#13;&#10;            if (!exists(tableName)) {&#13;&#10;                logger.warn(&quot;Table {} does not exist&quot;, tableName);&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            String dropTableSql = &quot;DROP TABLE IF EXISTS &quot; + tableName;&#13;&#10;            executeDDL(dropTableSql);&#13;&#10;&#13;&#10;            logger.info(&quot;Dropped table: {}&quot;, tableName);&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Drop all tables&#13;&#10;     */&#13;&#10;    public static void dropAll() {&#13;&#10;        ExceptionHandler.safeExecute(&quot;drop all tables&quot;, () -&gt; {&#13;&#10;            Set&lt;EntityType&lt;?&gt;&gt; entityTypes = MetadataManager.getAllEntityTypes();&#13;&#10;            logger.info(&quot;Dropping tables for {} entities&quot;, entityTypes.size());&#13;&#10;&#13;&#10;            // Drop in reverse order to handle foreign key constraints&#13;&#10;            List&lt;EntityType&lt;?&gt;&gt; entityList = new ArrayList&lt;&gt;(entityTypes);&#13;&#10;            Collections.reverse(entityList);&#13;&#10;&#13;&#10;            for (EntityType&lt;?&gt; entityType : entityList) {&#13;&#10;                drop(entityType.getJavaType());&#13;&#10;            }&#13;&#10;&#13;&#10;            logger.info(&quot;Successfully dropped all tables&quot;);&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Truncate table (remove all data but keep structure)&#13;&#10;     */&#13;&#10;    public static void truncate(Class&lt;?&gt; entityClass) {&#13;&#10;        ExceptionHandler.safeExecute(&quot;truncate table for &quot; + entityClass.getSimpleName(), () -&gt; {&#13;&#10;            String tableName = MetadataManager.getTableName(entityClass);&#13;&#10;&#13;&#10;            if (!exists(tableName)) {&#13;&#10;                logger.warn(&quot;Table {} does not exist&quot;, tableName);&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            TransactionManager.executeInTransaction(em -&gt; {&#13;&#10;                // Use DELETE instead of TRUNCATE for better compatibility&#13;&#10;                String deleteSql = &quot;DELETE FROM &quot; + tableName;&#13;&#10;                Query query = em.createNativeQuery(deleteSql);&#13;&#10;                int deletedRows = query.executeUpdate();&#13;&#10;&#13;&#10;                logger.info(&quot;Truncated table {}: {} rows deleted&quot;, tableName, deletedRows);&#13;&#10;                return null;&#13;&#10;            });&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Truncate all tables&#13;&#10;     */&#13;&#10;    public static void truncateAll() {&#13;&#10;        ExceptionHandler.safeExecute(&quot;truncate all tables&quot;, () -&gt; {&#13;&#10;            Set&lt;EntityType&lt;?&gt;&gt; entityTypes = MetadataManager.getAllEntityTypes();&#13;&#10;            logger.info(&quot;Truncating tables for {} entities&quot;, entityTypes.size());&#13;&#10;&#13;&#10;            for (EntityType&lt;?&gt; entityType : entityTypes) {&#13;&#10;                truncate(entityType.getJavaType());&#13;&#10;            }&#13;&#10;&#13;&#10;            logger.info(&quot;Successfully truncated all tables&quot;);&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Check if table exists&#13;&#10;     */&#13;&#10;    public static boolean exists(String tableName) {&#13;&#10;        return ExceptionHandler.safeExecute(&quot;check table exists: &quot; + tableName, () -&gt; {&#13;&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#13;&#10;            try {&#13;&#10;                String sql = &quot;SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = UPPER(?)&quot;;&#13;&#10;                Query query = em.createNativeQuery(sql);&#13;&#10;                query.setParameter(1, tableName);&#13;&#10;&#13;&#10;                Number count = (Number) query.getSingleResult();&#13;&#10;                return count.intValue() &gt; 0;&#13;&#10;            } finally {&#13;&#10;                EntityManagerProvider.closeEntityManager();&#13;&#10;            }&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get all table names&#13;&#10;     */&#13;&#10;    public static List&lt;String&gt; getAllTableNames() {&#13;&#10;        return ExceptionHandler.safeExecute(&quot;get all table names&quot;, () -&gt; {&#13;&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#13;&#10;            try {&#13;&#10;                String sql = &quot;SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'PUBLIC'&quot;;&#13;&#10;                Query query = em.createNativeQuery(sql);&#13;&#10;&#13;&#10;                @SuppressWarnings(&quot;unchecked&quot;)&#13;&#10;                List&lt;String&gt; tableNames = query.getResultList();&#13;&#10;                return tableNames;&#13;&#10;            } finally {&#13;&#10;                EntityManagerProvider.closeEntityManager();&#13;&#10;            }&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get table row count&#13;&#10;     */&#13;&#10;    public static long getByRowCount(Class&lt;?&gt; entityClass) {&#13;&#10;        return ExceptionHandler.safeExecute(&quot;get table row count for &quot; + entityClass.getSimpleName(), () -&gt; {&#13;&#10;            String tableName = MetadataManager.getTableName(entityClass);&#13;&#10;&#13;&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#13;&#10;            try {&#13;&#10;                String sql = &quot;SELECT COUNT(*) FROM &quot; + tableName;&#13;&#10;                Query query = em.createNativeQuery(sql);&#13;&#10;&#13;&#10;                Number count = (Number) query.getSingleResult();&#13;&#10;                return count.longValue();&#13;&#10;            } finally {&#13;&#10;                EntityManagerProvider.closeEntityManager();&#13;&#10;            }&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get table information&#13;&#10;     */&#13;&#10;    public static TableInfo getInfo(Class&lt;?&gt; entityClass) {&#13;&#10;        return ExceptionHandler.safeExecute(&quot;get table info for &quot; + entityClass.getSimpleName(), () -&gt; {&#13;&#10;            String tableName = MetadataManager.getTableName(entityClass);&#13;&#10;&#13;&#10;            TableInfo info = new TableInfo();&#13;&#10;            info.setTableName(tableName);&#13;&#10;            info.setEntityClass(entityClass);&#13;&#10;            info.setExists(exists(tableName));&#13;&#10;&#13;&#10;            if (info.isExists()) {&#13;&#10;                info.setRowCount(getByRowCount(entityClass));&#13;&#10;                info.setColumns(getTableColumns(tableName));&#13;&#10;            }&#13;&#10;&#13;&#10;            return info;&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get all table information&#13;&#10;     */&#13;&#10;    public static List&lt;TableInfo&gt; getAllTableInfo() {&#13;&#10;        return ExceptionHandler.safeExecute(&quot;get all table info&quot;, () -&gt; {&#13;&#10;            Set&lt;EntityType&lt;?&gt;&gt; entityTypes = MetadataManager.getAllEntityTypes();&#13;&#10;&#13;&#10;            return entityTypes.stream()&#13;&#10;                    .map(entityType -&gt; getInfo(entityType.getJavaType()))&#13;&#10;                    .collect(Collectors.toList());&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Reset auto-increment counter for table&#13;&#10;     */&#13;&#10;    public static void resetAutoIncrement(Class&lt;?&gt; entityClass) {&#13;&#10;        ExceptionHandler.safeExecute(&quot;reset auto increment for &quot; + entityClass.getSimpleName(), () -&gt; {&#13;&#10;            String tableName = MetadataManager.getTableName(entityClass);&#13;&#10;&#13;&#10;            TransactionManager.executeInTransaction(em -&gt; {&#13;&#10;                // H2 specific syntax for resetting auto increment&#13;&#10;                String sql = &quot;ALTER TABLE &quot; + tableName + &quot; ALTER COLUMN ID RESTART WITH 1&quot;;&#13;&#10;                try {&#13;&#10;                    Query query = em.createNativeQuery(sql);&#13;&#10;                    query.executeUpdate();&#13;&#10;                    logger.info(&quot;Reset auto increment for table: {}&quot;, tableName);&#13;&#10;                } catch (Exception e) {&#13;&#10;                    logger.warn(&quot;Could not reset auto increment for table {}: {}&quot;, tableName, e.getMessage());&#13;&#10;                }&#13;&#10;                return null;&#13;&#10;            });&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    // Private helper methods&#13;&#10;&#13;&#10;    private static void executeDDL(String sql) {&#13;&#10;        TransactionManager.executeInTransaction(em -&gt; {&#13;&#10;            Query query = em.createNativeQuery(sql);&#13;&#10;            query.executeUpdate();&#13;&#10;            return null;&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    private static String generateCreateTableSql(Class&lt;?&gt; entityClass) {&#13;&#10;        // This is a simplified version - in a real implementation,&#13;&#10;        // you would analyze the entity annotations to generate proper DDL&#13;&#10;        String tableName = MetadataManager.getTableName(entityClass);&#13;&#10;        return &quot;CREATE TABLE IF NOT EXISTS &quot; + tableName + &quot; (id BIGINT PRIMARY KEY AUTO_INCREMENT)&quot;;&#13;&#10;    }&#13;&#10;&#13;&#10;    private static List&lt;String&gt; getTableColumns(String tableName) {&#13;&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#13;&#10;        try {&#13;&#10;            String sql = &quot;SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = UPPER(?) ORDER BY ORDINAL_POSITION&quot;;&#13;&#10;            Query query = em.createNativeQuery(sql);&#13;&#10;            query.setParameter(1, tableName);&#13;&#10;&#13;&#10;            @SuppressWarnings(&quot;unchecked&quot;)&#13;&#10;            List&lt;String&gt; columns = query.getResultList();&#13;&#10;            return columns;&#13;&#10;        } finally {&#13;&#10;            EntityManagerProvider.closeEntityManager();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Table information holder class&#13;&#10;     */&#13;&#10;    public static class TableInfo {&#13;&#10;        private String tableName;&#13;&#10;        private Class&lt;?&gt; entityClass;&#13;&#10;        private boolean exists;&#13;&#10;        private long rowCount;&#13;&#10;        private List&lt;String&gt; columns;&#13;&#10;&#13;&#10;        // Getters and setters&#13;&#10;        public String getTableName() { return tableName; }&#13;&#10;        public void setTableName(String tableName) { this.tableName = tableName; }&#13;&#10;&#13;&#10;        public Class&lt;?&gt; getEntityClass() { return entityClass; }&#13;&#10;        public void setEntityClass(Class&lt;?&gt; entityClass) { this.entityClass = entityClass; }&#13;&#10;&#13;&#10;        public boolean isExists() { return exists; }&#13;&#10;        public void setExists(boolean exists) { this.exists = exists; }&#13;&#10;&#13;&#10;        public long getRowCount() { return rowCount; }&#13;&#10;        public void setRowCount(long rowCount) { this.rowCount = rowCount; }&#13;&#10;&#13;&#10;        public List&lt;String&gt; getColumns() { return columns; }&#13;&#10;        public void setColumns(List&lt;String&gt; columns) { this.columns = columns; }&#13;&#10;&#13;&#10;        @Override&#13;&#10;        public String toString() {&#13;&#10;            return &quot;TableInfo{&quot; +&#13;&#10;                    &quot;tableName='&quot; + tableName + '\'' +&#13;&#10;                    &quot;, entityClass=&quot; + (entityClass != null ? entityClass.getSimpleName() : &quot;null&quot;) +&#13;&#10;                    &quot;, exists=&quot; + exists +&#13;&#10;                    &quot;, rowCount=&quot; + rowCount +&#13;&#10;                    &quot;, columns=&quot; + (columns != null ? columns.size() : 0) +&#13;&#10;                    '}';&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/example/Order.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/example/Order.java" />
              <option name="updatedContent" value="package h2.orm.example;&#10;&#10;import jakarta.persistence.*;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Order entity with status field for demonstrating field-based queries&#10; */&#10;@Entity&#10;@Table(name = &quot;orders&quot;)&#10;public class Order {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @Column(name = &quot;order_number&quot;, unique = true, nullable = false)&#10;    private String orderNumber;&#10;&#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;customer_id&quot;)&#10;    private User customer;&#10;&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;status&quot;, nullable = false)&#10;    private Status status;&#10;&#10;    @Column(name = &quot;amount&quot;, nullable = false)&#10;    private Double amount;&#10;&#10;    @Column(name = &quot;created_date&quot;)&#10;    private LocalDateTime createdDate;&#10;&#10;    @Column(name = &quot;processed_date&quot;)&#10;    private LocalDateTime processedDate;&#10;&#10;    // Constructors&#10;    public Order() {&#10;        this.createdDate = LocalDateTime.now();&#10;    }&#10;&#10;    public Order(String orderNumber, User customer, Status status, Double amount) {&#10;        this();&#10;        this.orderNumber = orderNumber;&#10;        this.customer = customer;&#10;        this.status = status;&#10;        this.amount = amount;&#10;        &#10;        if (status == Status.PROCESSED) {&#10;            this.processedDate = LocalDateTime.now();&#10;        }&#10;    }&#10;&#10;    // Status enum&#10;    public enum Status {&#10;        NEW,&#10;        PROCESSED, &#10;        SHIPPED,&#10;        DELIVERED,&#10;        CANCELLED,&#10;        PENDING&#10;    }&#10;&#10;    // Getters and Setters&#10;    public Long getId() {&#10;        return id;&#10;    }&#10;&#10;    public void setId(Long id) {&#10;        this.id = id;&#10;    }&#10;&#10;    public String getOrderNumber() {&#10;        return orderNumber;&#10;    }&#10;&#10;    public void setOrderNumber(String orderNumber) {&#10;        this.orderNumber = orderNumber;&#10;    }&#10;&#10;    public User getCustomer() {&#10;        return customer;&#10;    }&#10;&#10;    public void setCustomer(User customer) {&#10;        this.customer = customer;&#10;    }&#10;&#10;    public Status getStatus() {&#10;        return status;&#10;    }&#10;&#10;    public void setStatus(Status status) {&#10;        this.status = status;&#10;        if (status == Status.PROCESSED &amp;&amp; this.processedDate == null) {&#10;            this.processedDate = LocalDateTime.now();&#10;        }&#10;    }&#10;&#10;    public Double getAmount() {&#10;        return amount;&#10;    }&#10;&#10;    public void setAmount(Double amount) {&#10;        this.amount = amount;&#10;    }&#10;&#10;    public LocalDateTime getCreatedDate() {&#10;        return createdDate;&#10;    }&#10;&#10;    public void setCreatedDate(LocalDateTime createdDate) {&#10;        this.createdDate = createdDate;&#10;    }&#10;&#10;    public LocalDateTime getProcessedDate() {&#10;        return processedDate;&#10;    }&#10;&#10;    public void setProcessedDate(LocalDateTime processedDate) {&#10;        this.processedDate = processedDate;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Order{&quot; +&#10;                &quot;id=&quot; + id +&#10;                &quot;, orderNumber='&quot; + orderNumber + '\'' +&#10;                &quot;, status=&quot; + status +&#10;                &quot;, amount=&quot; + amount +&#10;                &quot;, createdDate=&quot; + createdDate +&#10;                '}';&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/H2OrmExceptions.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/H2OrmExceptions.java" />
              <option name="updatedContent" value="package h2.orm.exception;&#10;&#10;/**&#10; * Exception thrown when database is not initialized&#10; */&#10;public class DatabaseNotInitializedException extends H2OrmException {&#10;    &#10;    public DatabaseNotInitializedException() {&#10;        super(&#10;            &quot;Database not initialized&quot;,&#10;            &quot;The H2-ORM database connection has not been initialized yet.&quot;,&#10;            &quot;Call EntityManagerProvider.initialize() before using repositories.&quot;&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when transaction is required but not active&#10; */&#10;class TransactionRequiredException extends H2OrmException {&#10;    &#10;    public TransactionRequiredException(String operation) {&#10;        super(&#10;            &quot;Transaction required for operation: &quot; + operation,&#10;            &quot;The operation '&quot; + operation + &quot;' requires an active transaction.&quot;,&#10;            &quot;This operation will be automatically wrapped in a transaction.&quot;&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when entity operation fails&#10; */&#10;class EntityOperationException extends H2OrmException {&#10;    &#10;    public EntityOperationException(String operation, Throwable cause) {&#10;        super(&#10;            &quot;Entity operation failed: &quot; + operation,&#10;            &quot;Failed to &quot; + operation.toLowerCase() + &quot; entity.&quot;,&#10;            &quot;Check if the entity is valid and database connection is working.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when unique constraint is violated&#10; */&#10;class UniqueConstraintException extends H2OrmException {&#10;    &#10;    public UniqueConstraintException(String field, Object value, Throwable cause) {&#10;        super(&#10;            &quot;Unique constraint violation&quot;,&#10;            &quot;A record with &quot; + field + &quot; = '&quot; + value + &quot;' already exists.&quot;,&#10;            &quot;Use a different value for &quot; + field + &quot; or update the existing record.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when configuration is invalid&#10; */&#10;class ConfigurationException extends H2OrmException {&#10;    &#10;    public ConfigurationException(String message, String suggestion) {&#10;        super(&#10;            &quot;Configuration error&quot;,&#10;            message,&#10;            suggestion&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when repository operation fails&#10; */&#10;class RepositoryException extends H2OrmException {&#10;    &#10;    public RepositoryException(String operation, Throwable cause) {&#10;        super(&#10;            &quot;Repository operation failed: &quot; + operation,&#10;            &quot;Failed to execute repository operation: &quot; + operation,&#10;            &quot;Check your entity configuration and database connection.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/AbstractRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/AbstractRepository.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import h2.orm.core.MetadataManager;&#10;import h2.orm.core.TransactionManager;&#10;import h2.orm.exception.ExceptionHandler;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.lang.reflect.ParameterizedType;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Abstract JPA Repository implementation similar to Spring Data JPA&#10; * Provides automatic implementation of all repository methods with comprehensive exception handling&#10; * Now uses core classes for better performance and reliability&#10; */&#10;public abstract class AbstractRepository&lt;T, ID extends Serializable&gt; implements JpaRepository&lt;T, ID&gt; {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(AbstractRepository.class);&#10;&#10;    protected final Class&lt;T&gt; entityClass;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public AbstractRepository() {&#10;        this.entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass().getGenericSuperclass())&#10;                .getActualTypeArguments()[0];&#10;    }&#10;&#10;    protected AbstractRepository(Class&lt;T&gt; entityClass) {&#10;        this.entityClass = entityClass;&#10;    }&#10;&#10;    protected abstract EntityManager getEntityManager();&#10;&#10;    @Override&#10;    public T save(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                // Use MetadataManager for entity state detection&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    return entity;&#10;                } else {&#10;                    return em.merge(entity);&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                int batchSize = 20;&#10;                int count = 0;&#10;&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;&#10;                    if (++count % batchSize == 0) {&#10;                        em.flush();&#10;                        em.clear();&#10;                    }&#10;                }&#10;&#10;                em.flush(); // Final flush&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;T&gt; findById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;find entity by ID&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                T entity = em.find(entityClass, id);&#10;                return Optional.ofNullable(entity);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public boolean existsById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;check entity exists&quot;, () -&gt; {&#10;            return findById(id).isPresent();&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAll() {&#10;        return ExceptionHandler.safeExecute(&quot;find all entities&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                CriteriaBuilder cb = em.getCriteriaBuilder();&#10;                CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;                Root&lt;T&gt; root = query.from(entityClass);&#10;                query.select(root);&#10;&#10;                TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;                return typedQuery.getResultList();&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities by IDs&quot;, () -&gt; {&#10;            List&lt;T&gt; result = new ArrayList&lt;&gt;();&#10;            for (ID id : ids) {&#10;                findById(id).ifPresent(result::add);&#10;            }&#10;            return result;&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public long count() {&#10;        return ExceptionHandler.safeExecute(&quot;count entities&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                CriteriaBuilder cb = em.getCriteriaBuilder();&#10;                CriteriaQuery&lt;Long&gt; query = cb.createQuery(Long.class);&#10;                Root&lt;T&gt; root = query.from(entityClass);&#10;                query.select(cb.count(root));&#10;&#10;                TypedQuery&lt;Long&gt; typedQuery = em.createQuery(query);&#10;                return typedQuery.getSingleResult();&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteById(ID id) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity by ID&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T entity = em.find(entityClass, id);&#10;                if (entity != null) {&#10;                    em.remove(entity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void delete(T entity) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                em.remove(managedEntity);&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllById(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;                ids.forEach(idList::add);&#10;&#10;                if (!idList.isEmpty()) {&#10;                    String tableName = MetadataManager.getTableName(entityClass);&#10;                    em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;)&#10;                            .setParameter(&quot;ids&quot;, idList)&#10;                            .executeUpdate();&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName()).executeUpdate();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void flush() {&#10;        ExceptionHandler.safeExecute(&quot;flush changes&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.flush();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T saveAndFlush(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save and flush entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                T savedEntity;&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    savedEntity = entity;&#10;                } else {&#10;                    savedEntity = em.merge(entity);&#10;                }&#10;                em.flush();&#10;                return savedEntity;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all and flush entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;                }&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteInBatch(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllInBatch() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName()).executeUpdate();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;                ids.forEach(idList::add);&#10;&#10;                if (!idList.isEmpty()) {&#10;                    em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;)&#10;                            .setParameter(&quot;ids&quot;, idList)&#10;                            .executeUpdate();&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getOne(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;get entity reference&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                return em.getReference(entityClass, id);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getReferenceById(ID id) {&#10;        return getOne(id);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import h2.orm.core.MetadataManager;&#10;import h2.orm.core.QueryExecutor;&#10;import h2.orm.core.TransactionManager;&#10;import h2.orm.exception.ExceptionHandler;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.lang.reflect.ParameterizedType;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Abstract JPA Repository implementation similar to Spring Data JPA&#10; * Now uses QueryExecutor for optimized query performance&#10; */&#10;public abstract class AbstractRepository&lt;T, ID extends Serializable&gt; implements JpaRepository&lt;T, ID&gt; {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(AbstractRepository.class);&#10;&#10;    protected final Class&lt;T&gt; entityClass;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public AbstractRepository() {&#10;        this.entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass().getGenericSuperclass())&#10;                .getActualTypeArguments()[0];&#10;    }&#10;&#10;    protected AbstractRepository(Class&lt;T&gt; entityClass) {&#10;        this.entityClass = entityClass;&#10;    }&#10;&#10;    protected abstract EntityManager getEntityManager();&#10;&#10;    @Override&#10;    public T save(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    return entity;&#10;                } else {&#10;                    return em.merge(entity);&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                int batchSize = 20;&#10;                int count = 0;&#10;&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;&#10;                    if (++count % batchSize == 0) {&#10;                        em.flush();&#10;                        em.clear();&#10;                    }&#10;                }&#10;&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;T&gt; findById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;find entity by ID&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                T entity = em.find(entityClass, id);&#10;                return Optional.ofNullable(entity);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public boolean existsById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;check entity exists&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized exists check&#10;            String jpql = &quot;SELECT COUNT(e) FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id = :id&quot;;&#10;            Long count = QueryExecutor.executeSingleResultQuery(jpql, Long.class, Map.of(&quot;id&quot;, id));&#10;            return count &gt; 0;&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAll() {&#10;        return ExceptionHandler.safeExecute(&quot;find all entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized query execution&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executeQuery(jpql, entityClass);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities by IDs&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;            &#10;            if (idList.isEmpty()) {&#10;                return new ArrayList&lt;&gt;();&#10;            }&#10;            &#10;            // Use QueryExecutor for batch ID lookup&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;            return QueryExecutor.executeQuery(jpql, entityClass, Map.of(&quot;ids&quot;, idList));&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public long count() {&#10;        return ExceptionHandler.safeExecute(&quot;count entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized count query&#10;            String jpql = &quot;SELECT COUNT(e) FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executeSingleResultQuery(jpql, Long.class);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteById(ID id) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity by ID&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id = :id&quot;;&#10;            QueryExecutor.executeUpdate(jpql, Map.of(&quot;id&quot;, id));&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void delete(T entity) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                em.remove(managedEntity);&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllById(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;&#10;            if (!idList.isEmpty()) {&#10;                // Use QueryExecutor for batch delete&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, idList));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized bulk delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName();&#10;            QueryExecutor.executeUpdate(jpql);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void flush() {&#10;        ExceptionHandler.safeExecute(&quot;flush changes&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.flush();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T saveAndFlush(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save and flush entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                T savedEntity;&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    savedEntity = entity;&#10;                } else {&#10;                    savedEntity = em.merge(entity);&#10;                }&#10;                em.flush();&#10;                return savedEntity;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all and flush entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;                }&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteInBatch(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities in batch&quot;, () -&gt; {&#10;            // Extract IDs and use QueryExecutor for batch delete&#10;            List&lt;ID&gt; ids = new ArrayList&lt;&gt;();&#10;            for (T entity : entities) {&#10;                @SuppressWarnings(&quot;unchecked&quot;)&#10;                ID id = (ID) MetadataManager.getIdValue(entity);&#10;                if (id != null) {&#10;                    ids.add(id);&#10;                }&#10;            }&#10;            &#10;            if (!ids.isEmpty()) {&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, ids));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllInBatch() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities in batch&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized bulk delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName();&#10;            QueryExecutor.executeUpdate(jpql);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs in batch&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;&#10;            if (!idList.isEmpty()) {&#10;                // Use QueryExecutor for batch delete&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, idList));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getOne(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;get entity reference&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                return em.getReference(entityClass, id);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getReferenceById(ID id) {&#10;        return getOne(id);&#10;    }&#10;&#10;    // Additional utility methods using QueryExecutor&#10;&#10;    /**&#10;     * Find entities with pagination using QueryExecutor&#10;     */&#10;    public List&lt;T&gt; findAll(int offset, int limit) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities with pagination&quot;, () -&gt; {&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executePaginatedQuery(jpql, entityClass, null, offset, limit);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query&#10;     */&#10;    public List&lt;T&gt; findByJpql(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return ExceptionHandler.safeExecute(&quot;execute custom JPQL query&quot;, () -&gt; {&#10;            return QueryExecutor.executeQuery(jpql, entityClass, parameters);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute custom native SQL query&#10;     */&#10;    public List&lt;T&gt; findByNativeQuery(String sql, Map&lt;String, Object&gt; parameters) {&#10;        return ExceptionHandler.safeExecute(&quot;execute custom native query&quot;, () -&gt; {&#10;            return QueryExecutor.executeNativeQuery(sql, entityClass, parameters);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/JpaRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/JpaRepository.java" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;&#10;/**&#10; * JPA Repository interface similar to Spring Data JPA&#10; * Extends base Repository with additional JPA-specific methods&#10; */&#10;public interface JpaRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; {&#10;    &#10;    /**&#10;     * Flush changes to database&#10;     */&#10;    void flush();&#10;    &#10;    /**&#10;     * Save and flush entity&#10;     */&#10;    T saveAndFlush(T entity);&#10;    &#10;    /**&#10;     * Save all and flush entities&#10;     */&#10;    List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete entities in batch&#10;     */&#10;    void deleteInBatch(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete all entities in batch&#10;     */&#10;    void deleteAllInBatch();&#10;    &#10;    /**&#10;     * Delete all entities in batch by IDs&#10;     */&#10;    void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Get reference to entity (lazy loading)&#10;     */&#10;    T getOne(ID id);&#10;    &#10;    /**&#10;     * Get reference to entity (lazy loading) - JPA 3.0 style&#10;     */&#10;    T getReferenceById(ID id);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repositories.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repositories.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import jakarta.persistence.EntityManager;&#10;&#10;import java.io.Serializable;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Repository factory that creates JPA repositories automatically&#10; * Works exactly like Spring Data JPA - just call Repositories.of(EntityClass.class)&#10; */&#10;public class Repositories {&#10;&#10;    private static final Map&lt;Class&lt;?&gt;, JpaRepository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get repository for entity class - creates it automatically if needed&#10;     * Usage: UserRepository userRepo = Repositories.of(User.class);&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;T, ID extends Serializable&gt; JpaRepository&lt;T, ID&gt; of(Class&lt;T&gt; entityClass) {&#10;        return (JpaRepository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass,&#10;            clazz -&gt; new SimpleJpaRepository&lt;&gt;((Class&lt;T&gt;) clazz));&#10;    }&#10;&#10;    /**&#10;     * Clear repository cache&#10;     */&#10;    public static void clearCache() {&#10;        repositoryCache.clear();&#10;    }&#10;&#10;    /**&#10;     * Simple JPA Repository implementation&#10;     */&#10;    private static class SimpleJpaRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;&#10;        public SimpleJpaRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;&#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import jakarta.persistence.EntityManager;&#10;&#10;import java.io.Serializable;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Repository factory that creates JPA repositories automatically&#10; * Works exactly like Spring Data JPA - just call Repositories.of(EntityClass.class)&#10; * Now uses core EntityManagerProvider for better performance&#10; */&#10;public class Repositories {&#10;    &#10;    private static final Map&lt;Class&lt;?&gt;, JpaRepository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;    &#10;    /**&#10;     * Get repository for entity class - creates it automatically if needed&#10;     * Usage: UserRepository userRepo = Repositories.of(User.class);&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;T, ID extends Serializable&gt; JpaRepository&lt;T, ID&gt; of(Class&lt;T&gt; entityClass) {&#10;        return (JpaRepository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, &#10;            clazz -&gt; new SimpleJpaRepository&lt;&gt;((Class&lt;T&gt;) clazz));&#10;    }&#10;    &#10;    /**&#10;     * Clear repository cache&#10;     */&#10;    public static void clearCache() {&#10;        repositoryCache.clear();&#10;    }&#10;    &#10;    /**&#10;     * Simple JPA Repository implementation using core EntityManagerProvider&#10;     */&#10;    private static class SimpleJpaRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;        &#10;        public SimpleJpaRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;        &#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repository.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Generic Repository interface for basic CRUD operations&#10; * @param &lt;T&gt; Entity type&#10; * @param &lt;ID&gt; Primary key type&#10; */&#10;public interface Repository&lt;T, ID extends Serializable&gt; {&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    T save(T entity);&#10;&#10;    /**&#10;     * Save multiple entities&#10;     */&#10;    List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    Optional&lt;T&gt; findById(ID id);&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    List&lt;T&gt; findAll();&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    List&lt;T&gt; findAll(int offset, int limit);&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    List&lt;T&gt; findByAttribute(String attributeName, Object value);&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    List&lt;T&gt; findByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    List&lt;T&gt; findByNativeQuery(String sqlQuery, Object... params);&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    List&lt;T&gt; findByQuery(String jpqlQuery, Object... params);&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    long count();&#10;&#10;    /**&#10;     * Count entities by criteria&#10;     */&#10;    long countByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    boolean existsById(ID id);&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    boolean existsByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Update entity&#10;     */&#10;    T update(T entity);&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    void deleteById(ID id);&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    void delete(T entity);&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll();&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    void deleteByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    int executeUpdate(String jpqlQuery, Object... params);&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    int executeNativeUpdate(String sqlQuery, Object... params);&#10;&#10;    /**&#10;     * Batch insert entities&#10;     */&#10;    void batchInsert(List&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Batch update entities&#10;     */&#10;    void batchUpdate(List&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Get entity class&#10;     */&#10;    Class&lt;T&gt; getEntityClass();&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Base repository interface similar to Spring Data JPA&#10; * Provides standard CRUD operations for entities&#10; */&#10;public interface Repository&lt;T, ID extends Serializable&gt; {&#10;    &#10;    /**&#10;     * Save an entity&#10;     */&#10;    T save(T entity);&#10;    &#10;    /**&#10;     * Save all entities&#10;     */&#10;    List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    Optional&lt;T&gt; findById(ID id);&#10;    &#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    boolean existsById(ID id);&#10;    &#10;    /**&#10;     * Find all entities&#10;     */&#10;    List&lt;T&gt; findAll();&#10;    &#10;    /**&#10;     * Find all entities by IDs&#10;     */&#10;    List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Count all entities&#10;     */&#10;    long count();&#10;    &#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    void deleteById(ID id);&#10;    &#10;    /**&#10;     * Delete entity&#10;     */&#10;    void delete(T entity);&#10;    &#10;    /**&#10;     * Delete all entities by IDs&#10;     */&#10;    void deleteAllById(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/service/BackupService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/service/BackupService.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/service/ExportService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/service/ExportService.java" />
              <option name="updatedContent" value="package h2.orm.service;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.fasterxml.jackson.databind.SerializationFeature;&#10;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;&#10;import org.apache.poi.ss.usermodel.*;&#10;import org.apache.poi.xssf.usermodel.XSSFWorkbook;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.FileOutputStream;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.lang.reflect.Field;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;/**&#10; * Export service for converting data to various formats (CSV, Excel, JSON)&#10; */&#10;public class ExportService {&#10;    &#10;    private static final Logger logger = LoggerFactory.getLogger(ExportService.class);&#10;    private final ObjectMapper objectMapper;&#10;    &#10;    public ExportService() {&#10;        this.objectMapper = new ObjectMapper();&#10;        this.objectMapper.registerModule(new JavaTimeModule());&#10;        this.objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);&#10;        this.objectMapper.enable(SerializationFeature.INDENT_OUTPUT);&#10;    }&#10;    &#10;    /**&#10;     * Export data to CSV file&#10;     */&#10;    public &lt;T&gt; void exportToCsv(List&lt;T&gt; data, String filePath) {&#10;        if (data == null || data.isEmpty()) {&#10;            logger.warn(&quot;No data to export to CSV&quot;);&#10;            return;&#10;        }&#10;        &#10;        try (FileWriter writer = new FileWriter(filePath)) {&#10;            Class&lt;?&gt; clazz = data.get(0).getClass();&#10;            Field[] fields = clazz.getDeclaredFields();&#10;            &#10;            // Write header&#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                if (i &gt; 0) writer.append(&quot;,&quot;);&#10;                writer.append(fields[i].getName());&#10;            }&#10;            writer.append(&quot;\n&quot;);&#10;            &#10;            // Write data&#10;            for (T item : data) {&#10;                for (int i = 0; i &lt; fields.length; i++) {&#10;                    if (i &gt; 0) writer.append(&quot;,&quot;);&#10;                    &#10;                    fields[i].setAccessible(true);&#10;                    Object value = fields[i].get(item);&#10;                    String stringValue = value != null ? value.toString() : &quot;&quot;;&#10;                    &#10;                    // Escape commas and quotes in CSV&#10;                    if (stringValue.contains(&quot;,&quot;) || stringValue.contains(&quot;\&quot;&quot;)) {&#10;                        stringValue = &quot;\&quot;&quot; + stringValue.replace(&quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;) + &quot;\&quot;&quot;;&#10;                    }&#10;                    &#10;                    writer.append(stringValue);&#10;                }&#10;                writer.append(&quot;\n&quot;);&#10;            }&#10;            &#10;            logger.info(&quot;Data exported to CSV: {} ({} records)&quot;, filePath, data.size());&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to export to CSV&quot;, e);&#10;            throw new RuntimeException(&quot;CSV export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export data to Excel file&#10;     */&#10;    public &lt;T&gt; void exportToExcel(List&lt;T&gt; data, String filePath) {&#10;        if (data == null || data.isEmpty()) {&#10;            logger.warn(&quot;No data to export to Excel&quot;);&#10;            return;&#10;        }&#10;        &#10;        try (Workbook workbook = new XSSFWorkbook()) {&#10;            Sheet sheet = workbook.createSheet(&quot;Data&quot;);&#10;            &#10;            Class&lt;?&gt; clazz = data.get(0).getClass();&#10;            Field[] fields = clazz.getDeclaredFields();&#10;            &#10;            // Create header row&#10;            Row headerRow = sheet.createRow(0);&#10;            CellStyle headerStyle = workbook.createCellStyle();&#10;            Font headerFont = workbook.createFont();&#10;            headerFont.setBold(true);&#10;            headerStyle.setFont(headerFont);&#10;            &#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                Cell cell = headerRow.createCell(i);&#10;                cell.setCellValue(fields[i].getName());&#10;                cell.setCellStyle(headerStyle);&#10;            }&#10;            &#10;            // Create data rows&#10;            for (int rowIndex = 0; rowIndex &lt; data.size(); rowIndex++) {&#10;                Row row = sheet.createRow(rowIndex + 1);&#10;                T item = data.get(rowIndex);&#10;                &#10;                for (int colIndex = 0; colIndex &lt; fields.length; colIndex++) {&#10;                    Cell cell = row.createCell(colIndex);&#10;                    fields[colIndex].setAccessible(true);&#10;                    Object value = fields[colIndex].get(item);&#10;                    &#10;                    if (value != null) {&#10;                        if (value instanceof Number) {&#10;                            cell.setCellValue(((Number) value).doubleValue());&#10;                        } else if (value instanceof Boolean) {&#10;                            cell.setCellValue((Boolean) value);&#10;                        } else if (value instanceof LocalDate) {&#10;                            cell.setCellValue(value.toString());&#10;                        } else if (value instanceof LocalDateTime) {&#10;                            cell.setCellValue(value.toString());&#10;                        } else {&#10;                            cell.setCellValue(value.toString());&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            &#10;            // Auto-size columns&#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                sheet.autoSizeColumn(i);&#10;            }&#10;            &#10;            // Write to file&#10;            try (FileOutputStream fileOut = new FileOutputStream(filePath)) {&#10;                workbook.write(fileOut);&#10;            }&#10;            &#10;            logger.info(&quot;Data exported to Excel: {} ({} records)&quot;, filePath, data.size());&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to export to Excel&quot;, e);&#10;            throw new RuntimeException(&quot;Excel export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export data to JSON file&#10;     */&#10;    public &lt;T&gt; void exportToJson(List&lt;T&gt; data, String filePath) {&#10;        try {&#10;            objectMapper.writeValue(new java.io.File(filePath), data);&#10;            logger.info(&quot;Data exported to JSON: {} ({} records)&quot;, filePath, data != null ? data.size() : 0);&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Failed to export to JSON&quot;, e);&#10;            throw new RuntimeException(&quot;JSON export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export single object to JSON file&#10;     */&#10;    public &lt;T&gt; void exportToJson(T object, String filePath) {&#10;        try {&#10;            objectMapper.writeValue(new java.io.File(filePath), object);&#10;            logger.info(&quot;Object exported to JSON: {}&quot;, filePath);&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Failed to export to JSON&quot;, e);&#10;            throw new RuntimeException(&quot;JSON export failed&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/h2/orm/test/H2ORMTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/h2/orm/test/H2ORMTest.java" />
              <option name="originalContent" value="package h2.orm.test;&#10;&#10;import h2.orm.H2ORM;&#10;import h2.orm.core.repository.*;&#10;import h2.orm.core.service.TableManager;&#10;import h2.orm.example.Product;&#10;import h2.orm.example.User;&#10;import org.junit.jupiter.api.*;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Comprehensive JUnit test suite for H2-ORM functionality&#10; */&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;public class H2ORMTest {&#10;&#10;    private static JpaRepository&lt;User, Long&gt; userRepo;&#10;    private static JpaRepository&lt;Product, Long&gt; productRepo;&#10;&#10;    @BeforeAll&#10;    static void setupH2ORM() {&#10;        H2ORM.startInMemory();&#10;        userRepo = H2ORM.repository(User.class);&#10;        productRepo = H2ORM.repository(Product.class);&#10;    }&#10;&#10;    @AfterAll&#10;    static void shutdownH2ORM() {&#10;        H2ORM.stop();&#10;    }&#10;&#10;    @BeforeEach&#10;    void setupTestData() {&#10;        // Clear existing data&#10;        userRepo.deleteAll();&#10;        productRepo.deleteAll();&#10;&#10;        // Create test users&#10;        User user1 = new User(&quot;alice_j&quot;, &quot;alice@example.com&quot;, &quot;Alice Johnson&quot;);&#10;        User user2 = new User(&quot;bob_s&quot;, &quot;bob@example.com&quot;, &quot;Bob Smith&quot;);&#10;        User user3 = new User(&quot;charlie_b&quot;, &quot;charlie@example.com&quot;, &quot;Charlie Brown&quot;);&#10;&#10;        userRepo.saveAll(List.of(user1, user2, user3));&#10;&#10;        // Create test products (need to check Product constructor)&#10;        Product product1 = new Product(&quot;Laptop&quot;, &quot;High-performance laptop&quot;, new java.math.BigDecimal(&quot;999.99&quot;));&#10;        Product product2 = new Product(&quot;Smartphone&quot;, &quot;Latest model smartphone&quot;, new java.math.BigDecimal(&quot;699.99&quot;));&#10;&#10;        productRepo.saveAll(List.of(product1, product2));&#10;    }&#10;&#10;    @Test&#10;    @Order(1)&#10;    @DisplayName(&quot;Test Basic Repository Operations&quot;)&#10;    void testBasicRepositoryOperations() {&#10;        // Test count&#10;        assertEquals(3, userRepo.count());&#10;        assertEquals(2, productRepo.count());&#10;&#10;        // Test findAll&#10;        List&lt;User&gt; allUsers = userRepo.findAll();&#10;        assertEquals(3, allUsers.size());&#10;&#10;        // Test findById&#10;        User firstUser = allUsers.get(0);&#10;        Optional&lt;User&gt; foundUser = userRepo.findById(firstUser.getId());&#10;        assertTrue(foundUser.isPresent());&#10;        assertEquals(firstUser.getFullName(), foundUser.get().getFullName());&#10;&#10;        // Test existsById&#10;        assertTrue(userRepo.existsById(firstUser.getId()));&#10;        assertFalse(userRepo.existsById(9999L));&#10;&#10;        // Test save&#10;        User newUser = new User(&quot;diana_p&quot;, &quot;diana@example.com&quot;, &quot;Diana Prince&quot;);&#10;        User savedUser = userRepo.save(newUser);&#10;        assertNotNull(savedUser.getId());&#10;        assertEquals(4, userRepo.count());&#10;&#10;        // Test delete&#10;        userRepo.delete(savedUser);&#10;        assertEquals(3, userRepo.count());&#10;    }&#10;&#10;    @Test&#10;    @Order(2)&#10;    @DisplayName(&quot;Test Sorting Functionality&quot;)&#10;    void testSortingFunctionality() {&#10;        // Test ascending sort by fullName&#10;        List&lt;User&gt; sortedByFullName = userRepo.findAll(Sort.by(&quot;fullName&quot;));&#10;        assertEquals(&quot;Alice Johnson&quot;, sortedByFullName.get(0).getFullName());&#10;        assertEquals(&quot;Bob Smith&quot;, sortedByFullName.get(1).getFullName());&#10;        assertEquals(&quot;Charlie Brown&quot;, sortedByFullName.get(2).getFullName());&#10;&#10;        // Test descending sort by username&#10;        List&lt;User&gt; sortedByUsernameDesc = userRepo.findAll(Sort.by(Sort.Direction.DESC, &quot;username&quot;));&#10;        assertEquals(&quot;charlie_b&quot;, sortedByUsernameDesc.get(0).getUsername());&#10;        assertEquals(&quot;bob_s&quot;, sortedByUsernameDesc.get(1).getUsername());&#10;        assertEquals(&quot;alice_j&quot;, sortedByUsernameDesc.get(2).getUsername());&#10;&#10;        // Test multiple field sorting&#10;        Sort multiSort = Sort.by(&quot;username&quot;).and(Sort.by(Sort.Direction.DESC, &quot;fullName&quot;));&#10;        List&lt;User&gt; multiSorted = userRepo.findAll(multiSort);&#10;        assertEquals(3, multiSorted.size());&#10;&#10;        // Test Sort.Order fluent API&#10;        Sort.Order usernameOrder = Sort.Order.asc(&quot;username&quot;);&#10;        assertTrue(usernameOrder.isAscending());&#10;        assertFalse(usernameOrder.isDescending());&#10;&#10;        Sort.Order fullNameOrder = Sort.Order.desc(&quot;fullName&quot;);&#10;        assertTrue(fullNameOrder.isDescending());&#10;        assertFalse(fullNameOrder.isAscending());&#10;    }&#10;&#10;    @Test&#10;    @Order(3)&#10;    @DisplayName(&quot;Test Pagination Functionality&quot;)&#10;    void testPaginationFunctionality() {&#10;        // Test basic pagination&#10;        PageRequest pageRequest = PageRequest.of(0, 2);&#10;        Page&lt;User&gt; firstPage = userRepo.findAll(pageRequest);&#10;&#10;        assertEquals(0, firstPage.getNumber());&#10;        assertEquals(2, firstPage.getSize());&#10;        assertEquals(3, firstPage.getTotalElements());&#10;        assertEquals(2, firstPage.getTotalPages());&#10;        assertEquals(2, firstPage.getNumberOfElements());&#10;        assertTrue(firstPage.hasNext());&#10;        assertFalse(firstPage.hasPrevious());&#10;        assertTrue(firstPage.isFirst());&#10;        assertFalse(firstPage.isLast());&#10;&#10;        // Test second page&#10;        Page&lt;User&gt; secondPage = userRepo.findAll(firstPage.nextPageable());&#10;        assertEquals(1, secondPage.getNumber());&#10;        assertEquals(1, secondPage.getNumberOfElements());&#10;        assertFalse(secondPage.hasNext());&#10;        assertTrue(secondPage.hasPrevious());&#10;        assertFalse(secondPage.isFirst());&#10;        assertTrue(secondPage.isLast());&#10;&#10;        // Test pagination with sorting&#10;        PageRequest sortedPageRequest = PageRequest.of(0, 2, Sort.by(&quot;fullName&quot;));&#10;        Page&lt;User&gt; sortedPage = userRepo.findAll(sortedPageRequest);&#10;        assertEquals(&quot;Alice Johnson&quot;, sortedPage.getContent().get(0).getFullName());&#10;        assertEquals(&quot;Bob Smith&quot;, sortedPage.getContent().get(1).getFullName());&#10;&#10;        // Test page mapping&#10;        Page&lt;String&gt; mappedPage = firstPage.map(User::getFullName);&#10;        assertEquals(2, mappedPage.getNumberOfElements());&#10;        assertTrue(mappedPage.getContent().stream().allMatch(name -&gt; name instanceof String));&#10;    }&#10;&#10;    @Test&#10;    @Order(4)&#10;    @DisplayName(&quot;Test Table Management&quot;)&#10;    void testTableManagement() {&#10;        // Test table existence&#10;        assertTrue(H2ORM.tableExists(&quot;user&quot;));&#10;        assertTrue(H2ORM.tableExists(&quot;product&quot;));&#10;        assertFalse(H2ORM.tableExists(&quot;nonexistent_table&quot;));&#10;&#10;        // Test table row counts&#10;        assertEquals(3, H2ORM.getTableRowCount(User.class));&#10;        assertEquals(2, H2ORM.getTableRowCount(Product.class));&#10;&#10;        // Test table info&#10;        TableManager.TableInfo userTableInfo = H2ORM.getTableInfo(User.class);&#10;        assertNotNull(userTableInfo);&#10;        assertEquals(&quot;user&quot;, userTableInfo.getTableName());&#10;        assertTrue(userTableInfo.isExists());&#10;        assertEquals(3, userTableInfo.getRowCount());&#10;&#10;        // Test all table info&#10;        List&lt;TableManager.TableInfo&gt; allTables = H2ORM.getAllTableInfo();&#10;        assertTrue(allTables.size() &gt;= 2);&#10;        assertTrue(allTables.stream().anyMatch(table -&gt; &quot;user&quot;.equals(table.getTableName())));&#10;        assertTrue(allTables.stream().anyMatch(table -&gt; &quot;product&quot;.equals(table.getTableName())));&#10;    }&#10;&#10;    @Test&#10;    @Order(5)&#10;    @DisplayName(&quot;Test Advanced Repository Operations&quot;)&#10;    void testAdvancedRepositoryOperations() {&#10;        // Test findAllById&#10;        List&lt;User&gt; allUsers = userRepo.findAll();&#10;        List&lt;Long&gt; userIds = allUsers.stream().map(User::getId).limit(2).toList();&#10;        List&lt;User&gt; foundUsers = userRepo.findAllById(userIds);&#10;        assertEquals(2, foundUsers.size());&#10;&#10;        // Test saveAndFlush&#10;        User newUser = new User(&quot;test_user&quot;, &quot;test@example.com&quot;, &quot;Test User&quot;);&#10;        User savedUser = userRepo.saveAndFlush(newUser);&#10;        assertNotNull(savedUser.getId());&#10;        assertEquals(&quot;Test User&quot;, savedUser.getFullName());&#10;&#10;        // Test batch operations&#10;        List&lt;User&gt; batchUsers = List.of(&#10;                new User(&quot;batch1&quot;, &quot;batch1@example.com&quot;, &quot;Batch User 1&quot;),&#10;                new User(&quot;batch2&quot;, &quot;batch2@example.com&quot;, &quot;Batch User 2&quot;)&#10;        );&#10;        List&lt;User&gt; savedBatchUsers = userRepo.saveAllAndFlush(batchUsers);&#10;        assertEquals(2, savedBatchUsers.size());&#10;        assertEquals(6, userRepo.count()); // 3 original + 1 test + 2 batch&#10;&#10;        // Test deleteAllById&#10;        List&lt;Long&gt; batchIds = savedBatchUsers.stream().map(User::getId).toList();&#10;        userRepo.deleteAllById(batchIds);&#10;        assertEquals(4, userRepo.count()); // 3 original + 1 test&#10;&#10;        // Cleanup&#10;        userRepo.delete(savedUser);&#10;        assertEquals(3, userRepo.count());&#10;    }&#10;&#10;    @Test&#10;    @Order(6)&#10;    @DisplayName(&quot;Test Export Functionality&quot;)&#10;    void testExportFunctionality() {&#10;        assertDoesNotThrow(() -&gt; {&#10;            // Test CSV export&#10;            H2ORM.exportToCsv(User.class, &quot;./test-exports/users.csv&quot;);&#10;&#10;            // Test Excel export&#10;            H2ORM.exportToExcel(User.class, &quot;./test-exports/users.xlsx&quot;);&#10;&#10;            // Test JSON export&#10;            H2ORM.exportToJson(User.class, &quot;./test-exports/users.json&quot;);&#10;&#10;            // Test export with specific data - filter by active users&#10;            List&lt;User&gt; activeUsers = userRepo.findAll().stream()&#10;                    .filter(user -&gt; user.getIsActive() != null &amp;&amp; user.getIsActive())&#10;                    .toList();&#10;            H2ORM.exportToCsv(activeUsers, &quot;./test-exports/active_users.csv&quot;);&#10;        });&#10;    }&#10;&#10;    @Test&#10;    @Order(7)&#10;    @DisplayName(&quot;Test Sort Edge Cases&quot;)&#10;    void testSortEdgeCases() {&#10;        // Test unsorted&#10;        Sort unsorted = Sort.unsorted();&#10;        assertTrue(unsorted.isUnsorted());&#10;        assertFalse(unsorted.isSorted());&#10;&#10;        // Test empty sort&#10;        List&lt;User&gt; unsortedUsers = userRepo.findAll(unsorted);&#10;        assertEquals(3, unsortedUsers.size());&#10;&#10;        // Test sort by non-existent field (should not crash)&#10;        assertDoesNotThrow(() -&gt; {&#10;            userRepo.findAll(Sort.by(&quot;nonExistentField&quot;));&#10;        });&#10;&#10;        // Test null handling&#10;        Sort.Order orderWithNulls = Sort.Order.asc(&quot;fullName&quot;).nullsLast();&#10;        assertEquals(Sort.NullHandling.NULLS_LAST, orderWithNulls.getNullHandling());&#10;    }&#10;&#10;    @Test&#10;    @Order(8)&#10;    @DisplayName(&quot;Test PageRequest Edge Cases&quot;)&#10;    void testPageRequestEdgeCases() {&#10;        // Test invalid page parameters&#10;        assertThrows(IllegalArgumentException.class, () -&gt; PageRequest.of(-1, 10));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; PageRequest.of(0, 0));&#10;&#10;        // Test large page size&#10;        Page&lt;User&gt; largePage = userRepo.findAll(PageRequest.of(0, 100));&#10;        assertEquals(3, largePage.getNumberOfElements());&#10;        assertEquals(1, largePage.getTotalPages());&#10;&#10;        // Test page beyond data&#10;        Page&lt;User&gt; emptyPage = userRepo.findAll(PageRequest.of(10, 10));&#10;        assertEquals(0, emptyPage.getNumberOfElements());&#10;        assertTrue(emptyPage.getContent().isEmpty());&#10;&#10;        // Test withPage method&#10;        PageRequest original = PageRequest.of(0, 2);&#10;        Pageable modified = original.withPage(1);&#10;        assertEquals(1, modified.getPageNumber());&#10;        assertEquals(2, modified.getPageSize());&#10;    }&#10;&#10;    @Test&#10;    @Order(9)&#10;    @DisplayName(&quot;Test Transaction Management&quot;)&#10;    void testTransactionManagement() {&#10;        // Test that operations work correctly within transactions&#10;        long initialCount = userRepo.count();&#10;&#10;        // This should work (save operation in transaction)&#10;        User newUser = new User(&quot;trans_test&quot;, &quot;transaction@example.com&quot;, &quot;Transaction Test&quot;);&#10;        User savedUser = userRepo.save(newUser);&#10;        assertNotNull(savedUser.getId());&#10;        assertEquals(initialCount + 1, userRepo.count());&#10;&#10;        // Cleanup&#10;        userRepo.delete(savedUser);&#10;        assertEquals(initialCount, userRepo.count());&#10;    }&#10;&#10;    @Test&#10;    @Order(10)&#10;    @DisplayName(&quot;Test H2ORM Lifecycle&quot;)&#10;    void testH2ORMLifecycle() {&#10;        // Test that H2ORM is running&#10;        assertTrue(H2ORM.isRunning());&#10;&#10;        // Test repository creation&#10;        JpaRepository&lt;User, Long&gt; newUserRepo = H2ORM.repository(User.class);&#10;        assertNotNull(newUserRepo);&#10;&#10;        // Test that repositories work&#10;        assertEquals(3, newUserRepo.count());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.test;&#13;&#10;&#13;&#10;import h2.orm.H2ORM;&#13;&#10;import h2.orm.core.repository.*;&#13;&#10;import h2.orm.core.service.TableManager;&#13;&#10;import h2.orm.example.Product;&#13;&#10;import h2.orm.example.User;&#13;&#10;import org.junit.jupiter.api.*;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Optional;&#13;&#10;&#13;&#10;import static org.junit.jupiter.api.Assertions.*;&#13;&#10;&#13;&#10;/**&#13;&#10; * Comprehensive JUnit test suite for H2-ORM functionality&#13;&#10; */&#13;&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#13;&#10;public class H2ORMTest {&#13;&#10;&#13;&#10;    private static JpaRepository&lt;User, Long&gt; userRepo;&#13;&#10;    private static JpaRepository&lt;Product, Long&gt; productRepo;&#13;&#10;&#13;&#10;    @BeforeAll&#13;&#10;    static void setupH2ORM() {&#13;&#10;        H2ORM.startInMemory();&#13;&#10;        userRepo = H2ORM.repository(User.class);&#13;&#10;        productRepo = H2ORM.repository(Product.class);&#13;&#10;    }&#13;&#10;&#13;&#10;    @AfterAll&#13;&#10;    static void shutdownH2ORM() {&#13;&#10;        H2ORM.stop();&#13;&#10;    }&#13;&#10;&#13;&#10;    @BeforeEach&#13;&#10;    void setupTestData() {&#13;&#10;        // Clear existing data&#13;&#10;        userRepo.deleteAll();&#13;&#10;        productRepo.deleteAll();&#13;&#10;&#13;&#10;        // Create test users&#13;&#10;        User user1 = new User(&quot;alice_j&quot;, &quot;alice@example.com&quot;, &quot;Alice Johnson&quot;);&#13;&#10;        User user2 = new User(&quot;bob_s&quot;, &quot;bob@example.com&quot;, &quot;Bob Smith&quot;);&#13;&#10;        User user3 = new User(&quot;charlie_b&quot;, &quot;charlie@example.com&quot;, &quot;Charlie Brown&quot;);&#13;&#10;&#13;&#10;        userRepo.saveAll(List.of(user1, user2, user3));&#13;&#10;&#13;&#10;        // Create test products (need to check Product constructor)&#13;&#10;        Product product1 = new Product(&quot;Laptop&quot;, &quot;High-performance laptop&quot;, new java.math.BigDecimal(&quot;999.99&quot;));&#13;&#10;        Product product2 = new Product(&quot;Smartphone&quot;, &quot;Latest model smartphone&quot;, new java.math.BigDecimal(&quot;699.99&quot;));&#13;&#10;&#13;&#10;        productRepo.saveAll(List.of(product1, product2));&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    @Order(1)&#13;&#10;    @DisplayName(&quot;Test Basic Repository Operations&quot;)&#13;&#10;    void testBasicRepositoryOperations() {&#13;&#10;        // Test count&#13;&#10;        assertEquals(3, userRepo.count());&#13;&#10;        assertEquals(2, productRepo.count());&#13;&#10;&#13;&#10;        // Test findAll&#13;&#10;        List&lt;User&gt; allUsers = userRepo.findAll();&#13;&#10;        assertEquals(3, allUsers.size());&#13;&#10;&#13;&#10;        // Test findById&#13;&#10;        User firstUser = allUsers.get(0);&#13;&#10;        Optional&lt;User&gt; foundUser = userRepo.findById(firstUser.getId());&#13;&#10;        assertTrue(foundUser.isPresent());&#13;&#10;        assertEquals(firstUser.getFullName(), foundUser.get().getFullName());&#13;&#10;&#13;&#10;        // Test existsById&#13;&#10;        assertTrue(userRepo.existsById(firstUser.getId()));&#13;&#10;        assertFalse(userRepo.existsById(9999L));&#13;&#10;&#13;&#10;        // Test save&#13;&#10;        User newUser = new User(&quot;diana_p&quot;, &quot;diana@example.com&quot;, &quot;Diana Prince&quot;);&#13;&#10;        User savedUser = userRepo.save(newUser);&#13;&#10;        assertNotNull(savedUser.getId());&#13;&#10;        assertEquals(4, userRepo.count());&#13;&#10;&#13;&#10;        // Test delete&#13;&#10;        userRepo.delete(savedUser);&#13;&#10;        assertEquals(3, userRepo.count());&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    @Order(2)&#13;&#10;    @DisplayName(&quot;Test Sorting Functionality&quot;)&#13;&#10;    void testSortingFunctionality() {&#13;&#10;        // Test ascending sort by fullName&#13;&#10;        List&lt;User&gt; sortedByFullName = userRepo.findAll(Sort.by(&quot;fullName&quot;));&#13;&#10;        assertEquals(&quot;Alice Johnson&quot;, sortedByFullName.get(0).getFullName());&#13;&#10;        assertEquals(&quot;Bob Smith&quot;, sortedByFullName.get(1).getFullName());&#13;&#10;        assertEquals(&quot;Charlie Brown&quot;, sortedByFullName.get(2).getFullName());&#13;&#10;&#13;&#10;        // Test descending sort by username&#13;&#10;        List&lt;User&gt; sortedByUsernameDesc = userRepo.findAll(Sort.by(Sort.Direction.DESC, &quot;username&quot;));&#13;&#10;        assertEquals(&quot;charlie_b&quot;, sortedByUsernameDesc.get(0).getUsername());&#13;&#10;        assertEquals(&quot;bob_s&quot;, sortedByUsernameDesc.get(1).getUsername());&#13;&#10;        assertEquals(&quot;alice_j&quot;, sortedByUsernameDesc.get(2).getUsername());&#13;&#10;&#13;&#10;        // Test multiple field sorting&#13;&#10;        Sort multiSort = Sort.by(&quot;username&quot;).and(Sort.by(Sort.Direction.DESC, &quot;fullName&quot;));&#13;&#10;        List&lt;User&gt; multiSorted = userRepo.findAll(multiSort);&#13;&#10;        assertEquals(3, multiSorted.size());&#13;&#10;&#13;&#10;        // Test Sort.Order fluent API&#13;&#10;        Sort.Order usernameOrder = Sort.Order.asc(&quot;username&quot;);&#13;&#10;        assertTrue(usernameOrder.isAscending());&#13;&#10;        assertFalse(usernameOrder.isDescending());&#13;&#10;&#13;&#10;        Sort.Order fullNameOrder = Sort.Order.desc(&quot;fullName&quot;);&#13;&#10;        assertTrue(fullNameOrder.isDescending());&#13;&#10;        assertFalse(fullNameOrder.isAscending());&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    @Order(3)&#13;&#10;    @DisplayName(&quot;Test Pagination Functionality&quot;)&#13;&#10;    void testPaginationFunctionality() {&#13;&#10;        // Test basic pagination&#13;&#10;        PageRequest pageRequest = PageRequest.of(0, 2);&#13;&#10;        Page&lt;User&gt; firstPage = userRepo.findAll(pageRequest);&#13;&#10;&#13;&#10;        assertEquals(0, firstPage.getNumber());&#13;&#10;        assertEquals(2, firstPage.getSize());&#13;&#10;        assertEquals(3, firstPage.getTotalElements());&#13;&#10;        assertEquals(2, firstPage.getTotalPages());&#13;&#10;        assertEquals(2, firstPage.getNumberOfElements());&#13;&#10;        assertTrue(firstPage.hasNext());&#13;&#10;        assertFalse(firstPage.hasPrevious());&#13;&#10;        assertTrue(firstPage.isFirst());&#13;&#10;        assertFalse(firstPage.isLast());&#13;&#10;&#13;&#10;        // Test second page&#13;&#10;        Page&lt;User&gt; secondPage = userRepo.findAll(firstPage.nextPageable());&#13;&#10;        assertEquals(1, secondPage.getNumber());&#13;&#10;        assertEquals(1, secondPage.getNumberOfElements());&#13;&#10;        assertFalse(secondPage.hasNext());&#13;&#10;        assertTrue(secondPage.hasPrevious());&#13;&#10;        assertFalse(secondPage.isFirst());&#13;&#10;        assertTrue(secondPage.isLast());&#13;&#10;&#13;&#10;        // Test pagination with sorting&#13;&#10;        PageRequest sortedPageRequest = PageRequest.of(0, 2, Sort.by(&quot;fullName&quot;));&#13;&#10;        Page&lt;User&gt; sortedPage = userRepo.findAll(sortedPageRequest);&#13;&#10;        assertEquals(&quot;Alice Johnson&quot;, sortedPage.getContent().get(0).getFullName());&#13;&#10;        assertEquals(&quot;Bob Smith&quot;, sortedPage.getContent().get(1).getFullName());&#13;&#10;&#13;&#10;        // Test page mapping&#13;&#10;        Page&lt;String&gt; mappedPage = firstPage.map(User::getFullName);&#13;&#10;        assertEquals(2, mappedPage.getNumberOfElements());&#13;&#10;        assertTrue(mappedPage.getContent().stream().allMatch(name -&gt; name instanceof String));&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    @Order(4)&#13;&#10;    @DisplayName(&quot;Test Table Management&quot;)&#13;&#10;    void testTableManagement() {&#13;&#10;        // Test table existence - fix table names to match actual @Table annotations&#13;&#10;        assertTrue(H2ORM.tableExists(&quot;users&quot;));  // User entity uses @Table(name = &quot;users&quot;)&#13;&#10;        assertTrue(H2ORM.tableExists(&quot;products&quot;)); // Assuming Product entity uses @Table(name = &quot;products&quot;)&#13;&#10;        assertFalse(H2ORM.tableExists(&quot;nonexistent_table&quot;));&#13;&#10;&#13;&#10;        // Test table row counts&#13;&#10;        assertEquals(3, H2ORM.getTableRowCount(User.class));&#13;&#10;        assertEquals(2, H2ORM.getTableRowCount(Product.class));&#13;&#10;&#13;&#10;        // Test table info&#13;&#10;        TableManager.TableInfo userTableInfo = H2ORM.getTableInfo(User.class);&#13;&#10;        assertNotNull(userTableInfo);&#13;&#10;        assertEquals(&quot;users&quot;, userTableInfo.getTableName()); // Fix expected table name&#13;&#10;        assertTrue(userTableInfo.isExists());&#13;&#10;        assertEquals(3, userTableInfo.getRowCount());&#13;&#10;&#13;&#10;        // Test all table info&#13;&#10;        List&lt;TableManager.TableInfo&gt; allTables = H2ORM.getAllTableInfo();&#13;&#10;        assertTrue(allTables.size() &gt;= 2);&#13;&#10;        assertTrue(allTables.stream().anyMatch(table -&gt; &quot;users&quot;.equals(table.getTableName())));&#13;&#10;        assertTrue(allTables.stream().anyMatch(table -&gt; &quot;products&quot;.equals(table.getTableName())));&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    @Order(5)&#13;&#10;    @DisplayName(&quot;Test Advanced Repository Operations&quot;)&#13;&#10;    void testAdvancedRepositoryOperations() {&#13;&#10;        // Test findAllById&#13;&#10;        List&lt;User&gt; allUsers = userRepo.findAll();&#13;&#10;        List&lt;Long&gt; userIds = allUsers.stream().map(User::getId).limit(2).toList();&#13;&#10;        List&lt;User&gt; foundUsers = userRepo.findAllById(userIds);&#13;&#10;        assertEquals(2, foundUsers.size());&#13;&#10;&#13;&#10;        // Test saveAndFlush&#13;&#10;        User newUser = new User(&quot;test_user&quot;, &quot;test@example.com&quot;, &quot;Test User&quot;);&#13;&#10;        User savedUser = userRepo.saveAndFlush(newUser);&#13;&#10;        assertNotNull(savedUser.getId());&#13;&#10;        assertEquals(&quot;Test User&quot;, savedUser.getFullName());&#13;&#10;&#13;&#10;        // Test batch operations&#13;&#10;        List&lt;User&gt; batchUsers = List.of(&#13;&#10;                new User(&quot;batch1&quot;, &quot;batch1@example.com&quot;, &quot;Batch User 1&quot;),&#13;&#10;                new User(&quot;batch2&quot;, &quot;batch2@example.com&quot;, &quot;Batch User 2&quot;)&#13;&#10;        );&#13;&#10;        List&lt;User&gt; savedBatchUsers = userRepo.saveAllAndFlush(batchUsers);&#13;&#10;        assertEquals(2, savedBatchUsers.size());&#13;&#10;        assertEquals(6, userRepo.count()); // 3 original + 1 test + 2 batch&#13;&#10;&#13;&#10;        // Test deleteAllById&#13;&#10;        List&lt;Long&gt; batchIds = savedBatchUsers.stream().map(User::getId).toList();&#13;&#10;        userRepo.deleteAllById(batchIds);&#13;&#10;        assertEquals(4, userRepo.count()); // 3 original + 1 test&#13;&#10;&#13;&#10;        // Cleanup&#13;&#10;        userRepo.delete(savedUser);&#13;&#10;        assertEquals(3, userRepo.count());&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    @Order(6)&#13;&#10;    @DisplayName(&quot;Test Export Functionality&quot;)&#13;&#10;    void testExportFunctionality() {&#13;&#10;        assertDoesNotThrow(() -&gt; {&#13;&#10;            // Test CSV export&#13;&#10;            H2ORM.exportToCsv(User.class, &quot;./test-exports/users.csv&quot;);&#13;&#10;&#13;&#10;            // Test Excel export&#13;&#10;            H2ORM.exportToExcel(User.class, &quot;./test-exports/users.xlsx&quot;);&#13;&#10;&#13;&#10;            // Test JSON export&#13;&#10;            H2ORM.exportToJson(User.class, &quot;./test-exports/users.json&quot;);&#13;&#10;&#13;&#10;            // Test export with specific data - filter by active users&#13;&#10;            List&lt;User&gt; activeUsers = userRepo.findAll().stream()&#13;&#10;                    .filter(user -&gt; user.getIsActive() != null &amp;&amp; user.getIsActive())&#13;&#10;                    .toList();&#13;&#10;            H2ORM.exportToCsv(activeUsers, &quot;./test-exports/active_users.csv&quot;);&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    @Order(7)&#13;&#10;    @DisplayName(&quot;Test Sort Edge Cases&quot;)&#13;&#10;    void testSortEdgeCases() {&#13;&#10;        // Test unsorted&#13;&#10;        Sort unsorted = Sort.unsorted();&#13;&#10;        assertTrue(unsorted.isUnsorted());&#13;&#10;        assertFalse(unsorted.isSorted());&#13;&#10;&#13;&#10;        // Test empty sort&#13;&#10;        List&lt;User&gt; unsortedUsers = userRepo.findAll(unsorted);&#13;&#10;        assertEquals(3, unsortedUsers.size());&#13;&#10;&#13;&#10;        // Test sort by non-existent field (should not crash)&#13;&#10;        assertDoesNotThrow(() -&gt; {&#13;&#10;            userRepo.findAll(Sort.by(&quot;nonExistentField&quot;));&#13;&#10;        });&#13;&#10;&#13;&#10;        // Test null handling&#13;&#10;        Sort.Order orderWithNulls = Sort.Order.asc(&quot;fullName&quot;).nullsLast();&#13;&#10;        assertEquals(Sort.NullHandling.NULLS_LAST, orderWithNulls.getNullHandling());&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    @Order(8)&#13;&#10;    @DisplayName(&quot;Test PageRequest Edge Cases&quot;)&#13;&#10;    void testPageRequestEdgeCases() {&#13;&#10;        // Test invalid page parameters&#13;&#10;        assertThrows(IllegalArgumentException.class, () -&gt; PageRequest.of(-1, 10));&#13;&#10;        assertThrows(IllegalArgumentException.class, () -&gt; PageRequest.of(0, 0));&#13;&#10;&#13;&#10;        // Test large page size&#13;&#10;        Page&lt;User&gt; largePage = userRepo.findAll(PageRequest.of(0, 100));&#13;&#10;        assertEquals(3, largePage.getNumberOfElements());&#13;&#10;        assertEquals(1, largePage.getTotalPages());&#13;&#10;&#13;&#10;        // Test page beyond data&#13;&#10;        Page&lt;User&gt; emptyPage = userRepo.findAll(PageRequest.of(10, 10));&#13;&#10;        assertEquals(0, emptyPage.getNumberOfElements());&#13;&#10;        assertTrue(emptyPage.getContent().isEmpty());&#13;&#10;&#13;&#10;        // Test withPage method&#13;&#10;        PageRequest original = PageRequest.of(0, 2);&#13;&#10;        Pageable modified = original.withPage(1);&#13;&#10;        assertEquals(1, modified.getPageNumber());&#13;&#10;        assertEquals(2, modified.getPageSize());&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    @Order(9)&#13;&#10;    @DisplayName(&quot;Test Transaction Management&quot;)&#13;&#10;    void testTransactionManagement() {&#13;&#10;        // Test that operations work correctly within transactions&#13;&#10;        long initialCount = userRepo.count();&#13;&#10;&#13;&#10;        // This should work (save operation in transaction)&#13;&#10;        User newUser = new User(&quot;trans_test&quot;, &quot;transaction@example.com&quot;, &quot;Transaction Test&quot;);&#13;&#10;        User savedUser = userRepo.save(newUser);&#13;&#10;        assertNotNull(savedUser.getId());&#13;&#10;        assertEquals(initialCount + 1, userRepo.count());&#13;&#10;&#13;&#10;        // Cleanup&#13;&#10;        userRepo.delete(savedUser);&#13;&#10;        assertEquals(initialCount, userRepo.count());&#13;&#10;    }&#13;&#10;&#13;&#10;    @Test&#13;&#10;    @Order(10)&#13;&#10;    @DisplayName(&quot;Test H2ORM Lifecycle&quot;)&#13;&#10;    void testH2ORMLifecycle() {&#13;&#10;        // Test that H2ORM is running&#13;&#10;        assertTrue(H2ORM.isRunning());&#13;&#10;&#13;&#10;        // Test repository creation&#13;&#10;        JpaRepository&lt;User, Long&gt; newUserRepo = H2ORM.repository(User.class);&#13;&#10;        assertNotNull(newUserRepo);&#13;&#10;&#13;&#10;        // Test that repositories work&#13;&#10;        assertEquals(3, newUserRepo.count());&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>