<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/LIBRARY_SETUP_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/LIBRARY_SETUP_GUIDE.md" />
              <option name="updatedContent" value="# H2-ORM Standalone Library Setup Guide&#10;&#10;##  Quick Start&#10;&#10;H2-ORM is now a standalone JPA library that works exactly like Spring Boot JPA - no handlers needed!&#10;&#10;### 1. Add to Your Project&#10;&#10;**Maven:**&#10;```xml&#10;&lt;dependency&gt;&#10;    &lt;groupId&gt;com.h2.orm&lt;/groupId&gt;&#10;    &lt;artifactId&gt;H2-ORM&lt;/artifactId&gt;&#10;    &lt;version&gt;v0.0.1&lt;/version&gt;&#10;&lt;/dependency&gt;&#10;```&#10;&#10;**Gradle:**&#10;```groovy&#10;implementation 'com.h2.orm:H2-ORM:v0.0.1'&#10;```&#10;&#10;### 2. Create Entities (Just Like Spring Boot)&#10;&#10;```java&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false, unique = true)&#10;    private String username;&#10;    &#10;    @Column(nullable = false)&#10;    private String email;&#10;    &#10;    // constructors, getters, setters...&#10;}&#10;```&#10;&#10;### 3. Initialize Database &amp; Use Repositories&#10;&#10;```java&#10;public class MyApp {&#10;    public static void main(String[] args) {&#10;        // Initialize database (like @SpringBootApplication)&#10;        EntityManagerProvider.initialize();&#10;        // or: EntityManagerProvider.initialize(DatabaseConfiguration.h2File(&quot;./data/myapp&quot;));&#10;        &#10;        // Get repository (like @Autowired)&#10;        JpaRepository&lt;User, Long&gt; userRepo = Repositories.of(User.class);&#10;        &#10;        // Use it exactly like Spring Boot JPA!&#10;        User user = new User(&quot;john&quot;, &quot;john@example.com&quot;);&#10;        userRepo.save(user);&#10;        &#10;        Optional&lt;User&gt; found = userRepo.findById(1L);&#10;        List&lt;User&gt; all = userRepo.findAll();&#10;        long count = userRepo.count();&#10;        &#10;        // Cleanup&#10;        EntityManagerProvider.shutdown();&#10;    }&#10;}&#10;```&#10;&#10;## ️ Configuration Options&#10;&#10;### Database Types&#10;&#10;```java&#10;// H2 In-Memory (Default)&#10;EntityManagerProvider.initialize();&#10;&#10;// H2 File-Based&#10;EntityManagerProvider.initialize(DatabaseConfiguration.h2File(&quot;./data/mydb&quot;));&#10;&#10;// SQLite&#10;EntityManagerProvider.initialize(DatabaseConfiguration.sqlite(&quot;./data/mydb.db&quot;));&#10;&#10;// MySQL&#10;EntityManagerProvider.initialize(&#10;    DatabaseConfiguration.mysql(&quot;localhost&quot;, 3306, &quot;mydb&quot;, &quot;user&quot;, &quot;pass&quot;)&#10;);&#10;&#10;// PostgreSQL&#10;EntityManagerProvider.initialize(&#10;    DatabaseConfiguration.postgresql(&quot;localhost&quot;, 5432, &quot;mydb&quot;, &quot;user&quot;, &quot;pass&quot;)&#10;);&#10;```&#10;&#10;### Properties File Configuration&#10;&#10;Create `h2-orm.properties`:&#10;```properties&#10;h2orm.database.type=h2&#10;h2orm.database.mode=file&#10;h2orm.database.path=./data/myapp&#10;h2orm.jpa.ddl.auto=update&#10;h2orm.jpa.show.sql=true&#10;```&#10;&#10;Then:&#10;```java&#10;EntityManagerProvider.initialize(&quot;h2-orm.properties&quot;);&#10;```&#10;&#10;### XML Configuration&#10;&#10;Create `h2-orm-config.xml`:&#10;```xml&#10;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&#10;&lt;properties&gt;&#10;    &lt;entry key=&quot;h2orm.database.type&quot;&gt;h2&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.database.mode&quot;&gt;file&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.database.path&quot;&gt;./data/myapp&lt;/entry&gt;&#10;&lt;/properties&gt;&#10;```&#10;&#10;### Fluent Configuration&#10;&#10;```java&#10;DatabaseConfiguration config = DatabaseConfigBuilder.create()&#10;    .h2()&#10;    .fileBased()&#10;    .path(&quot;./data/myapp&quot;)&#10;    .showSql(true)&#10;    .enableCache()&#10;    .poolSize(20)&#10;    .build();&#10;&#10;EntityManagerProvider.initialize(config);&#10;```&#10;&#10;##  Repository Methods (All Spring Data JPA Methods)&#10;&#10;```java&#10;JpaRepository&lt;User, Long&gt; repo = Repositories.of(User.class);&#10;&#10;// Basic CRUD&#10;User saved = repo.save(user);&#10;List&lt;User&gt; saved = repo.saveAll(userList);&#10;Optional&lt;User&gt; found = repo.findById(1L);&#10;List&lt;User&gt; all = repo.findAll();&#10;List&lt;User&gt; some = repo.findAllById(Arrays.asList(1L, 2L, 3L));&#10;boolean exists = repo.existsById(1L);&#10;long count = repo.count();&#10;&#10;// Deletion&#10;repo.deleteById(1L);&#10;repo.delete(user);&#10;repo.deleteAll(userList);&#10;repo.deleteAllById(Arrays.asList(1L, 2L));&#10;repo.deleteAll();&#10;&#10;// Advanced operations&#10;repo.flush();&#10;User saved = repo.saveAndFlush(user);&#10;List&lt;User&gt; saved = repo.saveAllAndFlush(userList);&#10;repo.deleteInBatch(userList);&#10;repo.deleteAllInBatch();&#10;User reference = repo.getReferenceById(1L);&#10;```&#10;&#10;##  Advanced Features&#10;&#10;### Custom Repositories&#10;&#10;```java&#10;// Define custom repository interface&#10;interface UserRepository extends JpaRepository&lt;User, Long&gt; {&#10;    // Inherit all standard methods&#10;    // Add custom methods if needed&#10;}&#10;&#10;// Use it&#10;UserRepository userRepo = (UserRepository) Repositories.of(User.class);&#10;```&#10;&#10;### Transaction Management&#10;&#10;```java&#10;// Automatic transactions (recommended)&#10;User result = EntityManagerProvider.executeInTransaction(em -&gt; {&#10;    User user = new User(&quot;john&quot;, &quot;john@example.com&quot;);&#10;    em.persist(user);&#10;    return user;&#10;});&#10;&#10;// Manual transaction control&#10;EntityManager em = EntityManagerProvider.getEntityManager();&#10;try {&#10;    em.getTransaction().begin();&#10;    // your operations&#10;    em.getTransaction().commit();&#10;} finally {&#10;    EntityManagerProvider.closeEntityManager();&#10;}&#10;```&#10;&#10;### Export Features&#10;&#10;```java&#10;ExportService exportService = new ExportService();&#10;&#10;// Export to CSV&#10;List&lt;User&gt; users = userRepo.findAll();&#10;exportService.exportToCsv(users, &quot;users.csv&quot;);&#10;&#10;// Export to Excel&#10;exportService.exportToExcel(users, &quot;users.xlsx&quot;);&#10;&#10;// Export to JSON&#10;exportService.exportToJson(users, &quot;users.json&quot;);&#10;```&#10;&#10;### Backup Features&#10;&#10;```java&#10;BackupService backupService = new BackupService();&#10;&#10;// Create backup&#10;backupService.createBackup(&quot;./backups/myapp_backup&quot;);&#10;&#10;// Restore backup&#10;backupService.restoreBackup(&quot;./backups/myapp_backup_20240101_120000.sql&quot;);&#10;&#10;// Compressed backup&#10;backupService.createCompressedBackup(&quot;./backups/myapp_backup&quot;);&#10;```&#10;&#10;##  Key Differences from Handlers&#10;&#10;### ❌ Old Way (with handlers):&#10;```java&#10;ModernJpaDatabaseHandler handler = new ModernJpaDatabaseHandler();&#10;handler.save(user);&#10;List&lt;User&gt; users = handler.findAll(User.class);&#10;```&#10;&#10;### ✅ New Way (Spring Boot style):&#10;```java&#10;JpaRepository&lt;User, Long&gt; userRepo = Repositories.of(User.class);&#10;userRepo.save(user);&#10;List&lt;User&gt; users = userRepo.findAll();&#10;```&#10;&#10;##  Configuration Properties Reference&#10;&#10;| Property | Default | Description |&#10;|----------|---------|-------------|&#10;| `h2orm.database.type` | `h2` | Database type (h2, sqlite, mysql, postgresql) |&#10;| `h2orm.database.mode` | `file` | H2 mode (file, memory) |&#10;| `h2orm.database.path` | `./data/h2orm` | Database file path |&#10;| `h2orm.jpa.ddl.auto` | `update` | Schema generation (create, update, validate, none) |&#10;| `h2orm.jpa.show.sql` | `false` | Show SQL statements |&#10;| `h2orm.pool.size` | `10` | Connection pool size |&#10;&#10;##  Migration from Old Version&#10;&#10;1. Replace handler initialization:&#10;   ```java&#10;   // Old&#10;   ModernJpaDatabaseHandler handler = new ModernJpaDatabaseHandler();&#10;   &#10;   // New&#10;   EntityManagerProvider.initialize();&#10;   JpaRepository&lt;User, Long&gt; userRepo = Repositories.of(User.class);&#10;   ```&#10;&#10;2. Replace method calls:&#10;   ```java&#10;   // Old&#10;   handler.save(user);&#10;   handler.findAll(User.class);&#10;   &#10;   // New&#10;   userRepo.save(user);&#10;   userRepo.findAll();&#10;   ```&#10;&#10;3. Keep your entities unchanged - they work as-is!&#10;&#10;##  You're Ready!&#10;&#10;Your H2-ORM library now works exactly like Spring Boot JPA. No more handlers needed - just pure, clean JPA repository pattern!" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/EntityManagerProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/EntityManagerProvider.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.config.DatabaseProperties;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Enhanced EntityManager Provider for H2-ORM library&#10; * Supports H2, SQLite, MySQL, PostgreSQL with advanced configuration management&#10; */&#10;public class EntityManagerProvider {&#10;    private static final Logger logger = LoggerFactory.getLogger(EntityManagerProvider.class);&#10;    private static final Map&lt;String, EntityManagerFactory&gt; factories = new ConcurrentHashMap&lt;&gt;();&#10;    private static final ThreadLocal&lt;EntityManager&gt; entityManagerThreadLocal = new ThreadLocal&lt;&gt;();&#10;    private static String defaultConfigName = &quot;default&quot;;&#10;    private static DatabaseConfiguration currentConfig;&#10;&#10;    /**&#10;     * Initialize with default configuration from properties&#10;     */&#10;    public static void initialize() {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromProperties();&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with custom properties file&#10;     */&#10;    public static void initialize(String propertiesFile) {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with specific configuration&#10;     */&#10;    public static void initialize(DatabaseConfiguration config) {&#10;        initialize(defaultConfigName, config);&#10;        currentConfig = config;&#10;    }&#10;&#10;    /**&#10;     * Initialize with named configuration for multi-database support&#10;     */&#10;    public static void initialize(String configName, DatabaseConfiguration config) {&#10;        EntityManagerFactory existingFactory = factories.get(configName);&#10;        if (existingFactory != null &amp;&amp; existingFactory.isOpen()) {&#10;            existingFactory.close();&#10;        }&#10;&#10;        try {&#10;            Map&lt;String, Object&gt; properties = buildJpaProperties(config);&#10;&#10;            logger.info(&quot;Initializing EntityManagerFactory for config: {} with database: {}&quot;,&#10;                    configName, config.getUrl());&#10;&#10;            EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;h2-orm-pu&quot;, properties);&#10;            factories.put(configName, factory);&#10;&#10;            logger.info(&quot;EntityManagerFactory initialized successfully for config: {}&quot;, configName);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to initialize EntityManagerFactory for config: {}&quot;, configName, e);&#10;            throw new RuntimeException(&quot;Failed to initialize database connection&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for default configuration&#10;     */&#10;    public static EntityManager getEntityManager() {&#10;        return getEntityManager(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for named configuration&#10;     */&#10;    public static EntityManager getEntityManager(String configName) {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em == null || !em.isOpen()) {&#10;            EntityManagerFactory factory = factories.get(configName);&#10;            if (factory == null) {&#10;                throw new IllegalStateException(&quot;EntityManagerFactory not initialized for config: &quot; + configName);&#10;            }&#10;            em = factory.createEntityManager();&#10;            entityManagerThreadLocal.set(em);&#10;        }&#10;        return em;&#10;    }&#10;&#10;    /**&#10;     * Close current thread's EntityManager&#10;     */&#10;    public static void closeEntityManager() {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em != null &amp;&amp; em.isOpen()) {&#10;            try {&#10;                if (em.getTransaction().isActive()) {&#10;                    em.getTransaction().rollback();&#10;                }&#10;                em.close();&#10;            } catch (Exception e) {&#10;                logger.warn(&quot;Error closing EntityManager&quot;, e);&#10;            } finally {&#10;                entityManagerThreadLocal.remove();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(TransactionCallback&lt;T&gt; callback) {&#10;        return executeInTransaction(defaultConfigName, callback);&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, TransactionCallback&lt;T&gt; callback) {&#10;        EntityManager em = getEntityManager(configName);&#10;        try {&#10;            em.getTransaction().begin();&#10;            T result = callback.execute(em);&#10;            em.getTransaction().commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;            }&#10;            throw new RuntimeException(&quot;Transaction failed&quot;, e);&#10;        } finally {&#10;            closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown all EntityManagerFactories&#10;     */&#10;    public static void shutdown() {&#10;        closeEntityManager();&#10;        factories.values().forEach(factory -&gt; {&#10;            if (factory.isOpen()) {&#10;                try {&#10;                    factory.close();&#10;                } catch (Exception e) {&#10;                    logger.warn(&quot;Error closing EntityManagerFactory&quot;, e);&#10;                }&#10;            }&#10;        });&#10;        factories.clear();&#10;        logger.info(&quot;All EntityManagerFactories shut down&quot;);&#10;    }&#10;&#10;    /**&#10;     * Check if provider is initialized&#10;     */&#10;    public static boolean isInitialized() {&#10;        return isInitialized(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Check if named configuration is initialized&#10;     */&#10;    public static boolean isInitialized(String configName) {&#10;        EntityManagerFactory factory = factories.get(configName);&#10;        return factory != null &amp;&amp; factory.isOpen();&#10;    }&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public static DatabaseConfiguration getCurrentConfiguration() {&#10;        return currentConfig;&#10;    }&#10;&#10;    private static Map&lt;String, Object&gt; buildJpaProperties(DatabaseConfiguration config) {&#10;        Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();&#10;&#10;        // Basic connection properties&#10;        properties.put(&quot;jakarta.persistence.jdbc.driver&quot;, config.getDriverClass());&#10;        properties.put(&quot;jakarta.persistence.jdbc.url&quot;, config.getUrl());&#10;        properties.put(&quot;jakarta.persistence.jdbc.user&quot;, config.getUsername());&#10;        properties.put(&quot;jakarta.persistence.jdbc.password&quot;, config.getPassword());&#10;&#10;        // Hibernate specific properties&#10;        properties.put(&quot;hibernate.dialect&quot;, config.getDialect());&#10;        properties.put(&quot;hibernate.hbm2ddl.auto&quot;, config.getDdlAuto());&#10;        properties.put(&quot;hibernate.show_sql&quot;, String.valueOf(config.isShowSql()));&#10;        properties.put(&quot;hibernate.format_sql&quot;, String.valueOf(config.isFormatSql()));&#10;        properties.put(&quot;hibernate.use_sql_comments&quot;, &quot;true&quot;);&#10;&#10;        // Connection pool settings (HikariCP)&#10;        properties.put(&quot;hibernate.connection.provider_class&quot;, &quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;);&#10;        properties.put(&quot;hibernate.hikari.maximumPoolSize&quot;, String.valueOf(config.getPoolSize()));&#10;        properties.put(&quot;hibernate.hikari.minimumIdle&quot;, String.valueOf(config.getMinimumIdle()));&#10;        properties.put(&quot;hibernate.hikari.connectionTimeout&quot;, String.valueOf(config.getConnectionTimeout()));&#10;        properties.put(&quot;hibernate.hikari.idleTimeout&quot;, String.valueOf(config.getIdleTimeout()));&#10;        properties.put(&quot;hibernate.hikari.maxLifetime&quot;, String.valueOf(config.getMaxLifetime()));&#10;        properties.put(&quot;hibernate.hikari.poolName&quot;, config.getPoolName());&#10;&#10;        // Performance settings&#10;        properties.put(&quot;hibernate.jdbc.batch_size&quot;, String.valueOf(config.getBatchSize()));&#10;        properties.put(&quot;hibernate.order_inserts&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.order_updates&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.jdbc.batch_versioned_data&quot;, &quot;true&quot;);&#10;&#10;        // Cache settings - Disable caching by default for simplicity&#10;        properties.put(&quot;hibernate.cache.use_second_level_cache&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.cache.use_query_cache&quot;, &quot;false&quot;);&#10;&#10;        if (config.isUseSecondLevelCache()) {&#10;            // Use Hibernate's built-in cache instead of JCache&#10;            properties.put(&quot;hibernate.cache.region.factory_class&quot;, &quot;org.hibernate.cache.internal.NoCacheRegionFactory&quot;);&#10;        }&#10;&#10;        // Additional optimizations&#10;        properties.put(&quot;hibernate.connection.autocommit&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.jdbc.lob.non_contextual_creation&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.temp.use_jdbc_metadata_defaults&quot;, &quot;false&quot;);&#10;&#10;        return properties;&#10;    }&#10;&#10;    /**&#10;     * Functional interface for transaction callbacks&#10;     */&#10;    @FunctionalInterface&#10;    public interface TransactionCallback&lt;T&gt; {&#10;        T execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.config.DatabaseProperties;&#10;import h2.orm.exception.DatabaseNotInitializedException;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Enhanced EntityManager Provider for H2-ORM library&#10; * Supports H2, SQLite, MySQL, PostgreSQL with advanced configuration management&#10; */&#10;public class EntityManagerProvider {&#10;    private static final Logger logger = LoggerFactory.getLogger(EntityManagerProvider.class);&#10;    private static final Map&lt;String, EntityManagerFactory&gt; factories = new ConcurrentHashMap&lt;&gt;();&#10;    private static final ThreadLocal&lt;EntityManager&gt; entityManagerThreadLocal = new ThreadLocal&lt;&gt;();&#10;    private static String defaultConfigName = &quot;default&quot;;&#10;    private static DatabaseConfiguration currentConfig;&#10;&#10;    /**&#10;     * Initialize with default configuration from properties&#10;     */&#10;    public static void initialize() {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromProperties();&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with custom properties file&#10;     */&#10;    public static void initialize(String propertiesFile) {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with specific configuration&#10;     */&#10;    public static void initialize(DatabaseConfiguration config) {&#10;        initialize(defaultConfigName, config);&#10;        currentConfig = config;&#10;    }&#10;&#10;    /**&#10;     * Initialize with named configuration for multi-database support&#10;     */&#10;    public static void initialize(String configName, DatabaseConfiguration config) {&#10;        EntityManagerFactory existingFactory = factories.get(configName);&#10;        if (existingFactory != null &amp;&amp; existingFactory.isOpen()) {&#10;            existingFactory.close();&#10;        }&#10;&#10;        try {&#10;            Map&lt;String, Object&gt; properties = buildJpaProperties(config);&#10;&#10;            logger.info(&quot;Initializing EntityManagerFactory for config: {} with database: {}&quot;,&#10;                    configName, config.getUrl());&#10;&#10;            EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;h2-orm-pu&quot;, properties);&#10;            factories.put(configName, factory);&#10;&#10;            logger.info(&quot;EntityManagerFactory initialized successfully for config: {}&quot;, configName);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to initialize EntityManagerFactory for config: {}&quot;, configName, e);&#10;            throw new RuntimeException(&quot;Failed to initialize database connection&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for default configuration&#10;     */&#10;    public static EntityManager getEntityManager() {&#10;        return getEntityManager(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for named configuration&#10;     */&#10;    public static EntityManager getEntityManager(String configName) {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em == null || !em.isOpen()) {&#10;            EntityManagerFactory factory = factories.get(configName);&#10;            if (factory == null) {&#10;                throw new DatabaseNotInitializedException();&#10;            }&#10;            em = factory.createEntityManager();&#10;            entityManagerThreadLocal.set(em);&#10;        }&#10;        return em;&#10;    }&#10;&#10;    /**&#10;     * Close current thread's EntityManager&#10;     */&#10;    public static void closeEntityManager() {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em != null &amp;&amp; em.isOpen()) {&#10;            try {&#10;                if (em.getTransaction().isActive()) {&#10;                    em.getTransaction().rollback();&#10;                }&#10;                em.close();&#10;            } catch (Exception e) {&#10;                logger.warn(&quot;Error closing EntityManager&quot;, e);&#10;            } finally {&#10;                entityManagerThreadLocal.remove();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(TransactionCallback&lt;T&gt; callback) {&#10;        return executeInTransaction(defaultConfigName, callback);&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, TransactionCallback&lt;T&gt; callback) {&#10;        EntityManager em = getEntityManager(configName);&#10;        try {&#10;            em.getTransaction().begin();&#10;            T result = callback.execute(em);&#10;            em.getTransaction().commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;            }&#10;            throw new RuntimeException(&quot;Transaction failed&quot;, e);&#10;        } finally {&#10;            closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown all EntityManagerFactories&#10;     */&#10;    public static void shutdown() {&#10;        closeEntityManager();&#10;        factories.values().forEach(factory -&gt; {&#10;            if (factory.isOpen()) {&#10;                try {&#10;                    factory.close();&#10;                } catch (Exception e) {&#10;                    logger.warn(&quot;Error closing EntityManagerFactory&quot;, e);&#10;                }&#10;            }&#10;        });&#10;        factories.clear();&#10;        logger.info(&quot;All EntityManagerFactories shut down&quot;);&#10;    }&#10;&#10;    /**&#10;     * Check if provider is initialized&#10;     */&#10;    public static boolean isInitialized() {&#10;        return isInitialized(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Check if named configuration is initialized&#10;     */&#10;    public static boolean isInitialized(String configName) {&#10;        EntityManagerFactory factory = factories.get(configName);&#10;        return factory != null &amp;&amp; factory.isOpen();&#10;    }&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public static DatabaseConfiguration getCurrentConfiguration() {&#10;        return currentConfig;&#10;    }&#10;&#10;    private static Map&lt;String, Object&gt; buildJpaProperties(DatabaseConfiguration config) {&#10;        Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();&#10;&#10;        // Basic connection properties&#10;        properties.put(&quot;jakarta.persistence.jdbc.driver&quot;, config.getDriverClass());&#10;        properties.put(&quot;jakarta.persistence.jdbc.url&quot;, config.getUrl());&#10;        properties.put(&quot;jakarta.persistence.jdbc.user&quot;, config.getUsername());&#10;        properties.put(&quot;jakarta.persistence.jdbc.password&quot;, config.getPassword());&#10;&#10;        // Hibernate specific properties&#10;        properties.put(&quot;hibernate.dialect&quot;, config.getDialect());&#10;        properties.put(&quot;hibernate.hbm2ddl.auto&quot;, config.getDdlAuto());&#10;        properties.put(&quot;hibernate.show_sql&quot;, String.valueOf(config.isShowSql()));&#10;        properties.put(&quot;hibernate.format_sql&quot;, String.valueOf(config.isFormatSql()));&#10;        properties.put(&quot;hibernate.use_sql_comments&quot;, &quot;true&quot;);&#10;&#10;        // Connection pool settings (HikariCP)&#10;        properties.put(&quot;hibernate.connection.provider_class&quot;, &quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;);&#10;        properties.put(&quot;hibernate.hikari.maximumPoolSize&quot;, String.valueOf(config.getPoolSize()));&#10;        properties.put(&quot;hibernate.hikari.minimumIdle&quot;, String.valueOf(config.getMinimumIdle()));&#10;        properties.put(&quot;hibernate.hikari.connectionTimeout&quot;, String.valueOf(config.getConnectionTimeout()));&#10;        properties.put(&quot;hibernate.hikari.idleTimeout&quot;, String.valueOf(config.getIdleTimeout()));&#10;        properties.put(&quot;hibernate.hikari.maxLifetime&quot;, String.valueOf(config.getMaxLifetime()));&#10;        properties.put(&quot;hibernate.hikari.poolName&quot;, config.getPoolName());&#10;&#10;        // Performance settings&#10;        properties.put(&quot;hibernate.jdbc.batch_size&quot;, String.valueOf(config.getBatchSize()));&#10;        properties.put(&quot;hibernate.order_inserts&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.order_updates&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.jdbc.batch_versioned_data&quot;, &quot;true&quot;);&#10;&#10;        // Cache settings - Disable caching by default for simplicity&#10;        properties.put(&quot;hibernate.cache.use_second_level_cache&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.cache.use_query_cache&quot;, &quot;false&quot;);&#10;&#10;        if (config.isUseSecondLevelCache()) {&#10;            // Use Hibernate's built-in cache instead of JCache&#10;            properties.put(&quot;hibernate.cache.region.factory_class&quot;, &quot;org.hibernate.cache.internal.NoCacheRegionFactory&quot;);&#10;        }&#10;&#10;        // Additional optimizations&#10;        properties.put(&quot;hibernate.connection.autocommit&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.jdbc.lob.non_contextual_creation&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.temp.use_jdbc_metadata_defaults&quot;, &quot;false&quot;);&#10;&#10;        return properties;&#10;    }&#10;&#10;    /**&#10;     * Functional interface for transaction callbacks&#10;     */&#10;    @FunctionalInterface&#10;    public interface TransactionCallback&lt;T&gt; {&#10;        T execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/H2ORM.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/H2ORM.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.core.EntityManagerProvider;&#10;import h2.orm.repository.JpaRepository;&#10;import h2.orm.repository.Repositories;&#10;&#10;/**&#10; * Main entry point for H2-ORM library - makes it super easy to use!&#10; *&#10; * Usage:&#10; * 1. H2ORM.start() - Initialize with defaults&#10; * 2. H2ORM.repository(EntityClass.class) - Get repository&#10; * 3. Use repository methods like Spring Boot JPA&#10; * 4. H2ORM.stop() - Clean shutdown&#10; */&#10;public class H2ORM {&#10;&#10;    /**&#10;     * Start H2-ORM with default H2 in-memory database&#10;     */&#10;    public static void start() {&#10;        EntityManagerProvider.initialize(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Start H2-ORM with H2 file-based database&#10;     */&#10;    public static void start(String databasePath) {&#10;        EntityManagerProvider.initialize(DatabaseConfiguration.h2File(databasePath));&#10;    }&#10;&#10;    /**&#10;     * Start H2-ORM with custom configuration&#10;     */&#10;    public static void start(DatabaseConfiguration config) {&#10;        EntityManagerProvider.initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Start H2-ORM from properties file&#10;     */&#10;    public static void startFromProperties(String propertiesFile) {&#10;        EntityManagerProvider.initialize(propertiesFile);&#10;    }&#10;&#10;    /**&#10;     * Get repository for entity class - exactly like Spring Boot @Autowired&#10;     */&#10;    public static &lt;T, ID extends java.io.Serializable&gt; JpaRepository&lt;T, ID&gt; repository(Class&lt;T&gt; entityClass) {&#10;        return Repositories.of(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Stop H2-ORM and cleanup resources&#10;     */&#10;    public static void stop() {&#10;        EntityManagerProvider.shutdown();&#10;    }&#10;&#10;    /**&#10;     * Check if H2-ORM is running&#10;     */&#10;    public static boolean isRunning() {&#10;        return EntityManagerProvider.isInitialized();&#10;    }&#10;&#10;    // Quick setup methods for different databases&#10;&#10;    /**&#10;     * Start with H2 in-memory database (perfect for testing)&#10;     */&#10;    public static void startInMemory() {&#10;        start(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Start with SQLite database&#10;     */&#10;    public static void startSQLite(String dbPath) {&#10;        start(DatabaseConfiguration.sqlite(dbPath));&#10;    }&#10;&#10;    /**&#10;     * Start with MySQL database&#10;     */&#10;    public static void startMySQL(String host, int port, String database, String username, String password) {&#10;        start(DatabaseConfiguration.mysql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Start with PostgreSQL database&#10;     */&#10;    public static void startPostgreSQL(String host, int port, String database, String username, String password) {&#10;        start(DatabaseConfiguration.postgresql(host, port, database, username, password));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.core.DatabaseInitializer;&#10;import h2.orm.repository.JpaRepository;&#10;import h2.orm.repository.Repositories;&#10;&#10;/**&#10; * Main entry point for H2-ORM library - makes it super easy to use!&#10; *&#10; * Usage:&#10; * 1. H2ORM.start() - Initialize with defaults&#10; * 2. H2ORM.repository(EntityClass.class) - Get repository&#10; * 3. Use repository methods like Spring Boot JPA&#10; * 4. H2ORM.stop() - Clean shutdown&#10; */&#10;public class H2ORM {&#10;&#10;    /**&#10;     * Start H2-ORM with default H2 in-memory database&#10;     */&#10;    public static void start() {&#10;        DatabaseInitializer.initialize(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Start H2-ORM with H2 file-based database&#10;     */&#10;    public static void start(String databasePath) {&#10;        DatabaseInitializer.initialize(DatabaseConfiguration.h2File(databasePath));&#10;    }&#10;&#10;    /**&#10;     * Start H2-ORM with custom configuration&#10;     */&#10;    public static void start(DatabaseConfiguration config) {&#10;        DatabaseInitializer.initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Start H2-ORM from properties file&#10;     */&#10;    public static void startFromProperties(String propertiesFile) {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#10;        DatabaseInitializer.initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Get repository for entity class - exactly like Spring Boot @Autowired&#10;     */&#10;    public static &lt;T, ID extends java.io.Serializable&gt; JpaRepository&lt;T, ID&gt; repository(Class&lt;T&gt; entityClass) {&#10;        return Repositories.of(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Stop H2-ORM and cleanup resources&#10;     */&#10;    public static void stop() {&#10;        DatabaseInitializer.shutdown();&#10;    }&#10;&#10;    /**&#10;     * Check if H2-ORM is running&#10;     */&#10;    public static boolean isRunning() {&#10;        return h2.orm.core.EntityManagerProvider.isInitialized();&#10;    }&#10;&#10;    // Quick setup methods for different databases&#10;&#10;    /**&#10;     * Start with H2 in-memory database (perfect for testing)&#10;     */&#10;    public static void startInMemory() {&#10;        start(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Start with SQLite database&#10;     */&#10;    public static void startSQLite(String dbPath) {&#10;        start(DatabaseConfiguration.sqlite(dbPath));&#10;    }&#10;&#10;    /**&#10;     * Start with MySQL database&#10;     */&#10;    public static void startMySQL(String host, int port, String database, String username, String password) {&#10;        start(DatabaseConfiguration.mysql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Start with PostgreSQL database&#10;     */&#10;    public static void startPostgreSQL(String host, int port, String database, String username, String password) {&#10;        start(DatabaseConfiguration.postgresql(host, port, database, username, password));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/JpaAdvancedDatabaseHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/JpaAdvancedDatabaseHandler.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.open.autobot.database.jpa.repository.AbstractRepository;&#10;import com.open.autobot.database.jpa.repository.Repository;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.Query;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Modern JPA-based Database Handler&#10; * High-performance replacement for the original H2DatabaseHandler&#10; * Supports H2, MySQL, PostgreSQL, SQLite and other JPA-compatible databases&#10; */&#10;public class JpaAdvancedDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(JpaAdvancedDatabaseHandler.class);&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;    private final Map&lt;Class&lt;?&gt;, Repository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Initialize the database with configuration&#10;     */&#10;    public void initialize(DatabaseConfig config) {&#10;        EntityManagerProvider.initialize(config);&#10;        logger.info(&quot;JPA Advanced Database Handler initialized successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Get or create repository for entity class&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T, ID extends Serializable&gt; Repository&lt;T, ID&gt; getRepository(Class&lt;T&gt; entityClass) {&#10;        return (Repository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, clazz -&gt;&#10;            new GenericRepository&lt;&gt;((Class&lt;T&gt;) clazz)&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        return repo.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save multiple entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return new ArrayList&lt;&gt;();&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        return repo.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findAll();&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findAll(offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByAttribute(Class&lt;T&gt; entityClass, String attributeName, Object value) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByAttribute(attributeName, value);&#10;    }&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByNativeQuery(Class&lt;T&gt; entityClass, String sqlQuery, Object... params) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByNativeQuery(sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByQuery(Class&lt;T&gt; entityClass, String jpqlQuery, Object... params) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.findByQuery(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.count();&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean existsById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.existsById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    public &lt;T&gt; boolean existsByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        return repo.existsByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        return repo.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteById((Serializable) id);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entity.getClass());&#10;        repo.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    public &lt;T&gt; void deleteAll(Class&lt;T&gt; entityClass) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteAll();&#10;    }&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    public &lt;T&gt; void deleteByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        Repository&lt;T, Serializable&gt; repo = getRepository(entityClass);&#10;        repo.deleteByCriteria(criteria);&#10;    }&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    public int executeUpdate(String jpqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            Query query = em.createQuery(jpqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            int result = query.executeUpdate();&#10;            tx.commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to execute update query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Execute update operation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    public int executeNativeUpdate(String sqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            Query query = em.createNativeQuery(sqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            int result = query.executeUpdate();&#10;            tx.commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to execute native update query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Execute native update operation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Batch insert entities for high performance&#10;     */&#10;    public &lt;T&gt; void batchInsert(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return;&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        repo.batchInsert(entities);&#10;    }&#10;&#10;    /**&#10;     * Batch update entities for high performance&#10;     */&#10;    public &lt;T&gt; void batchUpdate(List&lt;T&gt; entities) {&#10;        if (entities.isEmpty()) return;&#10;        Repository&lt;T, Serializable&gt; repo = getRepository((Class&lt;T&gt;) entities.get(0).getClass());&#10;        repo.batchUpdate(entities);&#10;    }&#10;&#10;    /**&#10;     * Create database schema/tables&#10;     */&#10;    public void createSchema() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            // Schema creation is handled by JPA/Hibernate automatically&#10;            // based on the ddl-auto configuration&#10;            tx.commit();&#10;            logger.info(&quot;Database schema created/updated successfully&quot;);&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to create schema: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Schema creation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Drop all tables&#10;     */&#10;    public void dropSchema() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin();&#10;            em.createNativeQuery(&quot;DROP ALL OBJECTS&quot;).executeUpdate();&#10;            tx.commit();&#10;            logger.info(&quot;Database schema dropped successfully&quot;);&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) {&#10;                tx.rollback();&#10;            }&#10;            logger.error(&quot;Failed to drop schema: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Schema drop failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get database version&#10;     */&#10;    public String getVersion() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(&quot;SELECT VERSION()&quot;);&#10;            Object result = query.getSingleResult();&#10;            return result != null ? result.toString() : &quot;Unknown&quot;;&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Could not retrieve database version: {}&quot;, e.getMessage());&#10;            return &quot;Unknown&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute custom SQL query and return raw results&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomQuery(String sqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            @SuppressWarnings(&quot;unchecked&quot;)&#10;            List&lt;Object[]&gt; results = query.getResultList();&#10;            return results;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to execute custom query: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Custom query execution failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query and return raw results&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomJpql(String jpqlQuery, Object... params) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createQuery(jpqlQuery);&#10;&#10;            for (int i = 0; i &lt; params.length; i++) {&#10;                query.setParameter(i + 1, params[i]);&#10;            }&#10;&#10;            @SuppressWarnings(&quot;unchecked&quot;)&#10;            List&lt;Object[]&gt; results = query.getResultList();&#10;            return results;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to execute custom JPQL: {}&quot;, e.getMessage());&#10;            throw new RuntimeException(&quot;Custom JPQL execution failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown the database handler&#10;     */&#10;    public void shutdown() {&#10;        EntityManagerProvider.shutdown();&#10;        logger.info(&quot;JPA Advanced Database Handler shutdown completed&quot;);&#10;    }&#10;&#10;    /**&#10;     * Generic Repository Implementation&#10;     */&#10;    private static class GenericRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;&#10;        public GenericRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;&#10;        // getEntityClass() method is inherited from AbstractRepository&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import h2.orm.repository.AbstractRepository;&#10;import h2.orm.repository.Repository;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;import jakarta.persistence.Query;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Advanced JPA-based Database Handler for H2-ORM Standalone Library&#10; * High-performance replacement for traditional database handlers&#10; * Supports H2, MySQL, PostgreSQL, SQLite and other JPA-compatible databases&#10; */&#10;public class JpaAdvancedDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(JpaAdvancedDatabaseHandler.class);&#10;    private final ObjectMapper objectMapper = new ObjectMapper();&#10;    private final Map&lt;Class&lt;?&gt;, Repository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get or create repository for entity class&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T, ID extends Serializable&gt; Repository&lt;T, ID&gt; getRepository(Class&lt;T&gt; entityClass) {&#10;        return (Repository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, clazz -&gt;&#10;            new GenericRepository&lt;&gt;((Class&lt;T&gt;) clazz)&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            em.persist(entity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity saved: {}&quot;, entity.getClass().getSimpleName());&#10;            return entity;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Save all entities in batch&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        if (entities == null || entities.isEmpty()) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;            int batchSize = 20; // Default batch size&#10;            &#10;            for (int i = 0; i &lt; entities.size(); i++) {&#10;                T entity = entities.get(i);&#10;                em.persist(entity);&#10;                savedEntities.add(entity);&#10;                &#10;                if (i % batchSize == 0 &amp;&amp; i &gt; 0) {&#10;                    em.flush();&#10;                    em.clear();&#10;                }&#10;            }&#10;            &#10;            em.flush();&#10;            logger.debug(&quot;Batch saved {} entities&quot;, entities.size());&#10;            return savedEntities;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T updated = em.merge(entity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity updated: {}&quot;, entity.getClass().getSimpleName());&#10;            return updated;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Delete an entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;            em.remove(managedEntity);&#10;            em.flush();&#10;            logger.debug(&quot;Entity deleted: {}&quot;, entity.getClass().getSimpleName());&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            T entity = em.find(entityClass, id);&#10;            if (entity != null) {&#10;                em.remove(entity);&#10;                em.flush();&#10;                logger.debug(&quot;Entity deleted by ID: {} - {}&quot;, entityClass.getSimpleName(), id);&#10;            }&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            T entity = em.find(entityClass, id);&#10;            return Optional.ofNullable(entity);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find all entities of a given class&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(root);&#10;            &#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(root);&#10;            &#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            typedQuery.setFirstResult(offset);&#10;            typedQuery.setMaxResults(limit);&#10;            &#10;            return typedQuery.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Count entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            CriteriaBuilder cb = em.getCriteriaBuilder();&#10;            CriteriaQuery&lt;Long&gt; query = cb.createQuery(Long.class);&#10;            Root&lt;T&gt; root = query.from(entityClass);&#10;            query.select(cb.count(root));&#10;            &#10;            TypedQuery&lt;Long&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getSingleResult();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean exists(Class&lt;T&gt; entityClass, Object id) {&#10;        return findById(entityClass, id).isPresent();&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            TypedQuery&lt;T&gt; query = em.createQuery(jpql, resultClass);&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            TypedQuery&lt;T&gt; query = em.createQuery(jpql, resultClass);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sql, resultClass);&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query with parameters&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sql, resultClass);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.getResultList();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute update query&#10;     */&#10;    public int executeUpdate(String jpql) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            Query query = em.createQuery(jpql);&#10;            return query.executeUpdate();&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute update query with parameters&#10;     */&#10;    public int executeUpdate(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            Query query = em.createQuery(jpql);&#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            return query.executeUpdate();&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Clear entity manager cache&#10;     */&#10;    public void clearCache() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            em.clear();&#10;            logger.debug(&quot;Entity manager cache cleared&quot;);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Flush pending changes&#10;     */&#10;    public void flush() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            em.flush();&#10;            logger.debug(&quot;Entity manager flushed&quot;);&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generic Repository Implementation&#10;     */&#10;    private static class GenericRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;        &#10;        public GenericRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;        &#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/ModernJpaDatabaseHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/ModernJpaDatabaseHandler.java" />
              <option name="originalContent" value="package h2.orm;&#10;&#10;import com.open.autobot.database.jpa.service.BackupService;&#10;import com.open.autobot.database.jpa.service.ChatService;&#10;import com.open.autobot.database.jpa.service.ExportService;&#10;import com.open.autobot.model.Conversation;&#10;import com.open.autobot.model.Message;&#10;import com.open.autobot.model.SenderRole;&#10;import jakarta.persistence.EntityManager;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Modern JPA Advanced Database Handler&#10; *&#10; * A complete replacement for H2DatabaseHandler with modern JPA architecture&#10; * Features:&#10; * - High-performance JPA operations with connection pooling&#10; * - Support for H2, MySQL, PostgreSQL, SQLite&#10; * - Comprehensive CRUD operations&#10; * - Chat system with conversations and messages&#10; * - Backup and restore functionality&#10; * - Export to CSV, Excel, JSON&#10; * - Batch operations for optimal performance&#10; * - Transaction management&#10; * - Query caching and optimization&#10; *&#10; * Usage:&#10; * 1. Initialize with database configuration&#10; * 2. Use save(), findAll(), findById() etc. for basic operations&#10; * 3. Use chat methods for conversation management&#10; * 4. Use backup methods for data protection&#10; * 5. Use export methods for data analysis&#10; */&#10;public class ModernJpaDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(ModernJpaDatabaseHandler.class);&#10;&#10;    private final JpaAdvancedDatabaseHandler coreHandler;&#10;    private final ChatService chatService;&#10;    private final BackupService backupService;&#10;    private final ExportService exportService;&#10;&#10;    /**&#10;     * Constructor - Initialize with H2 database (default)&#10;     */&#10;    public ModernJpaDatabaseHandler() {&#10;        this(DatabaseConfig.h2());&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with custom database configuration&#10;     */&#10;    public ModernJpaDatabaseHandler(DatabaseConfig config) {&#10;        this.coreHandler = new JpaAdvancedDatabaseHandler();&#10;        this.chatService = new ChatService();&#10;        this.backupService = new BackupService();&#10;        this.exportService = new ExportService();&#10;&#10;        // Initialize the database&#10;        this.coreHandler.initialize(config);&#10;&#10;        logger.info(&quot;Modern JPA Database Handler initialized with {}&quot;,&#10;                   config.getUrl().contains(&quot;h2&quot;) ? &quot;H2&quot; :&#10;                   config.getUrl().contains(&quot;mysql&quot;) ? &quot;MySQL&quot; :&#10;                   config.getUrl().contains(&quot;postgresql&quot;) ? &quot;PostgreSQL&quot; : &quot;Other database&quot;);&#10;    }&#10;&#10;    // =====================&#10;    // CORE CRUD OPERATIONS&#10;    // =====================&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return coreHandler.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save multiple entities with batch optimization&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        return coreHandler.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.findById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.findAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Find all entities with pagination (high performance for large datasets)&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        return coreHandler.findAll(entityClass, offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByAttribute(Class&lt;T&gt; entityClass, String attributeName, Object value) {&#10;        return coreHandler.findByAttribute(entityClass, attributeName, value);&#10;    }&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        return coreHandler.findByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByNativeQuery(Class&lt;T&gt; entityClass, String sqlQuery, Object... params) {&#10;        return coreHandler.findByNativeQuery(entityClass, sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findByQuery(Class&lt;T&gt; entityClass, String jpqlQuery, Object... params) {&#10;        return coreHandler.findByQuery(entityClass, jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.count(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    public &lt;T&gt; boolean existsById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.existsById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    public &lt;T&gt; boolean existsByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        return coreHandler.existsByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Update an entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return coreHandler.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        coreHandler.deleteById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        coreHandler.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete all entities of a type&#10;     */&#10;    public &lt;T&gt; void deleteAll(Class&lt;T&gt; entityClass) {&#10;        coreHandler.deleteAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    public &lt;T&gt; void deleteByCriteria(Class&lt;T&gt; entityClass, Map&lt;String, Object&gt; criteria) {&#10;        coreHandler.deleteByCriteria(entityClass, criteria);&#10;    }&#10;&#10;    /**&#10;     * Batch insert for high performance&#10;     */&#10;    public &lt;T&gt; void batchInsert(List&lt;T&gt; entities) {&#10;        coreHandler.batchInsert(entities);&#10;    }&#10;&#10;    /**&#10;     * Batch update for high performance&#10;     */&#10;    public &lt;T&gt; void batchUpdate(List&lt;T&gt; entities) {&#10;        coreHandler.batchUpdate(entities);&#10;    }&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    public int executeUpdate(String jpqlQuery, Object... params) {&#10;        return coreHandler.executeUpdate(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    public int executeNativeUpdate(String sqlQuery, Object... params) {&#10;        return coreHandler.executeNativeUpdate(sqlQuery, params);&#10;    }&#10;&#10;    // =====================&#10;    // CHAT SYSTEM METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Initialize chat system (called automatically)&#10;     */&#10;    public void initializeChatTables() {&#10;        chatService.initializeChatTables();&#10;    }&#10;&#10;    /**&#10;     * Start a new conversation&#10;     */&#10;    public String startNewConversation(String userId, String title) {&#10;        return chatService.startNewConversation(userId, title);&#10;    }&#10;&#10;    /**&#10;     * Add message to conversation&#10;     */&#10;    public void addMessage(String conversationId, SenderRole role, String content) {&#10;        chatService.addMessage(conversationId, role, content);&#10;    }&#10;&#10;    /**&#10;     * Get conversation history&#10;     */&#10;    public List&lt;Message&gt; getConversationHistory(String conversationId) {&#10;        return chatService.getConversationHistory(conversationId);&#10;    }&#10;&#10;    /**&#10;     * List user conversations&#10;     */&#10;    public List&lt;Conversation&gt; listUserConversations(String userId) {&#10;        return chatService.listUserConversations(userId);&#10;    }&#10;&#10;    /**&#10;     * Rename conversation&#10;     */&#10;    public void renameConversation(String conversationId, String newTitle) {&#10;        chatService.renameConversation(conversationId, newTitle);&#10;    }&#10;&#10;    /**&#10;     * Delete conversation&#10;     */&#10;    public void deleteConversation(String conversationId) {&#10;        chatService.deleteConversation(conversationId);&#10;    }&#10;&#10;    /**&#10;     * Add simple chat message (legacy compatibility)&#10;     */&#10;    public void addChatMessage(String message) {&#10;        chatService.addChatMessage(message);&#10;    }&#10;&#10;    /**&#10;     * Load simple chat history (legacy compatibility)&#10;     */&#10;    public List&lt;String&gt; loadChatHistory() {&#10;        return chatService.loadChatHistory();&#10;    }&#10;&#10;    /**&#10;     * Clear simple chat history (legacy compatibility)&#10;     */&#10;    public void clearChatHistory() {&#10;        chatService.clearChatHistory();&#10;    }&#10;&#10;    // =====================&#10;    // BACKUP &amp; RESTORE METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Create backup of a table&#10;     */&#10;    public String backup(String tableName) {&#10;        return backupService.backup(tableName);&#10;    }&#10;&#10;    /**&#10;     * Create backup of all tables&#10;     */&#10;    public List&lt;String&gt; backupAll() {&#10;        return backupService.backupAll();&#10;    }&#10;&#10;    /**&#10;     * List backup tables&#10;     */&#10;    public List&lt;String&gt; listBackups(String baseTableName) {&#10;        return backupService.listBackups(baseTableName);&#10;    }&#10;&#10;    /**&#10;     * Restore table from backup&#10;     */&#10;    public boolean restore(String backupTableName, String targetTableName) {&#10;        return backupService.restore(backupTableName, targetTableName);&#10;    }&#10;&#10;    /**&#10;     * Delete backup table&#10;     */&#10;    public boolean deleteBackup(String backupTableName) {&#10;        return backupService.deleteBackup(backupTableName);&#10;    }&#10;&#10;    /**&#10;     * Schedule periodic backup&#10;     */&#10;    public void schedulePeriodicBackup(String tableName, long intervalMinutes) {&#10;        backupService.schedulePeriodicBackup(tableName, intervalMinutes);&#10;    }&#10;&#10;    /**&#10;     * Schedule periodic backup for all tables&#10;     */&#10;    public void schedulePeriodicBackupAll(long intervalMinutes) {&#10;        backupService.schedulePeriodicBackupAll(intervalMinutes);&#10;    }&#10;&#10;    /**&#10;     * Create database dump&#10;     */&#10;    public String createDatabaseDump(String filePath) {&#10;        return backupService.createDatabaseDump(filePath);&#10;    }&#10;&#10;    /**&#10;     * Restore from database dump&#10;     */&#10;    public boolean restoreFromDump(String filePath) {&#10;        return backupService.restoreFromDump(filePath);&#10;    }&#10;&#10;    // =====================&#10;    // EXPORT METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Export table to CSV&#10;     */&#10;    public void exportToCSV(String tableName, String filePath) {&#10;        exportService.exportToCSV(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export table to Excel&#10;     */&#10;    public void exportToExcel(String tableName, String filePath) {&#10;        exportService.exportToExcel(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export table to JSON&#10;     */&#10;    public void exportToJSON(String tableName, String filePath) {&#10;        exportService.exportToJSON(tableName, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export query results to CSV&#10;     */&#10;    public void exportQueryToCSV(String sqlQuery, String filePath, Object... params) {&#10;        exportService.exportQueryToCSV(sqlQuery, filePath, params);&#10;    }&#10;&#10;    /**&#10;     * Export multiple tables to Excel&#10;     */&#10;    public void exportMultipleTablesToExcel(List&lt;String&gt; tableNames, String filePath) {&#10;        exportService.exportMultipleTablesToExcel(tableNames, filePath);&#10;    }&#10;&#10;    /**&#10;     * Get database statistics&#10;     */&#10;    public Map&lt;String, Object&gt; getDatabaseStatistics() {&#10;        return exportService.getDatabaseStatistics();&#10;    }&#10;&#10;    /**&#10;     * Export database statistics to JSON&#10;     */&#10;    public void exportStatisticsToJSON(String filePath) {&#10;        exportService.exportStatisticsToJSON(filePath);&#10;    }&#10;&#10;    // =====================&#10;    // UTILITY METHODS&#10;    // =====================&#10;&#10;    /**&#10;     * Get database version&#10;     */&#10;    public String getVersion() {&#10;        return coreHandler.getVersion();&#10;    }&#10;&#10;    /**&#10;     * Execute custom SQL query&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomQuery(String sqlQuery, Object... params) {&#10;        return coreHandler.executeCustomQuery(sqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query&#10;     */&#10;    public List&lt;Object[]&gt; executeCustomJpql(String jpqlQuery, Object... params) {&#10;        return coreHandler.executeCustomJpql(jpqlQuery, params);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for advanced operations&#10;     */&#10;    public EntityManager getEntityManager() {&#10;        return EntityManagerProvider.getEntityManager();&#10;    }&#10;&#10;    /**&#10;     * Close current EntityManager&#10;     */&#10;    public void closeEntityManager() {&#10;        EntityManagerProvider.closeEntityManager();&#10;    }&#10;&#10;    /**&#10;     * Create database schema&#10;     */&#10;    public void createSchema() {&#10;        coreHandler.createSchema();&#10;    }&#10;&#10;    /**&#10;     * Drop database schema&#10;     */&#10;    public void dropSchema() {&#10;        coreHandler.dropSchema();&#10;    }&#10;&#10;    /**&#10;     * Shutdown the database handler&#10;     */&#10;    public void shutdown() {&#10;        try {&#10;            backupService.shutdown();&#10;            coreHandler.shutdown();&#10;            logger.info(&quot;Modern JPA Database Handler shutdown completed&quot;);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error during shutdown: {}&quot;, e.getMessage());&#10;        }&#10;    }&#10;&#10;    // =====================&#10;    // FACTORY METHODS FOR DIFFERENT DATABASES&#10;    // =====================&#10;&#10;    /**&#10;     * Create handler for H2 database&#10;     */&#10;    public static ModernJpaDatabaseHandler forH2() {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.h2());&#10;    }&#10;&#10;    /**&#10;     * Create handler for MySQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler forMySQL(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.mysql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Create handler for PostgreSQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler forPostgreSQL(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.postgresql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Create handler for SQLite database&#10;     */&#10;    public static ModernJpaDatabaseHandler forSQLite(String filePath) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfig.sqlite(filePath));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.service.BackupService;&#10;import h2.orm.service.ExportService;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.function.Consumer;&#10;&#10;/**&#10; * Modern JPA Database Handler for H2-ORM Standalone Library&#10; *&#10; * A complete JPA-based database handler with modern architecture&#10; * Features:&#10; * - High-performance JPA operations with connection pooling&#10; * - Support for H2, MySQL, PostgreSQL, SQLite&#10; * - Comprehensive CRUD operations&#10; * - Backup and restore functionality&#10; * - Export to CSV, Excel, JSON&#10; * - Batch operations for optimal performance&#10; * - Transaction management&#10; * - Query caching and optimization&#10; * - Easy integration as standalone library&#10; *&#10; * Usage:&#10; * 1. Initialize with database configuration&#10; * 2. Use save(), findAll(), findById() etc. for basic operations&#10; * 3. Use backup methods for data protection&#10; * 4. Use export methods for data analysis&#10; */&#10;public class ModernJpaDatabaseHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(ModernJpaDatabaseHandler.class);&#10;&#10;    private final JpaAdvancedDatabaseHandler coreHandler;&#10;    private final BackupService backupService;&#10;    private final ExportService exportService;&#10;    private final DatabaseConfiguration configuration;&#10;&#10;    /**&#10;     * Constructor - Initialize with default H2 configuration&#10;     */&#10;    public ModernJpaDatabaseHandler() {&#10;        this(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with H2 file-based database&#10;     */&#10;    public ModernJpaDatabaseHandler(String databasePath) {&#10;        this(DatabaseConfiguration.h2File(databasePath));&#10;    }&#10;&#10;    /**&#10;     * Constructor - Initialize with custom configuration&#10;     */&#10;    public ModernJpaDatabaseHandler(DatabaseConfiguration config) {&#10;        this.configuration = config;&#10;&#10;        logger.info(&quot;Initializing ModernJpaDatabaseHandler with configuration: {}&quot;, config);&#10;&#10;        // Initialize EntityManager Provider&#10;        EntityManagerProvider.initialize(config);&#10;&#10;        // Initialize core components&#10;        this.coreHandler = new JpaAdvancedDatabaseHandler();&#10;        this.backupService = new BackupService();&#10;        this.exportService = new ExportService();&#10;&#10;        logger.info(&quot;ModernJpaDatabaseHandler initialized successfully&quot;);&#10;    }&#10;&#10;    /**&#10;     * Factory method for H2 in-memory database&#10;     */&#10;    public static ModernJpaDatabaseHandler h2InMemory() {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.h2InMemory());&#10;    }&#10;&#10;    /**&#10;     * Factory method for H2 file-based database&#10;     */&#10;    public static ModernJpaDatabaseHandler h2File(String path) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.h2File(path));&#10;    }&#10;&#10;    /**&#10;     * Factory method for SQLite database&#10;     */&#10;    public static ModernJpaDatabaseHandler sqlite(String path) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.sqlite(path));&#10;    }&#10;&#10;    /**&#10;     * Factory method for MySQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler mysql(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.mysql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Factory method for PostgreSQL database&#10;     */&#10;    public static ModernJpaDatabaseHandler postgresql(String host, int port, String database, String username, String password) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.postgresql(host, port, database, username, password));&#10;    }&#10;&#10;    /**&#10;     * Factory method from properties file&#10;     */&#10;    public static ModernJpaDatabaseHandler fromProperties(String propertiesFile) {&#10;        return new ModernJpaDatabaseHandler(DatabaseConfiguration.fromPropertiesFile(propertiesFile));&#10;    }&#10;&#10;    // ===== CRUD Operations =====&#10;&#10;    /**&#10;     * Save entity&#10;     */&#10;    public &lt;T&gt; T save(T entity) {&#10;        return coreHandler.save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save entity with validation&#10;     */&#10;    public &lt;T&gt; T save(T entity, Consumer&lt;T&gt; validator) {&#10;        if (validator != null) {&#10;            validator.accept(entity);&#10;        }&#10;        return save(entity);&#10;    }&#10;&#10;    /**&#10;     * Save all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; saveAll(List&lt;T&gt; entities) {&#10;        return coreHandler.saveAll(entities);&#10;    }&#10;&#10;    /**&#10;     * Update entity&#10;     */&#10;    public &lt;T&gt; T update(T entity) {&#10;        return coreHandler.update(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    public &lt;T&gt; void delete(T entity) {&#10;        coreHandler.delete(entity);&#10;    }&#10;&#10;    /**&#10;     * Delete by ID&#10;     */&#10;    public &lt;T&gt; void deleteById(Class&lt;T&gt; entityClass, Object id) {&#10;        coreHandler.deleteById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find by ID&#10;     */&#10;    public &lt;T&gt; Optional&lt;T&gt; findById(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.findById(entityClass, id);&#10;    }&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.findAll(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Find with pagination&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; findAll(Class&lt;T&gt; entityClass, int offset, int limit) {&#10;        return coreHandler.findAll(entityClass, offset, limit);&#10;    }&#10;&#10;    /**&#10;     * Count entities&#10;     */&#10;    public &lt;T&gt; long count(Class&lt;T&gt; entityClass) {&#10;        return coreHandler.count(entityClass);&#10;    }&#10;&#10;    /**&#10;     * Check if entity exists&#10;     */&#10;    public &lt;T&gt; boolean exists(Class&lt;T&gt; entityClass, Object id) {&#10;        return coreHandler.exists(entityClass, id);&#10;    }&#10;&#10;    // ===== Query Operations =====&#10;&#10;    /**&#10;     * Execute JPQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass) {&#10;        return coreHandler.query(jpql, resultClass);&#10;    }&#10;&#10;    /**&#10;     * Execute JPQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; query(String jpql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.query(jpql, resultClass, parameters);&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass) {&#10;        return coreHandler.nativeQuery(sql, resultClass);&#10;    }&#10;&#10;    /**&#10;     * Execute native SQL query with parameters&#10;     */&#10;    public &lt;T&gt; List&lt;T&gt; nativeQuery(String sql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.nativeQuery(sql, resultClass, parameters);&#10;    }&#10;&#10;    /**&#10;     * Execute update query&#10;     */&#10;    public int executeUpdate(String jpql) {&#10;        return coreHandler.executeUpdate(jpql);&#10;    }&#10;&#10;    /**&#10;     * Execute update query with parameters&#10;     */&#10;    public int executeUpdate(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return coreHandler.executeUpdate(jpql, parameters);&#10;    }&#10;&#10;    // ===== Criteria API =====&#10;&#10;    /**&#10;     * Create criteria query builder&#10;     */&#10;    public &lt;T&gt; CriteriaQueryBuilder&lt;T&gt; criteriaBuilder(Class&lt;T&gt; entityClass) {&#10;        return new CriteriaQueryBuilder&lt;&gt;(entityClass);&#10;    }&#10;&#10;    // ===== Transaction Management =====&#10;&#10;    /**&#10;     * Execute in transaction&#10;     */&#10;    public &lt;T&gt; T executeInTransaction(EntityManagerProvider.TransactionCallback&lt;T&gt; callback) {&#10;        return EntityManagerProvider.executeInTransaction(callback);&#10;    }&#10;&#10;    /**&#10;     * Execute without result in transaction&#10;     */&#10;    public void executeInTransaction(TransactionCallback callback) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            callback.execute(em);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    // ===== Export Operations =====&#10;&#10;    /**&#10;     * Export to CSV&#10;     */&#10;    public &lt;T&gt; void exportToCsv(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToCsv(data, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export to Excel&#10;     */&#10;    public &lt;T&gt; void exportToExcel(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToExcel(data, filePath);&#10;    }&#10;&#10;    /**&#10;     * Export to JSON&#10;     */&#10;    public &lt;T&gt; void exportToJson(Class&lt;T&gt; entityClass, String filePath) {&#10;        List&lt;T&gt; data = findAll(entityClass);&#10;        exportService.exportToJson(data, filePath);&#10;    }&#10;&#10;    // ===== Backup Operations =====&#10;&#10;    /**&#10;     * Create database backup&#10;     */&#10;    public void backup(String backupPath) {&#10;        backupService.createBackup(backupPath);&#10;    }&#10;&#10;    /**&#10;     * Restore database from backup&#10;     */&#10;    public void restore(String backupPath) {&#10;        backupService.restoreBackup(backupPath);&#10;    }&#10;&#10;    // ===== Utility Methods =====&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public DatabaseConfiguration getConfiguration() {&#10;        return configuration;&#10;    }&#10;&#10;    /**&#10;     * Check if handler is initialized&#10;     */&#10;    public boolean isInitialized() {&#10;        return EntityManagerProvider.isInitialized();&#10;    }&#10;&#10;    /**&#10;     * Shutdown handler and cleanup resources&#10;     */&#10;    public void shutdown() {&#10;        logger.info(&quot;Shutting down ModernJpaDatabaseHandler&quot;);&#10;        EntityManagerProvider.shutdown();&#10;        logger.info(&quot;ModernJpaDatabaseHandler shutdown completed&quot;);&#10;    }&#10;&#10;    // ===== Inner Classes =====&#10;&#10;    /**&#10;     * Criteria Query Builder for type-safe queries&#10;     */&#10;    public class CriteriaQueryBuilder&lt;T&gt; {&#10;        private final Class&lt;T&gt; entityClass;&#10;        private final CriteriaBuilder criteriaBuilder;&#10;        private final CriteriaQuery&lt;T&gt; query;&#10;        private final Root&lt;T&gt; root;&#10;&#10;        public CriteriaQueryBuilder(Class&lt;T&gt; entityClass) {&#10;            this.entityClass = entityClass;&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            this.criteriaBuilder = em.getCriteriaBuilder();&#10;            this.query = criteriaBuilder.createQuery(entityClass);&#10;            this.root = query.from(entityClass);&#10;        }&#10;&#10;        public CriteriaQueryBuilder&lt;T&gt; where(String fieldName, Object value) {&#10;            query.where(criteriaBuilder.equal(root.get(fieldName), value));&#10;            return this;&#10;        }&#10;&#10;        public CriteriaQueryBuilder&lt;T&gt; orderBy(String fieldName, boolean ascending) {&#10;            if (ascending) {&#10;                query.orderBy(criteriaBuilder.asc(root.get(fieldName)));&#10;            } else {&#10;                query.orderBy(criteriaBuilder.desc(root.get(fieldName)));&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public List&lt;T&gt; getResultList() {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            return typedQuery.getResultList();&#10;        }&#10;&#10;        public List&lt;T&gt; getResultList(int maxResults) {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;            typedQuery.setMaxResults(maxResults);&#10;            return typedQuery.getResultList();&#10;        }&#10;&#10;        public Optional&lt;T&gt; getSingleResult() {&#10;            List&lt;T&gt; results = getResultList(1);&#10;            return results.isEmpty() ? Optional.empty() : Optional.of(results.get(0));&#10;        }&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface TransactionCallback {&#10;        void execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/config/DatabaseConfigBuilder.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/config/DatabaseConfigBuilder.java" />
              <option name="updatedContent" value="package h2.orm.config;&#10;&#10;/**&#10; * Fluent configuration builder for H2-ORM database setup&#10; * Integrates with DatabaseProperties for flexible configuration management&#10; */&#10;public class DatabaseConfigBuilder {&#10;    private final DatabaseProperties properties;&#10;    private String databaseType;&#10;    private String mode;&#10;    private String path;&#10;    private String host;&#10;    private Integer port;&#10;    private String databaseName;&#10;    private String username;&#10;    private String password;&#10;    private String ddlAuto;&#10;    private Boolean showSql;&#10;    private Boolean formatSql;&#10;    private Integer poolSize;&#10;    private Integer batchSize;&#10;    private Boolean useSecondLevelCache;&#10;    private Boolean useQueryCache;&#10;    &#10;    public DatabaseConfigBuilder() {&#10;        this.properties = DatabaseProperties.getInstance();&#10;    }&#10;    &#10;    public static DatabaseConfigBuilder create() {&#10;        return new DatabaseConfigBuilder();&#10;    }&#10;    &#10;    public static DatabaseConfigBuilder fromProperties() {&#10;        return new DatabaseConfigBuilder().loadFromProperties();&#10;    }&#10;    &#10;    public static DatabaseConfigBuilder fromPropertiesFile(String filename) {&#10;        return new DatabaseConfigBuilder()&#10;                .loadFromPropertiesFile(filename)&#10;                .loadFromProperties();&#10;    }&#10;    &#10;    public DatabaseConfigBuilder loadFromPropertiesFile(String filename) {&#10;        properties.loadFromFile(filename);&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder loadFromProperties() {&#10;        this.databaseType = properties.getProperty(DatabaseProperties.Keys.DATABASE_TYPE);&#10;        this.mode = properties.getProperty(DatabaseProperties.Keys.DATABASE_MODE);&#10;        this.path = properties.getProperty(DatabaseProperties.Keys.DATABASE_PATH);&#10;        this.host = properties.getProperty(DatabaseProperties.Keys.DATABASE_HOST);&#10;        this.databaseName = properties.getProperty(DatabaseProperties.Keys.DATABASE_NAME);&#10;        this.username = properties.getProperty(DatabaseProperties.Keys.DATABASE_USERNAME);&#10;        this.password = properties.getProperty(DatabaseProperties.Keys.DATABASE_PASSWORD);&#10;        this.ddlAuto = properties.getProperty(DatabaseProperties.Keys.JPA_DDL_AUTO);&#10;        &#10;        String portStr = properties.getProperty(DatabaseProperties.Keys.DATABASE_PORT);&#10;        if (portStr != null) {&#10;            this.port = Integer.parseInt(portStr);&#10;        }&#10;        &#10;        this.showSql = properties.getBooleanProperty(DatabaseProperties.Keys.JPA_SHOW_SQL, false);&#10;        this.formatSql = properties.getBooleanProperty(DatabaseProperties.Keys.JPA_FORMAT_SQL, false);&#10;        this.poolSize = properties.getIntProperty(DatabaseProperties.Keys.POOL_SIZE, 10);&#10;        this.batchSize = properties.getIntProperty(DatabaseProperties.Keys.JPA_BATCH_SIZE, 20);&#10;        this.useSecondLevelCache = properties.getBooleanProperty(DatabaseProperties.Keys.JPA_CACHE_USE_SECOND_LEVEL, true);&#10;        this.useQueryCache = properties.getBooleanProperty(DatabaseProperties.Keys.JPA_CACHE_USE_QUERY, true);&#10;        &#10;        return this;&#10;    }&#10;    &#10;    // Fluent API methods&#10;    public DatabaseConfigBuilder h2() {&#10;        this.databaseType = &quot;h2&quot;;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder sqlite() {&#10;        this.databaseType = &quot;sqlite&quot;;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder mysql() {&#10;        this.databaseType = &quot;mysql&quot;;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder postgresql() {&#10;        this.databaseType = &quot;postgresql&quot;;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder inMemory() {&#10;        this.mode = &quot;memory&quot;;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder fileBased() {&#10;        this.mode = &quot;file&quot;;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder path(String path) {&#10;        this.path = path;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder host(String host) {&#10;        this.host = host;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder port(int port) {&#10;        this.port = port;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder database(String databaseName) {&#10;        this.databaseName = databaseName;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder credentials(String username, String password) {&#10;        this.username = username;&#10;        this.password = password;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder ddlAuto(String ddlAuto) {&#10;        this.ddlAuto = ddlAuto;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder showSql(boolean showSql) {&#10;        this.showSql = showSql;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder formatSql(boolean formatSql) {&#10;        this.formatSql = formatSql;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder poolSize(int poolSize) {&#10;        this.poolSize = poolSize;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder batchSize(int batchSize) {&#10;        this.batchSize = batchSize;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder enableCache() {&#10;        this.useSecondLevelCache = true;&#10;        this.useQueryCache = true;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfigBuilder disableCache() {&#10;        this.useSecondLevelCache = false;&#10;        this.useQueryCache = false;&#10;        return this;&#10;    }&#10;    &#10;    public DatabaseConfiguration build() {&#10;        DatabaseConfiguration config = new DatabaseConfiguration();&#10;        &#10;        // Set database type and connection details&#10;        String dbType = this.databaseType != null ? this.databaseType : &quot;h2&quot;;&#10;        String dbMode = this.mode != null ? this.mode : &quot;file&quot;;&#10;        &#10;        switch (dbType.toLowerCase()) {&#10;            case &quot;h2&quot;:&#10;                buildH2Config(config, dbMode);&#10;                break;&#10;            case &quot;sqlite&quot;:&#10;                buildSqliteConfig(config);&#10;                break;&#10;            case &quot;mysql&quot;:&#10;                buildMysqlConfig(config);&#10;                break;&#10;            case &quot;postgresql&quot;:&#10;                buildPostgresqlConfig(config);&#10;                break;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;Unsupported database type: &quot; + dbType);&#10;        }&#10;        &#10;        // Set common configuration&#10;        if (ddlAuto != null) config.setDdlAuto(ddlAuto);&#10;        if (showSql != null) config.setShowSql(showSql);&#10;        if (formatSql != null) config.setFormatSql(formatSql);&#10;        if (poolSize != null) config.setPoolSize(poolSize);&#10;        if (batchSize != null) config.setBatchSize(batchSize);&#10;        if (useSecondLevelCache != null) config.setUseSecondLevelCache(useSecondLevelCache);&#10;        if (useQueryCache != null) config.setUseQueryCache(useQueryCache);&#10;        &#10;        return config;&#10;    }&#10;    &#10;    private void buildH2Config(DatabaseConfiguration config, String mode) {&#10;        config.setDriverClass(&quot;org.h2.Driver&quot;);&#10;        config.setDialect(&quot;org.hibernate.dialect.H2Dialect&quot;);&#10;        &#10;        String dbPath = this.path != null ? this.path : &quot;./data/h2orm&quot;;&#10;        String url;&#10;        &#10;        if (&quot;memory&quot;.equals(mode)) {&#10;            url = &quot;jdbc:h2:mem:h2orm;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false&quot;;&#10;        } else {&#10;            url = String.format(&quot;jdbc:h2:%s;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false;AUTO_SERVER=TRUE&quot;, dbPath);&#10;        }&#10;        &#10;        config.setUrl(url);&#10;        config.setUsername(this.username != null ? this.username : &quot;sa&quot;);&#10;        config.setPassword(this.password != null ? this.password : &quot;&quot;);&#10;    }&#10;    &#10;    private void buildSqliteConfig(DatabaseConfiguration config) {&#10;        config.setDriverClass(&quot;org.sqlite.JDBC&quot;);&#10;        config.setDialect(&quot;org.hibernate.dialect.SQLiteDialect&quot;);&#10;        &#10;        String dbPath = this.path != null ? this.path : &quot;./data/h2orm.db&quot;;&#10;        config.setUrl(&quot;jdbc:sqlite:&quot; + dbPath);&#10;        config.setUsername(&quot;&quot;);&#10;        config.setPassword(&quot;&quot;);&#10;    }&#10;    &#10;    private void buildMysqlConfig(DatabaseConfiguration config) {&#10;        config.setDriverClass(&quot;com.mysql.cj.jdbc.Driver&quot;);&#10;        config.setDialect(&quot;org.hibernate.dialect.MySQL8Dialect&quot;);&#10;        &#10;        String host = this.host != null ? this.host : &quot;localhost&quot;;&#10;        int port = this.port != null ? this.port : 3306;&#10;        String database = this.databaseName != null ? this.databaseName : &quot;h2orm&quot;;&#10;        &#10;        String url = String.format(&quot;jdbc:mysql://%s:%d/%s?useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=true&quot;,&#10;                host, port, database);&#10;        &#10;        config.setUrl(url);&#10;        config.setUsername(this.username != null ? this.username : &quot;root&quot;);&#10;        config.setPassword(this.password != null ? this.password : &quot;&quot;);&#10;    }&#10;    &#10;    private void buildPostgresqlConfig(DatabaseConfiguration config) {&#10;        config.setDriverClass(&quot;org.postgresql.Driver&quot;);&#10;        config.setDialect(&quot;org.hibernate.dialect.PostgreSQL10Dialect&quot;);&#10;        &#10;        String host = this.host != null ? this.host : &quot;localhost&quot;;&#10;        int port = this.port != null ? this.port : 5432;&#10;        String database = this.databaseName != null ? this.databaseName : &quot;h2orm&quot;;&#10;        &#10;        String url = String.format(&quot;jdbc:postgresql://%s:%d/%s&quot;, host, port, database);&#10;        &#10;        config.setUrl(url);&#10;        config.setUsername(this.username != null ? this.username : &quot;postgres&quot;);&#10;        config.setPassword(this.password != null ? this.password : &quot;&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/config/DatabaseConfiguration.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/config/DatabaseConfiguration.java" />
              <option name="updatedContent" value="package h2.orm.config;&#10;&#10;/**&#10; * Enhanced database configuration class with comprehensive settings&#10; * for H2-ORM standalone library&#10; */&#10;public class DatabaseConfiguration {&#10;    private String driverClass;&#10;    private String url;&#10;    private String username;&#10;    private String password;&#10;    private String dialect;&#10;    private String ddlAuto = &quot;update&quot;;&#10;    private boolean showSql = false;&#10;    private boolean formatSql = false;&#10;    private int poolSize = 10;&#10;    private int batchSize = 20;&#10;    private boolean useSecondLevelCache = true;&#10;    private boolean useQueryCache = true;&#10;    private long connectionTimeout = 30000;&#10;    private long idleTimeout = 600000;&#10;    private long maxLifetime = 1800000;&#10;    private int minimumIdle = 5;&#10;    private String poolName = &quot;H2-ORM-Pool&quot;;&#10;    &#10;    // Default constructors&#10;    public DatabaseConfiguration() {}&#10;    &#10;    // Static factory methods for quick setup&#10;    public static DatabaseConfiguration h2InMemory() {&#10;        return DatabaseConfigBuilder.create()&#10;                .h2()&#10;                .inMemory()&#10;                .build();&#10;    }&#10;    &#10;    public static DatabaseConfiguration h2File(String path) {&#10;        return DatabaseConfigBuilder.create()&#10;                .h2()&#10;                .fileBased()&#10;                .path(path)&#10;                .build();&#10;    }&#10;    &#10;    public static DatabaseConfiguration sqlite(String path) {&#10;        return DatabaseConfigBuilder.create()&#10;                .sqlite()&#10;                .path(path)&#10;                .build();&#10;    }&#10;    &#10;    public static DatabaseConfiguration mysql(String host, int port, String database, String username, String password) {&#10;        return DatabaseConfigBuilder.create()&#10;                .mysql()&#10;                .host(host)&#10;                .port(port)&#10;                .database(database)&#10;                .credentials(username, password)&#10;                .build();&#10;    }&#10;    &#10;    public static DatabaseConfiguration postgresql(String host, int port, String database, String username, String password) {&#10;        return DatabaseConfigBuilder.create()&#10;                .postgresql()&#10;                .host(host)&#10;                .port(port)&#10;                .database(database)&#10;                .credentials(username, password)&#10;                .build();&#10;    }&#10;    &#10;    public static DatabaseConfiguration fromProperties() {&#10;        return DatabaseConfigBuilder.fromProperties().build();&#10;    }&#10;    &#10;    public static DatabaseConfiguration fromPropertiesFile(String filename) {&#10;        return DatabaseConfigBuilder.fromPropertiesFile(filename).build();&#10;    }&#10;    &#10;    // Getters and Setters&#10;    public String getDriverClass() {&#10;        return driverClass;&#10;    }&#10;    &#10;    public void setDriverClass(String driverClass) {&#10;        this.driverClass = driverClass;&#10;    }&#10;    &#10;    public String getUrl() {&#10;        return url;&#10;    }&#10;    &#10;    public void setUrl(String url) {&#10;        this.url = url;&#10;    }&#10;    &#10;    public String getUsername() {&#10;        return username;&#10;    }&#10;    &#10;    public void setUsername(String username) {&#10;        this.username = username;&#10;    }&#10;    &#10;    public String getPassword() {&#10;        return password;&#10;    }&#10;    &#10;    public void setPassword(String password) {&#10;        this.password = password;&#10;    }&#10;    &#10;    public String getDialect() {&#10;        return dialect;&#10;    }&#10;    &#10;    public void setDialect(String dialect) {&#10;        this.dialect = dialect;&#10;    }&#10;    &#10;    public String getDdlAuto() {&#10;        return ddlAuto;&#10;    }&#10;    &#10;    public void setDdlAuto(String ddlAuto) {&#10;        this.ddlAuto = ddlAuto;&#10;    }&#10;    &#10;    public boolean isShowSql() {&#10;        return showSql;&#10;    }&#10;    &#10;    public void setShowSql(boolean showSql) {&#10;        this.showSql = showSql;&#10;    }&#10;    &#10;    public boolean isFormatSql() {&#10;        return formatSql;&#10;    }&#10;    &#10;    public void setFormatSql(boolean formatSql) {&#10;        this.formatSql = formatSql;&#10;    }&#10;    &#10;    public int getPoolSize() {&#10;        return poolSize;&#10;    }&#10;    &#10;    public void setPoolSize(int poolSize) {&#10;        this.poolSize = poolSize;&#10;    }&#10;    &#10;    public int getBatchSize() {&#10;        return batchSize;&#10;    }&#10;    &#10;    public void setBatchSize(int batchSize) {&#10;        this.batchSize = batchSize;&#10;    }&#10;    &#10;    public boolean isUseSecondLevelCache() {&#10;        return useSecondLevelCache;&#10;    }&#10;    &#10;    public void setUseSecondLevelCache(boolean useSecondLevelCache) {&#10;        this.useSecondLevelCache = useSecondLevelCache;&#10;    }&#10;    &#10;    public boolean isUseQueryCache() {&#10;        return useQueryCache;&#10;    }&#10;    &#10;    public void setUseQueryCache(boolean useQueryCache) {&#10;        this.useQueryCache = useQueryCache;&#10;    }&#10;    &#10;    public long getConnectionTimeout() {&#10;        return connectionTimeout;&#10;    }&#10;    &#10;    public void setConnectionTimeout(long connectionTimeout) {&#10;        this.connectionTimeout = connectionTimeout;&#10;    }&#10;    &#10;    public long getIdleTimeout() {&#10;        return idleTimeout;&#10;    }&#10;    &#10;    public void setIdleTimeout(long idleTimeout) {&#10;        this.idleTimeout = idleTimeout;&#10;    }&#10;    &#10;    public long getMaxLifetime() {&#10;        return maxLifetime;&#10;    }&#10;    &#10;    public void setMaxLifetime(long maxLifetime) {&#10;        this.maxLifetime = maxLifetime;&#10;    }&#10;    &#10;    public int getMinimumIdle() {&#10;        return minimumIdle;&#10;    }&#10;    &#10;    public void setMinimumIdle(int minimumIdle) {&#10;        this.minimumIdle = minimumIdle;&#10;    }&#10;    &#10;    public String getPoolName() {&#10;        return poolName;&#10;    }&#10;    &#10;    public void setPoolName(String poolName) {&#10;        this.poolName = poolName;&#10;    }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        return &quot;DatabaseConfiguration{&quot; +&#10;                &quot;driverClass='&quot; + driverClass + '\'' +&#10;                &quot;, url='&quot; + url + '\'' +&#10;                &quot;, username='&quot; + username + '\'' +&#10;                &quot;, dialect='&quot; + dialect + '\'' +&#10;                &quot;, ddlAuto='&quot; + ddlAuto + '\'' +&#10;                &quot;, showSql=&quot; + showSql +&#10;                &quot;, formatSql=&quot; + formatSql +&#10;                &quot;, poolSize=&quot; + poolSize +&#10;                &quot;, batchSize=&quot; + batchSize +&#10;                &quot;, useSecondLevelCache=&quot; + useSecondLevelCache +&#10;                &quot;, useQueryCache=&quot; + useQueryCache +&#10;                '}';&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/config/DatabaseProperties.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/config/DatabaseProperties.java" />
              <option name="originalContent" value="&#10;import java.io.IOException;&#10;import java.io.InputStream;&#10;import java.util.Properties;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Centralized configuration manager for H2-ORM library&#10; * Supports both .properties files and XML configuration with override capabilities&#10; */&#10;public class DatabaseProperties {&#10;    private static final String DEFAULT_PROPERTIES_FILE = &quot;h2-orm.properties&quot;;&#10;    private static final String DEFAULT_XML_FILE = &quot;h2-orm-config.xml&quot;;&#10;    &#10;    private final Properties properties;&#10;    private final Map&lt;String, String&gt; overrides;&#10;    &#10;    private static DatabaseProperties instance;&#10;    &#10;    private DatabaseProperties() {&#10;        this.properties = new Properties();&#10;        this.overrides = new ConcurrentHashMap&lt;&gt;();&#10;        loadDefaultProperties();&#10;    }&#10;    &#10;    public static synchronized DatabaseProperties getInstance() {&#10;        if (instance == null) {&#10;            instance = new DatabaseProperties();&#10;        }&#10;        return instance;&#10;    }&#10;    &#10;    /**&#10;     * Load properties from custom file&#10;     */&#10;    public DatabaseProperties loadFromFile(String filename) {&#10;        try (InputStream is = getClass().getClassLoader().getResourceAsStream(filename)) {&#10;            if (is != null) {&#10;                if (filename.endsWith(&quot;.xml&quot;)) {&#10;                    properties.loadFromXML(is);&#10;                } else {&#10;                    properties.load(is);&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(&quot;Failed to load properties from: &quot; + filename, e);&#10;        }&#10;        return this;&#10;    }&#10;    &#10;    /**&#10;     * Override specific property programmatically&#10;     */&#10;    public DatabaseProperties override(String key, String value) {&#10;        overrides.put(key, value);&#10;        return this;&#10;    }&#10;    &#10;    /**&#10;     * Get property value with override support&#10;     */&#10;    public String getProperty(String key) {&#10;        return overrides.getOrDefault(key, properties.getProperty(key));&#10;    }&#10;    &#10;    /**&#10;     * Get property value with default fallback&#10;     */&#10;    public String getProperty(String key, String defaultValue) {&#10;        String value = getProperty(key);&#10;        return value != null ? value : defaultValue;&#10;    }&#10;    &#10;    /**&#10;     * Get boolean property&#10;     */&#10;    public boolean getBooleanProperty(String key, boolean defaultValue) {&#10;        String value = getProperty(key);&#10;        return value != null ? Boolean.parseBoolean(value) : defaultValue;&#10;    }&#10;    &#10;    /**&#10;     * Get integer property&#10;     */&#10;    public int getIntProperty(String key, int defaultValue) {&#10;        String value = getProperty(key);&#10;        try {&#10;            return value != null ? Integer.parseInt(value) : defaultValue;&#10;        } catch (NumberFormatException e) {&#10;            return defaultValue;&#10;        }&#10;    }&#10;    &#10;    private void loadDefaultProperties() {&#10;        // Set default values&#10;        properties.setProperty(&quot;h2orm.database.type&quot;, &quot;h2&quot;);&#10;        properties.setProperty(&quot;h2orm.database.mode&quot;, &quot;file&quot;); // file or memory&#10;        properties.setProperty(&quot;h2orm.database.path&quot;, &quot;./data/h2orm&quot;);&#10;        properties.setProperty(&quot;h2orm.database.username&quot;, &quot;sa&quot;);&#10;        properties.setProperty(&quot;h2orm.database.password&quot;, &quot;&quot;);&#10;        &#10;        // Connection pool settings&#10;        properties.setProperty(&quot;h2orm.pool.size&quot;, &quot;10&quot;);&#10;        properties.setProperty(&quot;h2orm.pool.timeout&quot;, &quot;30000&quot;);&#10;        properties.setProperty(&quot;h2orm.pool.idle.timeout&quot;, &quot;600000&quot;);&#10;        properties.setProperty(&quot;h2orm.pool.max.lifetime&quot;, &quot;1800000&quot;);&#10;        &#10;        // JPA/Hibernate settings&#10;        properties.setProperty(&quot;h2orm.jpa.ddl.auto&quot;, &quot;update&quot;);&#10;        properties.setProperty(&quot;h2orm.jpa.show.sql&quot;, &quot;false&quot;);&#10;        properties.setProperty(&quot;h2orm.jpa.format.sql&quot;, &quot;false&quot;);&#10;        properties.setProperty(&quot;h2orm.jpa.batch.size&quot;, &quot;20&quot;);&#10;        properties.setProperty(&quot;h2orm.jpa.cache.use.second.level&quot;, &quot;true&quot;);&#10;        properties.setProperty(&quot;h2orm.jpa.cache.use.query&quot;, &quot;true&quot;);&#10;        &#10;        // Export settings&#10;        properties.setProperty(&quot;h2orm.export.csv.delimiter&quot;, &quot;,&quot;);&#10;        properties.setProperty(&quot;h2orm.export.excel.sheet.name&quot;, &quot;Data&quot;);&#10;        properties.setProperty(&quot;h2orm.export.json.pretty.print&quot;, &quot;true&quot;);&#10;        &#10;        // Backup settings&#10;        properties.setProperty(&quot;h2orm.backup.auto.enabled&quot;, &quot;false&quot;);&#10;        properties.setProperty(&quot;h2orm.backup.interval.hours&quot;, &quot;24&quot;);&#10;        properties.setProperty(&quot;h2orm.backup.retention.days&quot;, &quot;7&quot;);&#10;        properties.setProperty(&quot;h2orm.backup.compression&quot;, &quot;true&quot;);&#10;        &#10;        // Monitoring settings&#10;        properties.setProperty(&quot;h2orm.monitoring.enabled&quot;, &quot;true&quot;);&#10;        properties.setProperty(&quot;h2orm.monitoring.query.log.enabled&quot;, &quot;false&quot;);&#10;        properties.setProperty(&quot;h2orm.monitoring.slow.query.threshold.ms&quot;, &quot;1000&quot;);&#10;        &#10;        // Try to load from default files&#10;        loadFromFile(DEFAULT_PROPERTIES_FILE);&#10;        loadFromFile(DEFAULT_XML_FILE);&#10;    }&#10;    &#10;    /**&#10;     * Database configuration keys&#10;     */&#10;    public static class Keys {&#10;        public static final String DATABASE_TYPE = &quot;h2orm.database.type&quot;;&#10;        public static final String DATABASE_MODE = &quot;h2orm.database.mode&quot;;&#10;        public static final String DATABASE_PATH = &quot;h2orm.database.path&quot;;&#10;        public static final String DATABASE_USERNAME = &quot;h2orm.database.username&quot;;&#10;        public static final String DATABASE_PASSWORD = &quot;h2orm.database.password&quot;;&#10;        public static final String DATABASE_HOST = &quot;h2orm.database.host&quot;;&#10;        public static final String DATABASE_PORT = &quot;h2orm.database.port&quot;;&#10;        public static final String DATABASE_NAME = &quot;h2orm.database.name&quot;;&#10;        &#10;        public static final String POOL_SIZE = &quot;h2orm.pool.size&quot;;&#10;        public static final String POOL_TIMEOUT = &quot;h2orm.pool.timeout&quot;;&#10;        public static final String POOL_IDLE_TIMEOUT = &quot;h2orm.pool.idle.timeout&quot;;&#10;        public static final String POOL_MAX_LIFETIME = &quot;h2orm.pool.max.lifetime&quot;;&#10;        &#10;        public static final String JPA_DDL_AUTO = &quot;h2orm.jpa.ddl.auto&quot;;&#10;        public static final String JPA_SHOW_SQL = &quot;h2orm.jpa.show.sql&quot;;&#10;        public static final String JPA_FORMAT_SQL = &quot;h2orm.jpa.format.sql&quot;;&#10;        public static final String JPA_BATCH_SIZE = &quot;h2orm.jpa.batch.size&quot;;&#10;        public static final String JPA_CACHE_USE_SECOND_LEVEL = &quot;h2orm.jpa.cache.use.second.level&quot;;&#10;        public static final String JPA_CACHE_USE_QUERY = &quot;h2orm.jpa.cache.use.query&quot;;&#10;    }&#10;}" />
              <option name="updatedContent" value="package h2.orm.config;&#10;&#10;import java.io.IOException;&#10;import java.io.InputStream;&#10;import java.util.Properties;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Centralized configuration manager for H2-ORM library&#10; * Supports both .properties files and XML configuration with override capabilities&#10; */&#10;public class DatabaseProperties {&#10;    private static final String DEFAULT_PROPERTIES_FILE = &quot;h2-orm.properties&quot;;&#10;    private static final String DEFAULT_XML_FILE = &quot;h2-orm-config.xml&quot;;&#10;    &#10;    private final Properties properties;&#10;    private final Map&lt;String, String&gt; overrides;&#10;    &#10;    private static DatabaseProperties instance;&#10;    &#10;    private DatabaseProperties() {&#10;        this.properties = new Properties();&#10;        this.overrides = new ConcurrentHashMap&lt;&gt;();&#10;        loadDefaultProperties();&#10;    }&#10;    &#10;    public static synchronized DatabaseProperties getInstance() {&#10;        if (instance == null) {&#10;            instance = new DatabaseProperties();&#10;        }&#10;        return instance;&#10;    }&#10;    &#10;    /**&#10;     * Load properties from custom file&#10;     */&#10;    public DatabaseProperties loadFromFile(String filename) {&#10;        try (InputStream is = getClass().getClassLoader().getResourceAsStream(filename)) {&#10;            if (is != null) {&#10;                if (filename.endsWith(&quot;.xml&quot;)) {&#10;                    properties.loadFromXML(is);&#10;                } else {&#10;                    properties.load(is);&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(&quot;Failed to load properties from: &quot; + filename, e);&#10;        }&#10;        return this;&#10;    }&#10;    &#10;    /**&#10;     * Override specific property programmatically&#10;     */&#10;    public DatabaseProperties override(String key, String value) {&#10;        overrides.put(key, value);&#10;        return this;&#10;    }&#10;    &#10;    /**&#10;     * Get property value with override support&#10;     */&#10;    public String getProperty(String key) {&#10;        return overrides.getOrDefault(key, properties.getProperty(key));&#10;    }&#10;    &#10;    /**&#10;     * Get property value with default fallback&#10;     */&#10;    public String getProperty(String key, String defaultValue) {&#10;        String value = getProperty(key);&#10;        return value != null ? value : defaultValue;&#10;    }&#10;    &#10;    /**&#10;     * Get boolean property&#10;     */&#10;    public boolean getBooleanProperty(String key, boolean defaultValue) {&#10;        String value = getProperty(key);&#10;        return value != null ? Boolean.parseBoolean(value) : defaultValue;&#10;    }&#10;    &#10;    /**&#10;     * Get integer property&#10;     */&#10;    public int getIntProperty(String key, int defaultValue) {&#10;        String value = getProperty(key);&#10;        try {&#10;            return value != null ? Integer.parseInt(value) : defaultValue;&#10;        } catch (NumberFormatException e) {&#10;            return defaultValue;&#10;        }&#10;    }&#10;    &#10;    private void loadDefaultProperties() {&#10;        // Set default values&#10;        properties.setProperty(&quot;h2orm.database.type&quot;, &quot;h2&quot;);&#10;        properties.setProperty(&quot;h2orm.database.mode&quot;, &quot;file&quot;); // file or memory&#10;        properties.setProperty(&quot;h2orm.database.path&quot;, &quot;./data/h2orm&quot;);&#10;        properties.setProperty(&quot;h2orm.database.username&quot;, &quot;sa&quot;);&#10;        properties.setProperty(&quot;h2orm.database.password&quot;, &quot;&quot;);&#10;        &#10;        // Connection pool settings&#10;        properties.setProperty(&quot;h2orm.pool.size&quot;, &quot;10&quot;);&#10;        properties.setProperty(&quot;h2orm.pool.timeout&quot;, &quot;30000&quot;);&#10;        properties.setProperty(&quot;h2orm.pool.idle.timeout&quot;, &quot;600000&quot;);&#10;        properties.setProperty(&quot;h2orm.pool.max.lifetime&quot;, &quot;1800000&quot;);&#10;        &#10;        // JPA/Hibernate settings&#10;        properties.setProperty(&quot;h2orm.jpa.ddl.auto&quot;, &quot;update&quot;);&#10;        properties.setProperty(&quot;h2orm.jpa.show.sql&quot;, &quot;false&quot;);&#10;        properties.setProperty(&quot;h2orm.jpa.format.sql&quot;, &quot;false&quot;);&#10;        properties.setProperty(&quot;h2orm.jpa.batch.size&quot;, &quot;20&quot;);&#10;        properties.setProperty(&quot;h2orm.jpa.cache.use.second.level&quot;, &quot;true&quot;);&#10;        properties.setProperty(&quot;h2orm.jpa.cache.use.query&quot;, &quot;true&quot;);&#10;        &#10;        // Export settings&#10;        properties.setProperty(&quot;h2orm.export.csv.delimiter&quot;, &quot;,&quot;);&#10;        properties.setProperty(&quot;h2orm.export.excel.sheet.name&quot;, &quot;Data&quot;);&#10;        properties.setProperty(&quot;h2orm.export.json.pretty.print&quot;, &quot;true&quot;);&#10;        &#10;        // Backup settings&#10;        properties.setProperty(&quot;h2orm.backup.auto.enabled&quot;, &quot;false&quot;);&#10;        properties.setProperty(&quot;h2orm.backup.interval.hours&quot;, &quot;24&quot;);&#10;        properties.setProperty(&quot;h2orm.backup.retention.days&quot;, &quot;7&quot;);&#10;        properties.setProperty(&quot;h2orm.backup.compression&quot;, &quot;true&quot;);&#10;        &#10;        // Monitoring settings&#10;        properties.setProperty(&quot;h2orm.monitoring.enabled&quot;, &quot;true&quot;);&#10;        properties.setProperty(&quot;h2orm.monitoring.query.log.enabled&quot;, &quot;false&quot;);&#10;        properties.setProperty(&quot;h2orm.monitoring.slow.query.threshold.ms&quot;, &quot;1000&quot;);&#10;        &#10;        // Try to load from default files&#10;        loadFromFile(DEFAULT_PROPERTIES_FILE);&#10;        loadFromFile(DEFAULT_XML_FILE);&#10;    }&#10;    &#10;    /**&#10;     * Database configuration keys&#10;     */&#10;    public static class Keys {&#10;        public static final String DATABASE_TYPE = &quot;h2orm.database.type&quot;;&#10;        public static final String DATABASE_MODE = &quot;h2orm.database.mode&quot;;&#10;        public static final String DATABASE_PATH = &quot;h2orm.database.path&quot;;&#10;        public static final String DATABASE_USERNAME = &quot;h2orm.database.username&quot;;&#10;        public static final String DATABASE_PASSWORD = &quot;h2orm.database.password&quot;;&#10;        public static final String DATABASE_HOST = &quot;h2orm.database.host&quot;;&#10;        public static final String DATABASE_PORT = &quot;h2orm.database.port&quot;;&#10;        public static final String DATABASE_NAME = &quot;h2orm.database.name&quot;;&#10;        &#10;        public static final String POOL_SIZE = &quot;h2orm.pool.size&quot;;&#10;        public static final String POOL_TIMEOUT = &quot;h2orm.pool.timeout&quot;;&#10;        public static final String POOL_IDLE_TIMEOUT = &quot;h2orm.pool.idle.timeout&quot;;&#10;        public static final String POOL_MAX_LIFETIME = &quot;h2orm.pool.max.lifetime&quot;;&#10;        &#10;        public static final String JPA_DDL_AUTO = &quot;h2orm.jpa.ddl.auto&quot;;&#10;        public static final String JPA_SHOW_SQL = &quot;h2orm.jpa.show.sql&quot;;&#10;        public static final String JPA_FORMAT_SQL = &quot;h2orm.jpa.format.sql&quot;;&#10;        public static final String JPA_BATCH_SIZE = &quot;h2orm.jpa.batch.size&quot;;&#10;        public static final String JPA_CACHE_USE_SECOND_LEVEL = &quot;h2orm.jpa.cache.use.second.level&quot;;&#10;        public static final String JPA_CACHE_USE_QUERY = &quot;h2orm.jpa.cache.use.query&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/DatabaseInitializer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/DatabaseInitializer.java" />
              <option name="originalContent" value="package h2.orm.core;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.exception.types.ConfigurationException;&#10;import jakarta.persistence.EntityManager;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.sql.Connection;&#10;import java.sql.DatabaseMetaData;&#10;import java.sql.ResultSet;&#10;import java.sql.SQLException;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;/**&#10; * Core database initializer for H2-ORM&#10; * Handles database setup, schema validation, and initialization tasks&#10; */&#10;public class DatabaseInitializer {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(DatabaseInitializer.class);&#10;&#10;    /**&#10;     * Initialize database with given configuration&#10;     */&#10;    public static void initialize(DatabaseConfiguration config) {&#10;        try {&#10;            logger.info(&quot;Initializing database with configuration: {}&quot;, config.getUrl());&#10;&#10;            // Initialize EntityManagerProvider&#10;            EntityManagerProvider.initialize(config);&#10;&#10;            // Validate database connection&#10;            validateConnection();&#10;&#10;            // Log database information&#10;            logDatabaseInfo();&#10;&#10;            logger.info(&quot;Database initialization completed successfully&quot;);&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Database initialization failed&quot;, e);&#10;            throw new ConfigurationException(&#10;                &quot;Failed to initialize database: &quot; + e.getMessage(),&#10;                &quot;Check your database configuration and ensure the database is accessible.&quot;&#10;            );&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Validate database connection&#10;     */&#10;    public static void validateConnection() {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            // Simple validation query&#10;            em.createNativeQuery(&quot;SELECT 1&quot;).getSingleResult();&#10;            logger.debug(&quot;Database connection validated successfully&quot;);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get existing table names in the database&#10;     */&#10;    public static Set&lt;String&gt; getExistingTables() {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            Set&lt;String&gt; tables = new HashSet&lt;&gt;();&#10;            try {&#10;                Connection connection = em.unwrap(Connection.class);&#10;                DatabaseMetaData metaData = connection.getMetaData();&#10;&#10;                try (ResultSet rs = metaData.getTables(null, null, &quot;%&quot;, new String[]{&quot;TABLE&quot;})) {&#10;                    while (rs.next()) {&#10;                        tables.add(rs.getString(&quot;TABLE_NAME&quot;).toLowerCase());&#10;                    }&#10;                }&#10;            } catch (SQLException e) {&#10;                logger.warn(&quot;Could not retrieve table information&quot;, e);&#10;            }&#10;            return tables;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Check if specific table exists&#10;     */&#10;    public static boolean tableExists(String tableName) {&#10;        return getExistingTables().contains(tableName.toLowerCase());&#10;    }&#10;&#10;    /**&#10;     * Log database information&#10;     */&#10;    private static void logDatabaseInfo() {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            try {&#10;                Connection connection = em.unwrap(Connection.class);&#10;                DatabaseMetaData metaData = connection.getMetaData();&#10;&#10;                logger.info(&quot;Database Info - Product: {}, Version: {}&quot;,&#10;                           metaData.getDatabaseProductName(),&#10;                           metaData.getDatabaseProductVersion());&#10;                logger.info(&quot;Driver Info - Name: {}, Version: {}&quot;,&#10;                           metaData.getDriverName(),&#10;                           metaData.getDriverVersion());&#10;&#10;            } catch (SQLException e) {&#10;                logger.debug(&quot;Could not retrieve database metadata&quot;, e);&#10;            }&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create database schema if not exists (for databases that support it)&#10;     */&#10;    public static void createSchemaIfNotExists(String schemaName) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            try {&#10;                em.createNativeQuery(&quot;CREATE SCHEMA IF NOT EXISTS &quot; + schemaName).executeUpdate();&#10;                logger.info(&quot;Schema '{}' created or already exists&quot;, schemaName);&#10;            } catch (Exception e) {&#10;                logger.debug(&quot;Could not create schema '{}': {}&quot;, schemaName, e.getMessage());&#10;            }&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute custom initialization SQL scripts&#10;     */&#10;    public static void executeInitScript(String sql) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            try {&#10;                String[] statements = sql.split(&quot;;&quot;);&#10;                for (String statement : statements) {&#10;                    String trimmed = statement.trim();&#10;                    if (!trimmed.isEmpty()) {&#10;                        em.createNativeQuery(trimmed).executeUpdate();&#10;                    }&#10;                }&#10;                logger.info(&quot;Initialization script executed successfully&quot;);&#10;            } catch (Exception e) {&#10;                logger.error(&quot;Failed to execute initialization script&quot;, e);&#10;                throw new ConfigurationException(&#10;                    &quot;Failed to execute database initialization script&quot;,&#10;                    &quot;Check your SQL syntax and database permissions.&quot;&#10;                );&#10;            }&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Cleanup and shutdown database connections&#10;     */&#10;    public static void shutdown() {&#10;        try {&#10;            EntityManagerProvider.shutdown();&#10;            logger.info(&quot;Database shutdown completed&quot;);&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Error during database shutdown&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.core;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.exception.types.ConfigurationException;&#10;import jakarta.persistence.EntityManager;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.sql.Connection;&#10;import java.sql.DatabaseMetaData;&#10;import java.sql.ResultSet;&#10;import java.sql.SQLException;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;/**&#10; * Core database initializer for H2-ORM&#10; * Handles database setup, schema validation, and initialization tasks&#10; */&#10;public class DatabaseInitializer {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(DatabaseInitializer.class);&#10;&#10;    /**&#10;     * Initialize database with given configuration&#10;     */&#10;    public static void initialize(DatabaseConfiguration config) {&#10;        try {&#10;            logger.info(&quot;Initializing database with configuration: {}&quot;, config.getUrl());&#10;&#10;            // Initialize EntityManagerProvider&#10;            EntityManagerProvider.initialize(config);&#10;&#10;            // Validate database connection&#10;            validateConnection();&#10;&#10;            // Try to log database information (non-critical)&#10;            try {&#10;                logDatabaseInfo();&#10;            } catch (Exception e) {&#10;                logger.debug(&quot;Could not retrieve database metadata (non-critical): {}&quot;, e.getMessage());&#10;            }&#10;&#10;            logger.info(&quot;Database initialization completed successfully&quot;);&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Database initialization failed&quot;, e);&#10;            throw new ConfigurationException(&#10;                &quot;Failed to initialize database: &quot; + e.getMessage(),&#10;                &quot;Check your database configuration and ensure the database is accessible.&quot;&#10;            );&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Validate database connection&#10;     */&#10;    public static void validateConnection() {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            // Simple validation query&#10;            em.createNativeQuery(&quot;SELECT 1&quot;).getSingleResult();&#10;            logger.debug(&quot;Database connection validated successfully&quot;);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Get existing table names in the database&#10;     */&#10;    public static Set&lt;String&gt; getExistingTables() {&#10;        return EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            Set&lt;String&gt; tables = new HashSet&lt;&gt;();&#10;            try {&#10;                Connection connection = em.unwrap(Connection.class);&#10;                DatabaseMetaData metaData = connection.getMetaData();&#10;&#10;                try (ResultSet rs = metaData.getTables(null, null, &quot;%&quot;, new String[]{&quot;TABLE&quot;})) {&#10;                    while (rs.next()) {&#10;                        tables.add(rs.getString(&quot;TABLE_NAME&quot;).toLowerCase());&#10;                    }&#10;                }&#10;            } catch (SQLException e) {&#10;                logger.warn(&quot;Could not retrieve table information&quot;, e);&#10;            }&#10;            return tables;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Check if specific table exists&#10;     */&#10;    public static boolean tableExists(String tableName) {&#10;        return getExistingTables().contains(tableName.toLowerCase());&#10;    }&#10;&#10;    /**&#10;     * Log database information&#10;     */&#10;    private static void logDatabaseInfo() {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            try {&#10;                Connection connection = em.unwrap(Connection.class);&#10;                DatabaseMetaData metaData = connection.getMetaData();&#10;&#10;                logger.info(&quot;Database Info - Product: {}, Version: {}&quot;,&#10;                           metaData.getDatabaseProductName(),&#10;                           metaData.getDatabaseProductVersion());&#10;                logger.info(&quot;Driver Info - Name: {}, Version: {}&quot;,&#10;                           metaData.getDriverName(),&#10;                           metaData.getDriverVersion());&#10;&#10;            } catch (SQLException e) {&#10;                logger.debug(&quot;Could not retrieve database metadata&quot;, e);&#10;            }&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Create database schema if not exists (for databases that support it)&#10;     */&#10;    public static void createSchemaIfNotExists(String schemaName) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            try {&#10;                em.createNativeQuery(&quot;CREATE SCHEMA IF NOT EXISTS &quot; + schemaName).executeUpdate();&#10;                logger.info(&quot;Schema '{}' created or already exists&quot;, schemaName);&#10;            } catch (Exception e) {&#10;                logger.debug(&quot;Could not create schema '{}': {}&quot;, schemaName, e.getMessage());&#10;            }&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute custom initialization SQL scripts&#10;     */&#10;    public static void executeInitScript(String sql) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            try {&#10;                String[] statements = sql.split(&quot;;&quot;);&#10;                for (String statement : statements) {&#10;                    String trimmed = statement.trim();&#10;                    if (!trimmed.isEmpty()) {&#10;                        em.createNativeQuery(trimmed).executeUpdate();&#10;                    }&#10;                }&#10;                logger.info(&quot;Initialization script executed successfully&quot;);&#10;            } catch (Exception e) {&#10;                logger.error(&quot;Failed to execute initialization script&quot;, e);&#10;                throw new ConfigurationException(&#10;                    &quot;Failed to execute database initialization script&quot;,&#10;                    &quot;Check your SQL syntax and database permissions.&quot;&#10;                );&#10;            }&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Cleanup and shutdown database connections&#10;     */&#10;    public static void shutdown() {&#10;        try {&#10;            EntityManagerProvider.shutdown();&#10;            logger.info(&quot;Database shutdown completed&quot;);&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Error during database shutdown&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/EntityManagerProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/EntityManagerProvider.java" />
              <option name="updatedContent" value="package h2.orm.core;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.exception.types.DatabaseNotInitializedException;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Core EntityManager Provider for H2-ORM library&#10; * Centralized management of JPA EntityManagerFactory and EntityManager instances&#10; */&#10;public class EntityManagerProvider {&#10;    private static final Logger logger = LoggerFactory.getLogger(EntityManagerProvider.class);&#10;    private static final Map&lt;String, EntityManagerFactory&gt; factories = new ConcurrentHashMap&lt;&gt;();&#10;    private static final ThreadLocal&lt;EntityManager&gt; entityManagerThreadLocal = new ThreadLocal&lt;&gt;();&#10;    private static String defaultConfigName = &quot;default&quot;;&#10;    private static DatabaseConfiguration currentConfig;&#10;&#10;    /**&#10;     * Initialize with default configuration from properties&#10;     */&#10;    public static void initialize() {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromProperties();&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with custom properties file&#10;     */&#10;    public static void initialize(String propertiesFile) {&#10;        DatabaseConfiguration config = DatabaseConfiguration.fromPropertiesFile(propertiesFile);&#10;        initialize(config);&#10;    }&#10;&#10;    /**&#10;     * Initialize with specific configuration&#10;     */&#10;    public static void initialize(DatabaseConfiguration config) {&#10;        initialize(defaultConfigName, config);&#10;        currentConfig = config;&#10;    }&#10;&#10;    /**&#10;     * Initialize with named configuration for multi-database support&#10;     */&#10;    public static void initialize(String configName, DatabaseConfiguration config) {&#10;        EntityManagerFactory existingFactory = factories.get(configName);&#10;        if (existingFactory != null &amp;&amp; existingFactory.isOpen()) {&#10;            existingFactory.close();&#10;        }&#10;&#10;        try {&#10;            Map&lt;String, Object&gt; properties = buildJpaProperties(config);&#10;&#10;            logger.info(&quot;Initializing EntityManagerFactory for config: {} with database: {}&quot;,&#10;                    configName, config.getUrl());&#10;&#10;            EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;h2-orm-pu&quot;, properties);&#10;            factories.put(configName, factory);&#10;&#10;            logger.info(&quot;EntityManagerFactory initialized successfully for config: {}&quot;, configName);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to initialize EntityManagerFactory for config: {}&quot;, configName, e);&#10;            throw new RuntimeException(&quot;Failed to initialize database connection&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for default configuration&#10;     */&#10;    public static EntityManager getEntityManager() {&#10;        return getEntityManager(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Get EntityManager for named configuration&#10;     */&#10;    public static EntityManager getEntityManager(String configName) {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em == null || !em.isOpen()) {&#10;            EntityManagerFactory factory = factories.get(configName);&#10;            if (factory == null) {&#10;                throw new DatabaseNotInitializedException();&#10;            }&#10;            em = factory.createEntityManager();&#10;            entityManagerThreadLocal.set(em);&#10;        }&#10;        return em;&#10;    }&#10;&#10;    /**&#10;     * Close current thread's EntityManager&#10;     */&#10;    public static void closeEntityManager() {&#10;        EntityManager em = entityManagerThreadLocal.get();&#10;        if (em != null &amp;&amp; em.isOpen()) {&#10;            try {&#10;                if (em.getTransaction().isActive()) {&#10;                    em.getTransaction().rollback();&#10;                }&#10;                em.close();&#10;            } catch (Exception e) {&#10;                logger.warn(&quot;Error closing EntityManager&quot;, e);&#10;            } finally {&#10;                entityManagerThreadLocal.remove();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(TransactionCallback&lt;T&gt; callback) {&#10;        return executeInTransaction(defaultConfigName, callback);&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, TransactionCallback&lt;T&gt; callback) {&#10;        EntityManager em = getEntityManager(configName);&#10;        try {&#10;            em.getTransaction().begin();&#10;            T result = callback.execute(em);&#10;            em.getTransaction().commit();&#10;            return result;&#10;        } catch (Exception e) {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;            }&#10;            throw new RuntimeException(&quot;Transaction failed&quot;, e);&#10;        } finally {&#10;            closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shutdown all EntityManagerFactories&#10;     */&#10;    public static void shutdown() {&#10;        closeEntityManager();&#10;        factories.values().forEach(factory -&gt; {&#10;            if (factory.isOpen()) {&#10;                try {&#10;                    factory.close();&#10;                } catch (Exception e) {&#10;                    logger.warn(&quot;Error closing EntityManagerFactory&quot;, e);&#10;                }&#10;            }&#10;        });&#10;        factories.clear();&#10;        logger.info(&quot;All EntityManagerFactories shut down&quot;);&#10;    }&#10;&#10;    /**&#10;     * Check if provider is initialized&#10;     */&#10;    public static boolean isInitialized() {&#10;        return isInitialized(defaultConfigName);&#10;    }&#10;&#10;    /**&#10;     * Check if named configuration is initialized&#10;     */&#10;    public static boolean isInitialized(String configName) {&#10;        EntityManagerFactory factory = factories.get(configName);&#10;        return factory != null &amp;&amp; factory.isOpen();&#10;    }&#10;&#10;    /**&#10;     * Get current configuration&#10;     */&#10;    public static DatabaseConfiguration getCurrentConfiguration() {&#10;        return currentConfig;&#10;    }&#10;&#10;    private static Map&lt;String, Object&gt; buildJpaProperties(DatabaseConfiguration config) {&#10;        Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();&#10;&#10;        // Basic connection properties&#10;        properties.put(&quot;jakarta.persistence.jdbc.driver&quot;, config.getDriverClass());&#10;        properties.put(&quot;jakarta.persistence.jdbc.url&quot;, config.getUrl());&#10;        properties.put(&quot;jakarta.persistence.jdbc.user&quot;, config.getUsername());&#10;        properties.put(&quot;jakarta.persistence.jdbc.password&quot;, config.getPassword());&#10;&#10;        // Hibernate specific properties&#10;        properties.put(&quot;hibernate.dialect&quot;, config.getDialect());&#10;        properties.put(&quot;hibernate.hbm2ddl.auto&quot;, config.getDdlAuto());&#10;        properties.put(&quot;hibernate.show_sql&quot;, String.valueOf(config.isShowSql()));&#10;        properties.put(&quot;hibernate.format_sql&quot;, String.valueOf(config.isFormatSql()));&#10;        properties.put(&quot;hibernate.use_sql_comments&quot;, &quot;true&quot;);&#10;&#10;        // Connection pool settings (HikariCP)&#10;        properties.put(&quot;hibernate.connection.provider_class&quot;, &quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;);&#10;        properties.put(&quot;hibernate.hikari.maximumPoolSize&quot;, String.valueOf(config.getPoolSize()));&#10;        properties.put(&quot;hibernate.hikari.minimumIdle&quot;, String.valueOf(config.getMinimumIdle()));&#10;        properties.put(&quot;hibernate.hikari.connectionTimeout&quot;, String.valueOf(config.getConnectionTimeout()));&#10;        properties.put(&quot;hibernate.hikari.idleTimeout&quot;, String.valueOf(config.getIdleTimeout()));&#10;        properties.put(&quot;hibernate.hikari.maxLifetime&quot;, String.valueOf(config.getMaxLifetime()));&#10;        properties.put(&quot;hibernate.hikari.poolName&quot;, config.getPoolName());&#10;&#10;        // Performance settings&#10;        properties.put(&quot;hibernate.jdbc.batch_size&quot;, String.valueOf(config.getBatchSize()));&#10;        properties.put(&quot;hibernate.order_inserts&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.order_updates&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.jdbc.batch_versioned_data&quot;, &quot;true&quot;);&#10;&#10;        // Cache settings - Disable caching by default for simplicity&#10;        properties.put(&quot;hibernate.cache.use_second_level_cache&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.cache.use_query_cache&quot;, &quot;false&quot;);&#10;&#10;        if (config.isUseSecondLevelCache()) {&#10;            // Use Hibernate's built-in cache instead of JCache&#10;            properties.put(&quot;hibernate.cache.region.factory_class&quot;, &quot;org.hibernate.cache.internal.NoCacheRegionFactory&quot;);&#10;        }&#10;&#10;        // Additional optimizations&#10;        properties.put(&quot;hibernate.connection.autocommit&quot;, &quot;false&quot;);&#10;        properties.put(&quot;hibernate.jdbc.lob.non_contextual_creation&quot;, &quot;true&quot;);&#10;        properties.put(&quot;hibernate.temp.use_jdbc_metadata_defaults&quot;, &quot;false&quot;);&#10;&#10;        return properties;&#10;    }&#10;&#10;    /**&#10;     * Functional interface for transaction callbacks&#10;     */&#10;    @FunctionalInterface&#10;    public interface TransactionCallback&lt;T&gt; {&#10;        T execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/MetadataManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/MetadataManager.java" />
              <option name="updatedContent" value="package h2.orm.core;&#10;&#10;import jakarta.persistence.*;&#10;import jakarta.persistence.metamodel.EntityType;&#10;import jakarta.persistence.metamodel.Metamodel;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.lang.reflect.Field;&#10;import java.util.*;&#10;&#10;/**&#10; * Core metadata manager for H2-ORM&#10; * Handles entity metadata, reflection, and schema information&#10; */&#10;public class MetadataManager {&#10;    &#10;    private static final Logger logger = LoggerFactory.getLogger(MetadataManager.class);&#10;    private static final Map&lt;Class&lt;?&gt;, EntityMetadata&gt; metadataCache = new HashMap&lt;&gt;();&#10;    &#10;    /**&#10;     * Get entity metadata with caching&#10;     */&#10;    public static EntityMetadata getEntityMetadata(Class&lt;?&gt; entityClass) {&#10;        return metadataCache.computeIfAbsent(entityClass, MetadataManager::buildEntityMetadata);&#10;    }&#10;    &#10;    /**&#10;     * Get all managed entity types&#10;     */&#10;    public static Set&lt;EntityType&lt;?&gt;&gt; getAllEntityTypes() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Metamodel metamodel = em.getMetamodel();&#10;            return metamodel.getEntities();&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Get table name for entity&#10;     */&#10;    public static String getTableName(Class&lt;?&gt; entityClass) {&#10;        Table tableAnnotation = entityClass.getAnnotation(Table.class);&#10;        if (tableAnnotation != null &amp;&amp; !tableAnnotation.name().isEmpty()) {&#10;            return tableAnnotation.name();&#10;        }&#10;        return entityClass.getSimpleName().toLowerCase();&#10;    }&#10;    &#10;    /**&#10;     * Get ID field for entity&#10;     */&#10;    public static Field getIdField(Class&lt;?&gt; entityClass) {&#10;        return getEntityMetadata(entityClass).getIdField();&#10;    }&#10;    &#10;    /**&#10;     * Get ID value from entity instance&#10;     */&#10;    public static Object getIdValue(Object entity) {&#10;        try {&#10;            Field idField = getIdField(entity.getClass());&#10;            if (idField != null) {&#10;                idField.setAccessible(true);&#10;                return idField.get(entity);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Failed to get ID value from entity&quot;, e);&#10;        }&#10;        return null;&#10;    }&#10;    &#10;    /**&#10;     * Check if entity is new (ID is null or zero)&#10;     */&#10;    public static boolean isEntityNew(Object entity) {&#10;        Object idValue = getIdValue(entity);&#10;        if (idValue == null) {&#10;            return true;&#10;        }&#10;        if (idValue instanceof Number) {&#10;            return ((Number) idValue).longValue() == 0;&#10;        }&#10;        return false;&#10;    }&#10;    &#10;    /**&#10;     * Get all fields with JPA annotations&#10;     */&#10;    public static List&lt;Field&gt; getJpaFields(Class&lt;?&gt; entityClass) {&#10;        return getEntityMetadata(entityClass).getJpaFields();&#10;    }&#10;    &#10;    /**&#10;     * Get column name for field&#10;     */&#10;    public static String getColumnName(Field field) {&#10;        Column columnAnnotation = field.getAnnotation(Column.class);&#10;        if (columnAnnotation != null &amp;&amp; !columnAnnotation.name().isEmpty()) {&#10;            return columnAnnotation.name();&#10;        }&#10;        return field.getName();&#10;    }&#10;    &#10;    /**&#10;     * Build entity metadata&#10;     */&#10;    private static EntityMetadata buildEntityMetadata(Class&lt;?&gt; entityClass) {&#10;        logger.debug(&quot;Building metadata for entity: {}&quot;, entityClass.getSimpleName());&#10;        &#10;        EntityMetadata metadata = new EntityMetadata();&#10;        metadata.setEntityClass(entityClass);&#10;        metadata.setTableName(getTableName(entityClass));&#10;        &#10;        List&lt;Field&gt; jpaFields = new ArrayList&lt;&gt;();&#10;        Field idField = null;&#10;        &#10;        // Process all fields including inherited ones&#10;        Class&lt;?&gt; currentClass = entityClass;&#10;        while (currentClass != null &amp;&amp; !currentClass.equals(Object.class)) {&#10;            for (Field field : currentClass.getDeclaredFields()) {&#10;                if (hasJpaAnnotation(field)) {&#10;                    jpaFields.add(field);&#10;                    &#10;                    if (field.isAnnotationPresent(Id.class)) {&#10;                        idField = field;&#10;                    }&#10;                }&#10;            }&#10;            currentClass = currentClass.getSuperclass();&#10;        }&#10;        &#10;        metadata.setJpaFields(jpaFields);&#10;        metadata.setIdField(idField);&#10;        &#10;        return metadata;&#10;    }&#10;    &#10;    /**&#10;     * Check if field has JPA annotations&#10;     */&#10;    private static boolean hasJpaAnnotation(Field field) {&#10;        return field.isAnnotationPresent(Id.class) ||&#10;               field.isAnnotationPresent(Column.class) ||&#10;               field.isAnnotationPresent(JoinColumn.class) ||&#10;               field.isAnnotationPresent(OneToOne.class) ||&#10;               field.isAnnotationPresent(OneToMany.class) ||&#10;               field.isAnnotationPresent(ManyToOne.class) ||&#10;               field.isAnnotationPresent(ManyToMany.class) ||&#10;               field.isAnnotationPresent(Embedded.class) ||&#10;               field.isAnnotationPresent(GeneratedValue.class);&#10;    }&#10;    &#10;    /**&#10;     * Clear metadata cache&#10;     */&#10;    public static void clearCache() {&#10;        metadataCache.clear();&#10;        logger.debug(&quot;Metadata cache cleared&quot;);&#10;    }&#10;    &#10;    /**&#10;     * Entity metadata holder class&#10;     */&#10;    public static class EntityMetadata {&#10;        private Class&lt;?&gt; entityClass;&#10;        private String tableName;&#10;        private Field idField;&#10;        private List&lt;Field&gt; jpaFields;&#10;        &#10;        // Getters and setters&#10;        public Class&lt;?&gt; getEntityClass() { return entityClass; }&#10;        public void setEntityClass(Class&lt;?&gt; entityClass) { this.entityClass = entityClass; }&#10;        &#10;        public String getTableName() { return tableName; }&#10;        public void setTableName(String tableName) { this.tableName = tableName; }&#10;        &#10;        public Field getIdField() { return idField; }&#10;        public void setIdField(Field idField) { this.idField = idField; }&#10;        &#10;        public List&lt;Field&gt; getJpaFields() { return jpaFields; }&#10;        public void setJpaFields(List&lt;Field&gt; jpaFields) { this.jpaFields = jpaFields; }&#10;        &#10;        @Override&#10;        public String toString() {&#10;            return &quot;EntityMetadata{&quot; +&#10;                    &quot;entityClass=&quot; + entityClass.getSimpleName() +&#10;                    &quot;, tableName='&quot; + tableName + '\'' +&#10;                    &quot;, idField=&quot; + (idField != null ? idField.getName() : &quot;null&quot;) +&#10;                    &quot;, jpaFieldsCount=&quot; + (jpaFields != null ? jpaFields.size() : 0) +&#10;                    '}';&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/QueryExecutor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/QueryExecutor.java" />
              <option name="updatedContent" value="package h2.orm.core;&#10;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.Query;&#10;import jakarta.persistence.TypedQuery;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * Core query executor for H2-ORM&#10; * Provides optimized query execution with proper resource management&#10; */&#10;public class QueryExecutor {&#10;    &#10;    private static final Logger logger = LoggerFactory.getLogger(QueryExecutor.class);&#10;    &#10;    /**&#10;     * Execute JPQL query and return results&#10;     */&#10;    public static &lt;T&gt; List&lt;T&gt; executeQuery(String jpql, Class&lt;T&gt; resultClass) {&#10;        return executeQuery(jpql, resultClass, null);&#10;    }&#10;    &#10;    /**&#10;     * Execute JPQL query with parameters and return results&#10;     */&#10;    public static &lt;T&gt; List&lt;T&gt; executeQuery(String jpql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            TypedQuery&lt;T&gt; query = em.createQuery(jpql, resultClass);&#10;            &#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            &#10;            List&lt;T&gt; results = query.getResultList();&#10;            logger.debug(&quot;JPQL query executed: {} rows returned&quot;, results.size());&#10;            return results;&#10;            &#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Execute native SQL query and return results&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;T&gt; List&lt;T&gt; executeNativeQuery(String sql, Class&lt;T&gt; resultClass) {&#10;        return executeNativeQuery(sql, resultClass, null);&#10;    }&#10;    &#10;    /**&#10;     * Execute native SQL query with parameters and return results&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;T&gt; List&lt;T&gt; executeNativeQuery(String sql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            Query query = em.createNativeQuery(sql, resultClass);&#10;            &#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            &#10;            List&lt;T&gt; results = query.getResultList();&#10;            logger.debug(&quot;Native SQL query executed: {} rows returned&quot;, results.size());&#10;            return results;&#10;            &#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Execute update/delete JPQL query&#10;     */&#10;    public static int executeUpdate(String jpql) {&#10;        return executeUpdate(jpql, null);&#10;    }&#10;    &#10;    /**&#10;     * Execute update/delete JPQL query with parameters&#10;     */&#10;    public static int executeUpdate(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return TransactionManager.executeInTransaction(em -&gt; {&#10;            Query query = em.createQuery(jpql);&#10;            &#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            &#10;            int rowsAffected = query.executeUpdate();&#10;            logger.debug(&quot;Update query executed: {} rows affected&quot;, rowsAffected);&#10;            return rowsAffected;&#10;        });&#10;    }&#10;    &#10;    /**&#10;     * Execute native update/delete SQL&#10;     */&#10;    public static int executeNativeUpdate(String sql) {&#10;        return executeNativeUpdate(sql, null);&#10;    }&#10;    &#10;    /**&#10;     * Execute native update/delete SQL with parameters&#10;     */&#10;    public static int executeNativeUpdate(String sql, Map&lt;String, Object&gt; parameters) {&#10;        return TransactionManager.executeInTransaction(em -&gt; {&#10;            Query query = em.createNativeQuery(sql);&#10;            &#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            &#10;            int rowsAffected = query.executeUpdate();&#10;            logger.debug(&quot;Native update query executed: {} rows affected&quot;, rowsAffected);&#10;            return rowsAffected;&#10;        });&#10;    }&#10;    &#10;    /**&#10;     * Execute query and return single result&#10;     */&#10;    public static &lt;T&gt; T executeSingleResultQuery(String jpql, Class&lt;T&gt; resultClass) {&#10;        return executeSingleResultQuery(jpql, resultClass, null);&#10;    }&#10;    &#10;    /**&#10;     * Execute query with parameters and return single result&#10;     */&#10;    public static &lt;T&gt; T executeSingleResultQuery(String jpql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            TypedQuery&lt;T&gt; query = em.createQuery(jpql, resultClass);&#10;            &#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            &#10;            return query.getSingleResult();&#10;            &#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Execute paginated query&#10;     */&#10;    public static &lt;T&gt; List&lt;T&gt; executePaginatedQuery(String jpql, Class&lt;T&gt; resultClass, int firstResult, int maxResults) {&#10;        return executePaginatedQuery(jpql, resultClass, null, firstResult, maxResults);&#10;    }&#10;    &#10;    /**&#10;     * Execute paginated query with parameters&#10;     */&#10;    public static &lt;T&gt; List&lt;T&gt; executePaginatedQuery(String jpql, Class&lt;T&gt; resultClass, Map&lt;String, Object&gt; parameters, int firstResult, int maxResults) {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            TypedQuery&lt;T&gt; query = em.createQuery(jpql, resultClass);&#10;            &#10;            if (parameters != null) {&#10;                parameters.forEach(query::setParameter);&#10;            }&#10;            &#10;            query.setFirstResult(firstResult);&#10;            query.setMaxResults(maxResults);&#10;            &#10;            List&lt;T&gt; results = query.getResultList();&#10;            logger.debug(&quot;Paginated query executed: {} rows returned (offset: {}, limit: {})&quot;, &#10;                        results.size(), firstResult, maxResults);&#10;            return results;&#10;            &#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/core/TransactionManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/core/TransactionManager.java" />
              <option name="originalContent" value="package h2.orm.core;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import jakarta.persistence.EntityManager;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;/**&#10; * Core transaction manager for H2-ORM&#10; * Handles transaction lifecycle and ensures proper rollback on errors&#10; */&#10;public class TransactionManager {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(TransactionManager.class);&#10;&#10;    /**&#10;     * Execute operation in transaction with automatic rollback on error&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(TransactionCallback&lt;T&gt; callback) {&#10;        return EntityManagerProvider.executeInTransaction(callback);&#10;    }&#10;&#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, TransactionCallback&lt;T&gt; callback) {&#10;        return EntityManagerProvider.executeInTransaction(configName, callback);&#10;    }&#10;&#10;    /**&#10;     * Execute void operation in transaction&#10;     */&#10;    public static void executeInTransaction(VoidTransactionCallback callback) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            callback.execute(em);&#10;            return null;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Check if current thread has active transaction&#10;     */&#10;    public static boolean hasActiveTransaction() {&#10;        try {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            return em.getTransaction().isActive();&#10;        } catch (Exception e) {&#10;            return false;&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Begin transaction manually (advanced usage)&#10;     */&#10;    public static void beginTransaction() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        if (!em.getTransaction().isActive()) {&#10;            em.getTransaction().begin();&#10;            logger.debug(&quot;Transaction started manually&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Commit transaction manually (advanced usage)&#10;     */&#10;    public static void commitTransaction() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().commit();&#10;                logger.debug(&quot;Transaction committed manually&quot;);&#10;            }&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Rollback transaction manually (advanced usage)&#10;     */&#10;    public static void rollbackTransaction() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;                logger.debug(&quot;Transaction rolled back manually&quot;);&#10;            }&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface TransactionCallback&lt;T&gt; {&#10;        T execute(EntityManager entityManager) throws Exception;&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface VoidTransactionCallback {&#10;        void execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.core;&#10;&#10;import jakarta.persistence.EntityManager;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;/**&#10; * Core transaction manager for H2-ORM&#10; * Handles transaction lifecycle and ensures proper rollback on errors&#10; */&#10;public class TransactionManager {&#10;    &#10;    private static final Logger logger = LoggerFactory.getLogger(TransactionManager.class);&#10;    &#10;    /**&#10;     * Execute operation in transaction with automatic rollback on error&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(EntityManagerProvider.TransactionCallback&lt;T&gt; callback) {&#10;        return EntityManagerProvider.executeInTransaction(callback);&#10;    }&#10;    &#10;    /**&#10;     * Execute operation in transaction with named configuration&#10;     */&#10;    public static &lt;T&gt; T executeInTransaction(String configName, EntityManagerProvider.TransactionCallback&lt;T&gt; callback) {&#10;        return EntityManagerProvider.executeInTransaction(configName, callback);&#10;    }&#10;    &#10;    /**&#10;     * Execute void operation in transaction&#10;     */&#10;    public static void executeInTransaction(VoidTransactionCallback callback) {&#10;        EntityManagerProvider.executeInTransaction(em -&gt; {&#10;            callback.execute(em);&#10;            return null;&#10;        });&#10;    }&#10;    &#10;    /**&#10;     * Check if current thread has active transaction&#10;     */&#10;    public static boolean hasActiveTransaction() {&#10;        try {&#10;            EntityManager em = EntityManagerProvider.getEntityManager();&#10;            return em.getTransaction().isActive();&#10;        } catch (Exception e) {&#10;            return false;&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Begin transaction manually (advanced usage)&#10;     */&#10;    public static void beginTransaction() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        if (!em.getTransaction().isActive()) {&#10;            em.getTransaction().begin();&#10;            logger.debug(&quot;Transaction started manually&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Commit transaction manually (advanced usage)&#10;     */&#10;    public static void commitTransaction() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().commit();&#10;                logger.debug(&quot;Transaction committed manually&quot;);&#10;            }&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Rollback transaction manually (advanced usage)&#10;     */&#10;    public static void rollbackTransaction() {&#10;        EntityManager em = EntityManagerProvider.getEntityManager();&#10;        try {&#10;            if (em.getTransaction().isActive()) {&#10;                em.getTransaction().rollback();&#10;                logger.debug(&quot;Transaction rolled back manually&quot;);&#10;            }&#10;        } finally {&#10;            EntityManagerProvider.closeEntityManager();&#10;        }&#10;    }&#10;    &#10;    @FunctionalInterface&#10;    public interface VoidTransactionCallback {&#10;        void execute(EntityManager entityManager) throws Exception;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/example/Product.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/example/Product.java" />
              <option name="updatedContent" value="package h2.orm.example;&#10;&#10;import jakarta.persistence.*;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Example Product entity - demonstrates relationships and different data types&#10; */&#10;@Entity&#10;@Table(name = &quot;products&quot;)&#10;public class Product {&#10;    &#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false)&#10;    private String name;&#10;    &#10;    @Column(columnDefinition = &quot;TEXT&quot;)&#10;    private String description;&#10;    &#10;    @Column(nullable = false, precision = 10, scale = 2)&#10;    private BigDecimal price;&#10;    &#10;    @Column(name = &quot;stock_quantity&quot;)&#10;    private Integer stockQuantity = 0;&#10;    &#10;    @Column(name = &quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;    &#10;    @Column(name = &quot;updated_at&quot;)&#10;    private LocalDateTime updatedAt;&#10;    &#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;created_by&quot;)&#10;    private User createdBy;&#10;    &#10;    // Constructors&#10;    public Product() {&#10;        this.createdAt = LocalDateTime.now();&#10;        this.updatedAt = LocalDateTime.now();&#10;    }&#10;    &#10;    public Product(String name, String description, BigDecimal price) {&#10;        this();&#10;        this.name = name;&#10;        this.description = description;&#10;        this.price = price;&#10;    }&#10;    &#10;    @PreUpdate&#10;    public void preUpdate() {&#10;        this.updatedAt = LocalDateTime.now();&#10;    }&#10;    &#10;    // Getters and Setters&#10;    public Long getId() { return id; }&#10;    public void setId(Long id) { this.id = id; }&#10;    &#10;    public String getName() { return name; }&#10;    public void setName(String name) { this.name = name; }&#10;    &#10;    public String getDescription() { return description; }&#10;    public void setDescription(String description) { this.description = description; }&#10;    &#10;    public BigDecimal getPrice() { return price; }&#10;    public void setPrice(BigDecimal price) { this.price = price; }&#10;    &#10;    public Integer getStockQuantity() { return stockQuantity; }&#10;    public void setStockQuantity(Integer stockQuantity) { this.stockQuantity = stockQuantity; }&#10;    &#10;    public LocalDateTime getCreatedAt() { return createdAt; }&#10;    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }&#10;    &#10;    public LocalDateTime getUpdatedAt() { return updatedAt; }&#10;    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }&#10;    &#10;    public User getCreatedBy() { return createdBy; }&#10;    public void setCreatedBy(User createdBy) { this.createdBy = createdBy; }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        return &quot;Product{&quot; +&#10;                &quot;id=&quot; + id +&#10;                &quot;, name='&quot; + name + '\'' +&#10;                &quot;, description='&quot; + description + '\'' +&#10;                &quot;, price=&quot; + price +&#10;                &quot;, stockQuantity=&quot; + stockQuantity +&#10;                &quot;, createdAt=&quot; + createdAt +&#10;                &quot;, updatedAt=&quot; + updatedAt +&#10;                '}';&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/example/SpringBootStyleExample.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/example/SpringBootStyleExample.java" />
              <option name="originalContent" value="package h2.orm.example;&#10;&#10;import h2.orm.config.DatabaseConfiguration;&#10;import h2.orm.core.EntityManagerProvider;&#10;import h2.orm.repository.JpaRepository;&#10;import h2.orm.repository.Repositories;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Complete example showing how to use H2-ORM exactly like Spring Boot JPA&#10; * No handlers needed - just entities, repositories, and direct usage!&#10; */&#10;public class SpringBootStyleExample {&#10;&#10;    public static void main(String[] args) {&#10;        // 1. Initialize the database (like @SpringBootApplication does)&#10;        initializeDatabase();&#10;&#10;        // 2. Get repositories (like @Autowired in Spring Boot)&#10;        JpaRepository&lt;User, Long&gt; userRepository = Repositories.of(User.class);&#10;        JpaRepository&lt;Product, Long&gt; productRepository = Repositories.of(Product.class);&#10;&#10;        try {&#10;            // 3. Use repositories exactly like Spring Boot JPA!&#10;            demonstrateBasicCrud(userRepository, productRepository);&#10;            demonstrateAdvancedFeatures(userRepository, productRepository);&#10;&#10;        } finally {&#10;            // Clean shutdown&#10;            EntityManagerProvider.shutdown();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Initialize database - supports multiple ways just like Spring Boot&#10;     */&#10;    private static void initializeDatabase() {&#10;        // Option 1: Default H2 in-memory (like Spring Boot default)&#10;        // EntityManagerProvider.initialize();&#10;&#10;        // Option 2: H2 file-based&#10;        EntityManagerProvider.initialize(DatabaseConfiguration.h2File(&quot;./data/myapp&quot;));&#10;&#10;        // Option 3: From properties file (like application.properties)&#10;        // EntityManagerProvider.initialize(&quot;myapp.properties&quot;);&#10;&#10;        // Option 4: Custom configuration&#10;        // DatabaseConfiguration config = DatabaseConfigBuilder.create()&#10;        //     .h2().fileBased().path(&quot;./data/custom&quot;)&#10;        //     .showSql(true).build();&#10;        // EntityManagerProvider.initialize(config);&#10;&#10;        System.out.println(&quot;✅ Database initialized successfully!&quot;);&#10;&#10;        // Clean up any existing data to avoid unique constraint violations&#10;        cleanupExistingData();&#10;    }&#10;&#10;    /**&#10;     * Clean up existing data to avoid unique constraint violations&#10;     */&#10;    private static void cleanupExistingData() {&#10;        try {&#10;            JpaRepository&lt;User, Long&gt; userRepo = Repositories.of(User.class);&#10;            JpaRepository&lt;Product, Long&gt; productRepo = Repositories.of(Product.class);&#10;&#10;            // Delete all existing data&#10;            productRepo.deleteAll();&#10;            userRepo.deleteAll();&#10;&#10;            System.out.println(&quot; Cleaned up existing data&quot;);&#10;        } catch (Exception e) {&#10;            // Ignore cleanup errors - tables might not exist yet&#10;            System.out.println(&quot;ℹ️ No existing data to clean up (first run)&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Demonstrate basic CRUD operations - exactly like Spring Boot JPA&#10;     */&#10;    private static void demonstrateBasicCrud(JpaRepository&lt;User, Long&gt; userRepo,&#10;                                           JpaRepository&lt;Product, Long&gt; productRepo) {&#10;&#10;        System.out.println(&quot;\n Basic CRUD Operations:&quot;);&#10;&#10;        // CREATE - Save entities&#10;        User user1 = new User(&quot;john_doe&quot;, &quot;john@example.com&quot;, &quot;John Doe&quot;);&#10;        User user2 = new User(&quot;jane_smith&quot;, &quot;jane@example.com&quot;, &quot;Jane Smith&quot;);&#10;&#10;        userRepo.save(user1);&#10;        userRepo.save(user2);&#10;        System.out.println(&quot;Created users: &quot; + user1.getId() + &quot;, &quot; + user2.getId());&#10;&#10;        // Create products&#10;        Product product1 = new Product(&quot;Laptop&quot;, &quot;High-performance laptop&quot;, new BigDecimal(&quot;999.99&quot;));&#10;        Product product2 = new Product(&quot;Mouse&quot;, &quot;Wireless optical mouse&quot;, new BigDecimal(&quot;29.99&quot;));&#10;        product1.setStockQuantity(10);&#10;        product2.setStockQuantity(50);&#10;        product1.setCreatedBy(user1);&#10;        product2.setCreatedBy(user2);&#10;&#10;        productRepo.saveAll(List.of(product1, product2));&#10;        System.out.println(&quot;Created products: &quot; + product1.getId() + &quot;, &quot; + product2.getId());&#10;&#10;        // READ - Find operations&#10;        System.out.println(&quot;\n Reading data:&quot;);&#10;&#10;        // Find by ID&#10;        Optional&lt;User&gt; foundUser = userRepo.findById(user1.getId());&#10;        foundUser.ifPresent(u -&gt; System.out.println(&quot;Found user: &quot; + u.getUsername()));&#10;&#10;        // Find all&#10;        List&lt;User&gt; allUsers = userRepo.findAll();&#10;        System.out.println(&quot;Total users: &quot; + allUsers.size());&#10;&#10;        List&lt;Product&gt; allProducts = productRepo.findAll();&#10;        System.out.println(&quot;Total products: &quot; + allProducts.size());&#10;&#10;        // Count&#10;        long userCount = userRepo.count();&#10;        long productCount = productRepo.count();&#10;        System.out.println(&quot;Users count: &quot; + userCount + &quot;, Products count: &quot; + productCount);&#10;&#10;        // UPDATE&#10;        System.out.println(&quot;\n✏️ Updating data:&quot;);&#10;        user1.setFullName(&quot;John Updated Doe&quot;);&#10;        userRepo.save(user1); // save() works for both create and update&#10;        System.out.println(&quot;Updated user: &quot; + user1.getFullName());&#10;&#10;        // UPDATE with saveAndFlush&#10;        product1.setPrice(new BigDecimal(&quot;899.99&quot;));&#10;        productRepo.saveAndFlush(product1);&#10;        System.out.println(&quot;Updated product price: &quot; + product1.getPrice());&#10;    }&#10;&#10;    /**&#10;     * Demonstrate advanced features&#10;     */&#10;    private static void demonstrateAdvancedFeatures(JpaRepository&lt;User, Long&gt; userRepo,&#10;                                                   JpaRepository&lt;Product, Long&gt; productRepo) {&#10;&#10;        System.out.println(&quot;\n Advanced Features:&quot;);&#10;&#10;        // Batch operations&#10;        List&lt;User&gt; newUsers = List.of(&#10;            new User(&quot;alice&quot;, &quot;alice@example.com&quot;, &quot;Alice Johnson&quot;),&#10;            new User(&quot;bob&quot;, &quot;bob@example.com&quot;, &quot;Bob Wilson&quot;),&#10;            new User(&quot;charlie&quot;, &quot;charlie@example.com&quot;, &quot;Charlie Brown&quot;)&#10;        );&#10;&#10;        userRepo.saveAllAndFlush(newUsers);&#10;        System.out.println(&quot;Batch saved &quot; + newUsers.size() + &quot; users&quot;);&#10;&#10;        // Exists check&#10;        boolean exists = userRepo.existsById(1L);&#10;        System.out.println(&quot;User with ID 1 exists: &quot; + exists);&#10;&#10;        // Find multiple by IDs&#10;        List&lt;User&gt; someUsers = userRepo.findAllById(List.of(1L, 2L, 3L));&#10;        System.out.println(&quot;Found users by IDs: &quot; + someUsers.size());&#10;&#10;        // Batch delete&#10;        System.out.println(&quot;\n️ Deletion operations:&quot;);&#10;&#10;        // Delete by ID&#10;        if (!newUsers.isEmpty()) {&#10;            userRepo.deleteById(newUsers.get(0).getId());&#10;            System.out.println(&quot;Deleted user by ID&quot;);&#10;        }&#10;&#10;        // Delete entities&#10;        if (newUsers.size() &gt; 1) {&#10;            userRepo.deleteAll(newUsers.subList(1, 2));&#10;            System.out.println(&quot;Deleted user entities&quot;);&#10;        }&#10;&#10;        // Final count&#10;        System.out.println(&quot;Final user count: &quot; + userRepo.count());&#10;        System.out.println(&quot;Final product count: &quot; + productRepo.count());&#10;&#10;        // Show some data&#10;        System.out.println(&quot;\n Final data:&quot;);&#10;        userRepo.findAll().forEach(System.out::println);&#10;        productRepo.findAll().forEach(System.out::println);&#10;    }&#10;}&#10;&#10;/**&#10; * Example of custom repository interface (like Spring Data JPA)&#10; */&#10;interface UserRepository extends JpaRepository&lt;User, Long&gt; {&#10;    // You can add custom methods here and implement them&#10;    // For now, all basic methods are inherited from JpaRepository&#10;}&#10;&#10;/**&#10; * Example of custom repository interface for Product&#10; */&#10;interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {&#10;    // Custom methods would go here&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.example;&#10;&#10;import h2.orm.H2ORM;&#10;import h2.orm.repository.JpaRepository;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Complete example showing how to use H2-ORM exactly like Spring Boot JPA&#10; * No handlers needed - just entities, repositories, and direct usage!&#10; * Now uses the new core architecture for better performance and reliability&#10; */&#10;public class SpringBootStyleExample {&#10;    &#10;    public static void main(String[] args) {&#10;        try {&#10;            // 1. Initialize the database (like @SpringBootApplication does)&#10;            initializeDatabase();&#10;            &#10;            // 2. Get repositories (like @Autowired in Spring Boot)&#10;            JpaRepository&lt;User, Long&gt; userRepository = H2ORM.repository(User.class);&#10;            JpaRepository&lt;Product, Long&gt; productRepository = H2ORM.repository(Product.class);&#10;            &#10;            // 3. Use repositories exactly like Spring Boot JPA!&#10;            demonstrateBasicCrud(userRepository, productRepository);&#10;            demonstrateAdvancedFeatures(userRepository, productRepository);&#10;            &#10;        } catch (Exception e) {&#10;            System.err.println(&quot;❌ Error: &quot; + e.getMessage());&#10;            if (e.getCause() != null) {&#10;                System.err.println(&quot; Cause: &quot; + e.getCause().getMessage());&#10;            }&#10;        } finally {&#10;            // Clean shutdown&#10;            H2ORM.stop();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Initialize database using new H2ORM entry point&#10;     */&#10;    private static void initializeDatabase() {&#10;        // Using the new simplified H2ORM entry point&#10;        H2ORM.start(&quot;./data/myapp&quot;);&#10;        &#10;        System.out.println(&quot;✅ Database initialized successfully with new core architecture!&quot;);&#10;        &#10;        // Clean up any existing data to avoid unique constraint violations&#10;        cleanupExistingData();&#10;    }&#10;    &#10;    /**&#10;     * Clean up existing data to avoid unique constraint violations&#10;     */&#10;    private static void cleanupExistingData() {&#10;        try {&#10;            JpaRepository&lt;User, Long&gt; userRepo = H2ORM.repository(User.class);&#10;            JpaRepository&lt;Product, Long&gt; productRepo = H2ORM.repository(Product.class);&#10;            &#10;            // Delete all existing data&#10;            productRepo.deleteAll();&#10;            userRepo.deleteAll();&#10;            &#10;            System.out.println(&quot; Cleaned up existing data&quot;);&#10;        } catch (Exception e) {&#10;            // Ignore cleanup errors - tables might not exist yet&#10;            System.out.println(&quot;ℹ️ No existing data to clean up (first run)&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Demonstrate basic CRUD operations - exactly like Spring Boot JPA&#10;     */&#10;    private static void demonstrateBasicCrud(JpaRepository&lt;User, Long&gt; userRepo,&#10;                                           JpaRepository&lt;Product, Long&gt; productRepo) {&#10;&#10;        System.out.println(&quot;\n Basic CRUD Operations:&quot;);&#10;&#10;        // CREATE - Save entities&#10;        User user1 = new User(&quot;john_doe&quot;, &quot;john@example.com&quot;, &quot;John Doe&quot;);&#10;        User user2 = new User(&quot;jane_smith&quot;, &quot;jane@example.com&quot;, &quot;Jane Smith&quot;);&#10;&#10;        userRepo.save(user1);&#10;        userRepo.save(user2);&#10;        System.out.println(&quot;Created users: &quot; + user1.getId() + &quot;, &quot; + user2.getId());&#10;&#10;        // Create products&#10;        Product product1 = new Product(&quot;Laptop&quot;, &quot;High-performance laptop&quot;, new BigDecimal(&quot;999.99&quot;));&#10;        Product product2 = new Product(&quot;Mouse&quot;, &quot;Wireless optical mouse&quot;, new BigDecimal(&quot;29.99&quot;));&#10;        product1.setStockQuantity(10);&#10;        product2.setStockQuantity(50);&#10;        product1.setCreatedBy(user1);&#10;        product2.setCreatedBy(user2);&#10;&#10;        productRepo.saveAll(List.of(product1, product2));&#10;        System.out.println(&quot;Created products: &quot; + product1.getId() + &quot;, &quot; + product2.getId());&#10;&#10;        // READ - Find operations&#10;        System.out.println(&quot;\n Reading data:&quot;);&#10;&#10;        // Find by ID&#10;        Optional&lt;User&gt; foundUser = userRepo.findById(user1.getId());&#10;        foundUser.ifPresent(u -&gt; System.out.println(&quot;Found user: &quot; + u.getUsername()));&#10;&#10;        // Find all&#10;        List&lt;User&gt; allUsers = userRepo.findAll();&#10;        System.out.println(&quot;Total users: &quot; + allUsers.size());&#10;&#10;        List&lt;Product&gt; allProducts = productRepo.findAll();&#10;        System.out.println(&quot;Total products: &quot; + allProducts.size());&#10;&#10;        // Count&#10;        long userCount = userRepo.count();&#10;        long productCount = productRepo.count();&#10;        System.out.println(&quot;Users count: &quot; + userCount + &quot;, Products count: &quot; + productCount);&#10;&#10;        // UPDATE&#10;        System.out.println(&quot;\n✏️ Updating data:&quot;);&#10;        user1.setFullName(&quot;John Updated Doe&quot;);&#10;        userRepo.save(user1); // save() works for both create and update&#10;        System.out.println(&quot;Updated user: &quot; + user1.getFullName());&#10;&#10;        // UPDATE with saveAndFlush&#10;        product1.setPrice(new BigDecimal(&quot;899.99&quot;));&#10;        productRepo.saveAndFlush(product1);&#10;        System.out.println(&quot;Updated product price: &quot; + product1.getPrice());&#10;    }&#10;&#10;    /**&#10;     * Demonstrate advanced features&#10;     */&#10;    private static void demonstrateAdvancedFeatures(JpaRepository&lt;User, Long&gt; userRepo,&#10;                                                   JpaRepository&lt;Product, Long&gt; productRepo) {&#10;&#10;        System.out.println(&quot;\n Advanced Features:&quot;);&#10;&#10;        // Batch operations&#10;        List&lt;User&gt; newUsers = List.of(&#10;            new User(&quot;alice&quot;, &quot;alice@example.com&quot;, &quot;Alice Johnson&quot;),&#10;            new User(&quot;bob&quot;, &quot;bob@example.com&quot;, &quot;Bob Wilson&quot;),&#10;            new User(&quot;charlie&quot;, &quot;charlie@example.com&quot;, &quot;Charlie Brown&quot;)&#10;        );&#10;&#10;        userRepo.saveAllAndFlush(newUsers);&#10;        System.out.println(&quot;Batch saved &quot; + newUsers.size() + &quot; users&quot;);&#10;&#10;        // Exists check&#10;        boolean exists = userRepo.existsById(1L);&#10;        System.out.println(&quot;User with ID 1 exists: &quot; + exists);&#10;&#10;        // Find multiple by IDs&#10;        List&lt;User&gt; someUsers = userRepo.findAllById(List.of(1L, 2L, 3L));&#10;        System.out.println(&quot;Found users by IDs: &quot; + someUsers.size());&#10;&#10;        // Batch delete&#10;        System.out.println(&quot;\n️ Deletion operations:&quot;);&#10;&#10;        // Delete by ID&#10;        if (!newUsers.isEmpty()) {&#10;            userRepo.deleteById(newUsers.get(0).getId());&#10;            System.out.println(&quot;Deleted user by ID&quot;);&#10;        }&#10;&#10;        // Delete entities&#10;        if (newUsers.size() &gt; 1) {&#10;            userRepo.deleteAll(newUsers.subList(1, 2));&#10;            System.out.println(&quot;Deleted user entities&quot;);&#10;        }&#10;&#10;        // Final count&#10;        System.out.println(&quot;Final user count: &quot; + userRepo.count());&#10;        System.out.println(&quot;Final product count: &quot; + productRepo.count());&#10;&#10;        // Show some data&#10;        System.out.println(&quot;\n Final data:&quot;);&#10;        userRepo.findAll().forEach(System.out::println);&#10;        productRepo.findAll().forEach(System.out::println);&#10;    }&#10;}&#10;&#10;/**&#10; * Example of custom repository interface (like Spring Data JPA)&#10; */&#10;interface UserRepository extends JpaRepository&lt;User, Long&gt; {&#10;    // You can add custom methods here and implement them&#10;    // For now, all basic methods are inherited from JpaRepository&#10;}&#10;&#10;/**&#10; * Example of custom repository interface for Product&#10; */&#10;interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {&#10;    // Custom methods would go here&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/example/SuperSimpleExample.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/example/SuperSimpleExample.java" />
              <option name="updatedContent" value="package h2.orm.example;&#10;&#10;import h2.orm.H2ORM;&#10;import h2.orm.repository.JpaRepository;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.List;&#10;&#10;/**&#10; * Super Simple Example - shows how easy H2-ORM is to use!&#10; * Just like Spring Boot but even simpler!&#10; */&#10;public class SuperSimpleExample {&#10;    &#10;    public static void main(String[] args) {&#10;        try {&#10;            // 1. Start H2-ORM (one line!)&#10;            H2ORM.start(&quot;./data/simple_example&quot;);&#10;            &#10;            // 2. Get repositories (like @Autowired in Spring Boot)&#10;            JpaRepository&lt;User, Long&gt; userRepo = H2ORM.repository(User.class);&#10;            JpaRepository&lt;Product, Long&gt; productRepo = H2ORM.repository(Product.class);&#10;            &#10;            // 3. Use it exactly like Spring Boot JPA!&#10;            System.out.println(&quot; H2-ORM Super Simple Example&quot;);&#10;            &#10;            // Clean start&#10;            userRepo.deleteAll();&#10;            productRepo.deleteAll();&#10;            &#10;            // Create and save users&#10;            User john = userRepo.save(new User(&quot;john_doe&quot;, &quot;john@example.com&quot;, &quot;John Doe&quot;));&#10;            User jane = userRepo.save(new User(&quot;jane_smith&quot;, &quot;jane@example.com&quot;, &quot;Jane Smith&quot;));&#10;            &#10;            System.out.println(&quot;✅ Created users: &quot; + john.getUsername() + &quot;, &quot; + jane.getUsername());&#10;            &#10;            // Create and save products&#10;            Product laptop = new Product(&quot;MacBook Pro&quot;, &quot;High-performance laptop&quot;, new BigDecimal(&quot;2499.99&quot;));&#10;            laptop.setStockQuantity(5);&#10;            laptop.setCreatedBy(john);&#10;            &#10;            Product mouse = new Product(&quot;Magic Mouse&quot;, &quot;Wireless mouse&quot;, new BigDecimal(&quot;99.99&quot;));&#10;            mouse.setStockQuantity(20);&#10;            mouse.setCreatedBy(jane);&#10;            &#10;            productRepo.saveAll(List.of(laptop, mouse));&#10;            System.out.println(&quot;✅ Created products: &quot; + laptop.getName() + &quot;, &quot; + mouse.getName());&#10;            &#10;            // Query data&#10;            List&lt;User&gt; allUsers = userRepo.findAll();&#10;            List&lt;Product&gt; allProducts = productRepo.findAll();&#10;            &#10;            System.out.println(&quot;\n Current Data:&quot;);&#10;            System.out.println(&quot;Users (&quot; + userRepo.count() + &quot;):&quot;);&#10;            allUsers.forEach(u -&gt; System.out.println(&quot;  - &quot; + u.getUsername() + &quot; (&quot; + u.getEmail() + &quot;)&quot;));&#10;            &#10;            System.out.println(&quot;Products (&quot; + productRepo.count() + &quot;):&quot;);&#10;            allProducts.forEach(p -&gt; System.out.println(&quot;  - &quot; + p.getName() + &quot; - $&quot; + p.getPrice()));&#10;            &#10;            // Update example&#10;            laptop.setPrice(new BigDecimal(&quot;2299.99&quot;));&#10;            productRepo.saveAndFlush(laptop);&#10;            System.out.println(&quot;✅ Updated laptop price to: $&quot; + laptop.getPrice());&#10;            &#10;            System.out.println(&quot;\n Success! H2-ORM is working perfectly!&quot;);&#10;            &#10;        } catch (Exception e) {&#10;            System.err.println(&quot;❌ Error: &quot; + e.getMessage());&#10;            if (e.getCause() != null) {&#10;                System.err.println(&quot; Cause: &quot; + e.getCause().getMessage());&#10;            }&#10;        } finally {&#10;            // 4. Clean shutdown&#10;            H2ORM.stop();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/example/User.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/example/User.java" />
              <option name="updatedContent" value="package h2.orm.example;&#10;&#10;import jakarta.persistence.*;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Example User entity - just like any JPA entity in Spring Boot&#10; */&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User {&#10;    &#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false, unique = true)&#10;    private String username;&#10;    &#10;    @Column(nullable = false)&#10;    private String email;&#10;    &#10;    @Column(name = &quot;full_name&quot;)&#10;    private String fullName;&#10;    &#10;    @Column(name = &quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;    &#10;    @Column(name = &quot;is_active&quot;)&#10;    private Boolean isActive = true;&#10;    &#10;    // Constructors&#10;    public User() {&#10;        this.createdAt = LocalDateTime.now();&#10;    }&#10;    &#10;    public User(String username, String email, String fullName) {&#10;        this();&#10;        this.username = username;&#10;        this.email = email;&#10;        this.fullName = fullName;&#10;    }&#10;    &#10;    // Getters and Setters&#10;    public Long getId() { return id; }&#10;    public void setId(Long id) { this.id = id; }&#10;    &#10;    public String getUsername() { return username; }&#10;    public void setUsername(String username) { this.username = username; }&#10;    &#10;    public String getEmail() { return email; }&#10;    public void setEmail(String email) { this.email = email; }&#10;    &#10;    public String getFullName() { return fullName; }&#10;    public void setFullName(String fullName) { this.fullName = fullName; }&#10;    &#10;    public LocalDateTime getCreatedAt() { return createdAt; }&#10;    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }&#10;    &#10;    public Boolean getIsActive() { return isActive; }&#10;    public void setIsActive(Boolean isActive) { this.isActive = isActive; }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        return &quot;User{&quot; +&#10;                &quot;id=&quot; + id +&#10;                &quot;, username='&quot; + username + '\'' +&#10;                &quot;, email='&quot; + email + '\'' +&#10;                &quot;, fullName='&quot; + fullName + '\'' +&#10;                &quot;, createdAt=&quot; + createdAt +&#10;                &quot;, isActive=&quot; + isActive +&#10;                '}';&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/ExceptionHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/ExceptionHandler.java" />
              <option name="originalContent" value="package h2.orm.exception;&#10;&#10;import jakarta.persistence.TransactionRequiredException;&#10;import org.hibernate.exception.ConstraintViolationException;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;/**&#10; * Utility class to handle and convert various exceptions to user-friendly H2OrmExceptions&#10; */&#10;public class ExceptionHandler {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(ExceptionHandler.class);&#10;&#10;    /**&#10;     * Handle any exception and convert to user-friendly H2OrmException&#10;     */&#10;    public static H2OrmException handleException(String operation, Throwable throwable) {&#10;        logger.error(&quot;Exception during {}: {}&quot;, operation, throwable.getMessage(), throwable);&#10;&#10;        // Handle specific exception types&#10;        if (throwable instanceof TransactionRequiredException) {&#10;            return new TransactionRequiredException(operation);&#10;        }&#10;&#10;        if (throwable instanceof ConstraintViolationException) {&#10;            ConstraintViolationException cve = (ConstraintViolationException) cve;&#10;            return handleConstraintViolation(cve);&#10;        }&#10;&#10;        if (throwable instanceof jakarta.persistence.EntityExistsException) {&#10;            return new H2OrmExceptions.EntityOperationException(&#10;                &quot;save entity (entity already exists)&quot;, throwable);&#10;        }&#10;&#10;        if (throwable instanceof jakarta.persistence.EntityNotFoundException) {&#10;            return new H2OrmExceptions.EntityOperationException(&#10;                &quot;find entity (entity not found)&quot;, throwable);&#10;        }&#10;&#10;        if (throwable instanceof IllegalStateException &amp;&amp;&#10;            throwable.getMessage().contains(&quot;EntityManagerFactory not initialized&quot;)) {&#10;            return new DatabaseNotInitializedException();&#10;        }&#10;&#10;        // Handle SQL/database errors&#10;        if (throwable.getMessage() != null) {&#10;            String message = throwable.getMessage().toLowerCase();&#10;&#10;            if (message.contains(&quot;unique&quot;) || message.contains(&quot;duplicate&quot;)) {&#10;                return handleUniqueConstraintViolation(throwable);&#10;            }&#10;&#10;            if (message.contains(&quot;table&quot;) &amp;&amp; message.contains(&quot;doesn't exist&quot;)) {&#10;                return new H2OrmExceptions.ConfigurationException(&#10;                    &quot;Database table doesn't exist.&quot;,&#10;                    &quot;Make sure your entities are properly configured and database schema is created.&quot;&#10;                );&#10;            }&#10;&#10;            if (message.contains(&quot;connection&quot;)) {&#10;                return new H2OrmExceptions.ConfigurationException(&#10;                    &quot;Database connection failed.&quot;,&#10;                    &quot;Check your database configuration and ensure the database server is running.&quot;&#10;                );&#10;            }&#10;        }&#10;&#10;        // Generic fallback&#10;        return new H2OrmExceptions.RepositoryException(operation, throwable);&#10;    }&#10;&#10;    private static H2OrmException handleConstraintViolation(ConstraintViolationException cve) {&#10;        String message = cve.getMessage();&#10;        if (message != null &amp;&amp; message.toLowerCase().contains(&quot;unique&quot;)) {&#10;            return handleUniqueConstraintViolation(cve);&#10;        }&#10;&#10;        return new H2OrmExceptions.EntityOperationException(&#10;            &quot;save entity (constraint violation)&quot;, cve);&#10;    }&#10;&#10;    private static H2OrmException handleUniqueConstraintViolation(Throwable throwable) {&#10;        String message = throwable.getMessage();&#10;&#10;        // Try to extract field name and value from error message&#10;        String field = &quot;field&quot;;&#10;        String value = &quot;value&quot;;&#10;&#10;        if (message != null) {&#10;            // Parse common unique constraint error patterns&#10;            if (message.contains(&quot;username&quot;)) {&#10;                field = &quot;username&quot;;&#10;                // Try to extract value from error message&#10;                int start = message.indexOf(&quot;'&quot;);&#10;                int end = message.lastIndexOf(&quot;'&quot;);&#10;                if (start != -1 &amp;&amp; end != -1 &amp;&amp; start &lt; end) {&#10;                    value = message.substring(start + 1, end);&#10;                }&#10;            }&#10;        }&#10;&#10;        return new H2OrmExceptions.UniqueConstraintException(field, value, throwable);&#10;    }&#10;&#10;    /**&#10;     * Safe execution wrapper that handles exceptions&#10;     */&#10;    public static &lt;T&gt; T safeExecute(String operation, ThrowingSupplier&lt;T&gt; supplier) {&#10;        try {&#10;            return supplier.get();&#10;        } catch (Exception e) {&#10;            throw handleException(operation, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Safe execution wrapper for void operations&#10;     */&#10;    public static void safeExecute(String operation, ThrowingRunnable runnable) {&#10;        try {&#10;            runnable.run();&#10;        } catch (Exception e) {&#10;            throw handleException(operation, e);&#10;        }&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ThrowingSupplier&lt;T&gt; {&#10;        T get() throws Exception;&#10;    }&#10;&#10;    @FunctionalInterface&#10;    public interface ThrowingRunnable {&#10;        void run() throws Exception;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.exception;&#10;&#10;import h2.orm.exception.types.*;&#10;import org.hibernate.exception.ConstraintViolationException;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;/**&#10; * Central exception handler for H2-ORM library&#10; * Converts technical exceptions to user-friendly H2OrmExceptions&#10; */&#10;public class ExceptionHandler {&#10;    &#10;    private static final Logger logger = LoggerFactory.getLogger(ExceptionHandler.class);&#10;    &#10;    /**&#10;     * Handle any exception and convert to user-friendly H2OrmException&#10;     */&#10;    public static H2OrmException handleException(String operation, Throwable throwable) {&#10;        logger.error(&quot;Exception during {}: {}&quot;, operation, throwable.getMessage(), throwable);&#10;        &#10;        // Handle specific exception types&#10;        if (throwable instanceof jakarta.persistence.TransactionRequiredException) {&#10;            return new TransactionRequiredException(operation);&#10;        }&#10;        &#10;        if (throwable instanceof ConstraintViolationException) {&#10;            return handleConstraintViolation((ConstraintViolationException) throwable);&#10;        }&#10;        &#10;        if (throwable instanceof jakarta.persistence.EntityExistsException) {&#10;            return new EntityOperationException(&quot;save entity (entity already exists)&quot;, throwable);&#10;        }&#10;        &#10;        if (throwable instanceof jakarta.persistence.EntityNotFoundException) {&#10;            return new EntityOperationException(&quot;find entity (entity not found)&quot;, throwable);&#10;        }&#10;        &#10;        if (throwable instanceof IllegalStateException &amp;&amp; &#10;            throwable.getMessage() != null &amp;&amp; &#10;            throwable.getMessage().contains(&quot;EntityManagerFactory not initialized&quot;)) {&#10;            return new DatabaseNotInitializedException();&#10;        }&#10;        &#10;        // Handle SQL/database errors by message content&#10;        if (throwable.getMessage() != null) {&#10;            String message = throwable.getMessage().toLowerCase();&#10;            &#10;            if (message.contains(&quot;unique&quot;) || message.contains(&quot;duplicate&quot;)) {&#10;                return handleUniqueConstraintViolation(throwable);&#10;            }&#10;            &#10;            if (message.contains(&quot;table&quot;) &amp;&amp; (message.contains(&quot;doesn't exist&quot;) || message.contains(&quot;not found&quot;))) {&#10;                return new ConfigurationException(&#10;                    &quot;Database table doesn't exist.&quot;,&#10;                    &quot;Make sure your entities are properly configured and database schema is created.&quot;&#10;                );&#10;            }&#10;            &#10;            if (message.contains(&quot;connection&quot;)) {&#10;                return new ConfigurationException(&#10;                    &quot;Database connection failed.&quot;,&#10;                    &quot;Check your database configuration and ensure the database server is running.&quot;&#10;                );&#10;            }&#10;        }&#10;        &#10;        // Generic fallback&#10;        return new RepositoryException(operation, throwable);&#10;    }&#10;    &#10;    private static H2OrmException handleConstraintViolation(ConstraintViolationException cve) {&#10;        String message = cve.getMessage();&#10;        if (message != null &amp;&amp; message.toLowerCase().contains(&quot;unique&quot;)) {&#10;            return handleUniqueConstraintViolation(cve);&#10;        }&#10;        &#10;        return new EntityOperationException(&quot;save entity (constraint violation)&quot;, cve);&#10;    }&#10;    &#10;    private static H2OrmException handleUniqueConstraintViolation(Throwable throwable) {&#10;        String message = throwable.getMessage();&#10;        &#10;        // Try to extract field name and value from error message&#10;        String field = &quot;field&quot;;&#10;        String value = &quot;unknown&quot;;&#10;        &#10;        if (message != null) {&#10;            // Parse common unique constraint error patterns&#10;            if (message.contains(&quot;username&quot;)) {&#10;                field = &quot;username&quot;;&#10;            } else if (message.contains(&quot;email&quot;)) {&#10;                field = &quot;email&quot;;&#10;            }&#10;            &#10;            // Try to extract value from error message&#10;            int start = message.indexOf(&quot;'&quot;);&#10;            int end = message.lastIndexOf(&quot;'&quot;);&#10;            if (start != -1 &amp;&amp; end != -1 &amp;&amp; start &lt; end) {&#10;                value = message.substring(start + 1, end);&#10;            }&#10;        }&#10;        &#10;        return new UniqueConstraintException(field, value, throwable);&#10;    }&#10;    &#10;    /**&#10;     * Safe execution wrapper that handles exceptions&#10;     */&#10;    public static &lt;T&gt; T safeExecute(String operation, ThrowingSupplier&lt;T&gt; supplier) {&#10;        try {&#10;            return supplier.get();&#10;        } catch (H2OrmException e) {&#10;            // Re-throw our custom exceptions as-is&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw handleException(operation, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Safe execution wrapper for void operations&#10;     */&#10;    public static void safeExecute(String operation, ThrowingRunnable runnable) {&#10;        try {&#10;            runnable.run();&#10;        } catch (H2OrmException e) {&#10;            // Re-throw our custom exceptions as-is&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw handleException(operation, e);&#10;        }&#10;    }&#10;    &#10;    @FunctionalInterface&#10;    public interface ThrowingSupplier&lt;T&gt; {&#10;        T get() throws Exception;&#10;    }&#10;    &#10;    @FunctionalInterface&#10;    public interface ThrowingRunnable {&#10;        void run() throws Exception;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/H2OrmException.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/H2OrmException.java" />
              <option name="updatedContent" value="package h2.orm.exception;&#10;&#10;/**&#10; * Base exception for all H2-ORM related errors&#10; * Provides user-friendly error messages and suggestions&#10; */&#10;public class H2OrmException extends RuntimeException {&#10;    &#10;    private final String userFriendlyMessage;&#10;    private final String suggestion;&#10;    &#10;    public H2OrmException(String message) {&#10;        super(message);&#10;        this.userFriendlyMessage = message;&#10;        this.suggestion = null;&#10;    }&#10;    &#10;    public H2OrmException(String message, String userFriendlyMessage) {&#10;        super(message);&#10;        this.userFriendlyMessage = userFriendlyMessage;&#10;        this.suggestion = null;&#10;    }&#10;    &#10;    public H2OrmException(String message, String userFriendlyMessage, String suggestion) {&#10;        super(message);&#10;        this.userFriendlyMessage = userFriendlyMessage;&#10;        this.suggestion = suggestion;&#10;    }&#10;    &#10;    public H2OrmException(String message, Throwable cause) {&#10;        super(message, cause);&#10;        this.userFriendlyMessage = message;&#10;        this.suggestion = null;&#10;    }&#10;    &#10;    public H2OrmException(String message, String userFriendlyMessage, String suggestion, Throwable cause) {&#10;        super(message, cause);&#10;        this.userFriendlyMessage = userFriendlyMessage;&#10;        this.suggestion = suggestion;&#10;    }&#10;    &#10;    public String getUserFriendlyMessage() {&#10;        return userFriendlyMessage;&#10;    }&#10;    &#10;    public String getSuggestion() {&#10;        return suggestion;&#10;    }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot;H2-ORM Error: &quot;).append(userFriendlyMessage);&#10;        &#10;        if (suggestion != null &amp;&amp; !suggestion.isEmpty()) {&#10;            sb.append(&quot;\n Suggestion: &quot;).append(suggestion);&#10;        }&#10;        &#10;        if (getCause() != null) {&#10;            sb.append(&quot;\n Technical details: &quot;).append(getCause().getMessage());&#10;        }&#10;        &#10;        return sb.toString();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/H2OrmExceptions.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/H2OrmExceptions.java" />
              <option name="updatedContent" value="package h2.orm.exception;&#10;&#10;/**&#10; * Exception thrown when database is not initialized&#10; */&#10;public class DatabaseNotInitializedException extends H2OrmException {&#10;    &#10;    public DatabaseNotInitializedException() {&#10;        super(&#10;            &quot;Database not initialized&quot;,&#10;            &quot;The H2-ORM database connection has not been initialized yet.&quot;,&#10;            &quot;Call EntityManagerProvider.initialize() before using repositories.&quot;&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when transaction is required but not active&#10; */&#10;class TransactionRequiredException extends H2OrmException {&#10;    &#10;    public TransactionRequiredException(String operation) {&#10;        super(&#10;            &quot;Transaction required for operation: &quot; + operation,&#10;            &quot;The operation '&quot; + operation + &quot;' requires an active transaction.&quot;,&#10;            &quot;This operation will be automatically wrapped in a transaction.&quot;&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when entity operation fails&#10; */&#10;class EntityOperationException extends H2OrmException {&#10;    &#10;    public EntityOperationException(String operation, Throwable cause) {&#10;        super(&#10;            &quot;Entity operation failed: &quot; + operation,&#10;            &quot;Failed to &quot; + operation.toLowerCase() + &quot; entity.&quot;,&#10;            &quot;Check if the entity is valid and database connection is working.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when unique constraint is violated&#10; */&#10;class UniqueConstraintException extends H2OrmException {&#10;    &#10;    public UniqueConstraintException(String field, Object value, Throwable cause) {&#10;        super(&#10;            &quot;Unique constraint violation&quot;,&#10;            &quot;A record with &quot; + field + &quot; = '&quot; + value + &quot;' already exists.&quot;,&#10;            &quot;Use a different value for &quot; + field + &quot; or update the existing record.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when configuration is invalid&#10; */&#10;class ConfigurationException extends H2OrmException {&#10;    &#10;    public ConfigurationException(String message, String suggestion) {&#10;        super(&#10;            &quot;Configuration error&quot;,&#10;            message,&#10;            suggestion&#10;        );&#10;    }&#10;}&#10;&#10;/**&#10; * Exception thrown when repository operation fails&#10; */&#10;class RepositoryException extends H2OrmException {&#10;    &#10;    public RepositoryException(String operation, Throwable cause) {&#10;        super(&#10;            &quot;Repository operation failed: &quot; + operation,&#10;            &quot;Failed to execute repository operation: &quot; + operation,&#10;            &quot;Check your entity configuration and database connection.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/ConfigurationException.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/ConfigurationException.java" />
              <option name="updatedContent" value="package h2.orm.exception.types;&#10;&#10;import h2.orm.exception.H2OrmException;&#10;&#10;/**&#10; * Exception thrown when configuration is invalid&#10; */&#10;public class ConfigurationException extends H2OrmException {&#10;    &#10;    public ConfigurationException(String message, String suggestion) {&#10;        super(&#10;            &quot;Configuration error&quot;,&#10;            message,&#10;            suggestion&#10;        );&#10;    }&#10;    &#10;    public ConfigurationException(String message, String suggestion, Throwable cause) {&#10;        super(&#10;            &quot;Configuration error&quot;,&#10;            message,&#10;            suggestion,&#10;            cause&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/DatabaseNotInitializedException.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/DatabaseNotInitializedException.java" />
              <option name="updatedContent" value="package h2.orm.exception.types;&#10;&#10;import h2.orm.exception.H2OrmException;&#10;&#10;/**&#10; * Exception thrown when database is not initialized&#10; */&#10;public class DatabaseNotInitializedException extends H2OrmException {&#10;    &#10;    public DatabaseNotInitializedException() {&#10;        super(&#10;            &quot;Database not initialized&quot;,&#10;            &quot;The H2-ORM database connection has not been initialized yet.&quot;,&#10;            &quot;Call H2ORM.start() or EntityManagerProvider.initialize() before using repositories.&quot;&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/EntityOperationException.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/EntityOperationException.java" />
              <option name="updatedContent" value="package h2.orm.exception.types;&#10;&#10;import h2.orm.exception.H2OrmException;&#10;&#10;/**&#10; * Exception thrown when entity operation fails&#10; */&#10;public class EntityOperationException extends H2OrmException {&#10;    &#10;    public EntityOperationException(String operation, Throwable cause) {&#10;        super(&#10;            &quot;Entity operation failed: &quot; + operation,&#10;            &quot;Failed to &quot; + operation.toLowerCase() + &quot; entity.&quot;,&#10;            &quot;Check if the entity is valid and database connection is working.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/RepositoryException.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/RepositoryException.java" />
              <option name="updatedContent" value="package h2.orm.exception.types;&#10;&#10;import h2.orm.exception.H2OrmException;&#10;&#10;/**&#10; * Exception thrown when repository operation fails&#10; */&#10;public class RepositoryException extends H2OrmException {&#10;    &#10;    public RepositoryException(String operation, Throwable cause) {&#10;        super(&#10;            &quot;Repository operation failed: &quot; + operation,&#10;            &quot;Failed to execute repository operation: &quot; + operation,&#10;            &quot;Check your entity configuration and database connection.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/TransactionRequiredException.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/TransactionRequiredException.java" />
              <option name="updatedContent" value="package h2.orm.exception.types;&#10;&#10;import h2.orm.exception.H2OrmException;&#10;&#10;/**&#10; * Exception thrown when transaction is required but not active&#10; */&#10;public class TransactionRequiredException extends H2OrmException {&#10;    &#10;    public TransactionRequiredException(String operation) {&#10;        super(&#10;            &quot;Transaction required for operation: &quot; + operation,&#10;            &quot;The operation '&quot; + operation + &quot;' requires an active transaction.&quot;,&#10;            &quot;This operation will be automatically wrapped in a transaction.&quot;&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/UniqueConstraintException.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/exception/types/UniqueConstraintException.java" />
              <option name="updatedContent" value="package h2.orm.exception.types;&#10;&#10;import h2.orm.exception.H2OrmException;&#10;&#10;/**&#10; * Exception thrown when unique constraint is violated&#10; */&#10;public class UniqueConstraintException extends H2OrmException {&#10;    &#10;    public UniqueConstraintException(String field, Object value, Throwable cause) {&#10;        super(&#10;            &quot;Unique constraint violation&quot;,&#10;            &quot;A record with &quot; + field + &quot; = '&quot; + value + &quot;' already exists.&quot;,&#10;            &quot;Use a different value for &quot; + field + &quot; or update the existing record instead.&quot;,&#10;            cause&#10;        );&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/AbstractRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/AbstractRepository.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import h2.orm.core.MetadataManager;&#10;import h2.orm.core.TransactionManager;&#10;import h2.orm.exception.ExceptionHandler;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.lang.reflect.ParameterizedType;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Abstract JPA Repository implementation similar to Spring Data JPA&#10; * Provides automatic implementation of all repository methods with comprehensive exception handling&#10; * Now uses core classes for better performance and reliability&#10; */&#10;public abstract class AbstractRepository&lt;T, ID extends Serializable&gt; implements JpaRepository&lt;T, ID&gt; {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(AbstractRepository.class);&#10;&#10;    protected final Class&lt;T&gt; entityClass;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public AbstractRepository() {&#10;        this.entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass().getGenericSuperclass())&#10;                .getActualTypeArguments()[0];&#10;    }&#10;&#10;    protected AbstractRepository(Class&lt;T&gt; entityClass) {&#10;        this.entityClass = entityClass;&#10;    }&#10;&#10;    protected abstract EntityManager getEntityManager();&#10;&#10;    @Override&#10;    public T save(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                // Use MetadataManager for entity state detection&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    return entity;&#10;                } else {&#10;                    return em.merge(entity);&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                int batchSize = 20;&#10;                int count = 0;&#10;&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;&#10;                    if (++count % batchSize == 0) {&#10;                        em.flush();&#10;                        em.clear();&#10;                    }&#10;                }&#10;&#10;                em.flush(); // Final flush&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;T&gt; findById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;find entity by ID&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                T entity = em.find(entityClass, id);&#10;                return Optional.ofNullable(entity);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public boolean existsById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;check entity exists&quot;, () -&gt; {&#10;            return findById(id).isPresent();&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAll() {&#10;        return ExceptionHandler.safeExecute(&quot;find all entities&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                CriteriaBuilder cb = em.getCriteriaBuilder();&#10;                CriteriaQuery&lt;T&gt; query = cb.createQuery(entityClass);&#10;                Root&lt;T&gt; root = query.from(entityClass);&#10;                query.select(root);&#10;&#10;                TypedQuery&lt;T&gt; typedQuery = em.createQuery(query);&#10;                return typedQuery.getResultList();&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities by IDs&quot;, () -&gt; {&#10;            List&lt;T&gt; result = new ArrayList&lt;&gt;();&#10;            for (ID id : ids) {&#10;                findById(id).ifPresent(result::add);&#10;            }&#10;            return result;&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public long count() {&#10;        return ExceptionHandler.safeExecute(&quot;count entities&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                CriteriaBuilder cb = em.getCriteriaBuilder();&#10;                CriteriaQuery&lt;Long&gt; query = cb.createQuery(Long.class);&#10;                Root&lt;T&gt; root = query.from(entityClass);&#10;                query.select(cb.count(root));&#10;&#10;                TypedQuery&lt;Long&gt; typedQuery = em.createQuery(query);&#10;                return typedQuery.getSingleResult();&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteById(ID id) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity by ID&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T entity = em.find(entityClass, id);&#10;                if (entity != null) {&#10;                    em.remove(entity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void delete(T entity) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                em.remove(managedEntity);&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllById(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;                ids.forEach(idList::add);&#10;&#10;                if (!idList.isEmpty()) {&#10;                    String tableName = MetadataManager.getTableName(entityClass);&#10;                    em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;)&#10;                            .setParameter(&quot;ids&quot;, idList)&#10;                            .executeUpdate();&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName()).executeUpdate();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void flush() {&#10;        ExceptionHandler.safeExecute(&quot;flush changes&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.flush();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T saveAndFlush(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save and flush entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                T savedEntity;&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    savedEntity = entity;&#10;                } else {&#10;                    savedEntity = em.merge(entity);&#10;                }&#10;                em.flush();&#10;                return savedEntity;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all and flush entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;                }&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteInBatch(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllInBatch() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName()).executeUpdate();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs in batch&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;                ids.forEach(idList::add);&#10;&#10;                if (!idList.isEmpty()) {&#10;                    em.createQuery(&quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;)&#10;                            .setParameter(&quot;ids&quot;, idList)&#10;                            .executeUpdate();&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getOne(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;get entity reference&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                return em.getReference(entityClass, id);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getReferenceById(ID id) {&#10;        return getOne(id);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import h2.orm.core.MetadataManager;&#10;import h2.orm.core.QueryExecutor;&#10;import h2.orm.core.TransactionManager;&#10;import h2.orm.exception.ExceptionHandler;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.TypedQuery;&#10;import jakarta.persistence.criteria.CriteriaBuilder;&#10;import jakarta.persistence.criteria.CriteriaQuery;&#10;import jakarta.persistence.criteria.Root;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.Serializable;&#10;import java.lang.reflect.ParameterizedType;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Abstract JPA Repository implementation similar to Spring Data JPA&#10; * Now uses QueryExecutor for optimized query performance&#10; */&#10;public abstract class AbstractRepository&lt;T, ID extends Serializable&gt; implements JpaRepository&lt;T, ID&gt; {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(AbstractRepository.class);&#10;&#10;    protected final Class&lt;T&gt; entityClass;&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public AbstractRepository() {&#10;        this.entityClass = (Class&lt;T&gt;) ((ParameterizedType) getClass().getGenericSuperclass())&#10;                .getActualTypeArguments()[0];&#10;    }&#10;&#10;    protected AbstractRepository(Class&lt;T&gt; entityClass) {&#10;        this.entityClass = entityClass;&#10;    }&#10;&#10;    protected abstract EntityManager getEntityManager();&#10;&#10;    @Override&#10;    public T save(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    return entity;&#10;                } else {&#10;                    return em.merge(entity);&#10;                }&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                int batchSize = 20;&#10;                int count = 0;&#10;&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;&#10;                    if (++count % batchSize == 0) {&#10;                        em.flush();&#10;                        em.clear();&#10;                    }&#10;                }&#10;&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;T&gt; findById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;find entity by ID&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                T entity = em.find(entityClass, id);&#10;                return Optional.ofNullable(entity);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public boolean existsById(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;check entity exists&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized exists check&#10;            String jpql = &quot;SELECT COUNT(e) FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id = :id&quot;;&#10;            Long count = QueryExecutor.executeSingleResultQuery(jpql, Long.class, Map.of(&quot;id&quot;, id));&#10;            return count &gt; 0;&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAll() {&#10;        return ExceptionHandler.safeExecute(&quot;find all entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized query execution&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executeQuery(jpql, entityClass);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities by IDs&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;            &#10;            if (idList.isEmpty()) {&#10;                return new ArrayList&lt;&gt;();&#10;            }&#10;            &#10;            // Use QueryExecutor for batch ID lookup&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;            return QueryExecutor.executeQuery(jpql, entityClass, Map.of(&quot;ids&quot;, idList));&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public long count() {&#10;        return ExceptionHandler.safeExecute(&quot;count entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized count query&#10;            String jpql = &quot;SELECT COUNT(e) FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executeSingleResultQuery(jpql, Long.class);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteById(ID id) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity by ID&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id = :id&quot;;&#10;            QueryExecutor.executeUpdate(jpql, Map.of(&quot;id&quot;, id));&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void delete(T entity) {&#10;        ExceptionHandler.safeExecute(&quot;delete entity&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                em.remove(managedEntity);&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllById(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;&#10;            if (!idList.isEmpty()) {&#10;                // Use QueryExecutor for batch delete&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, idList));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                for (T entity : entities) {&#10;                    T managedEntity = em.contains(entity) ? entity : em.merge(entity);&#10;                    em.remove(managedEntity);&#10;                }&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAll() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized bulk delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName();&#10;            QueryExecutor.executeUpdate(jpql);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void flush() {&#10;        ExceptionHandler.safeExecute(&quot;flush changes&quot;, () -&gt; {&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.flush();&#10;                return null;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T saveAndFlush(T entity) {&#10;        return ExceptionHandler.safeExecute(&quot;save and flush entity&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                T savedEntity;&#10;                if (MetadataManager.isEntityNew(entity)) {&#10;                    em.persist(entity);&#10;                    savedEntity = entity;&#10;                } else {&#10;                    savedEntity = em.merge(entity);&#10;                }&#10;                em.flush();&#10;                return savedEntity;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities) {&#10;        return ExceptionHandler.safeExecute(&quot;save all and flush entities&quot;, () -&gt; {&#10;            return TransactionManager.executeInTransaction(em -&gt; {&#10;                List&lt;T&gt; savedEntities = new ArrayList&lt;&gt;();&#10;                for (T entity : entities) {&#10;                    T savedEntity;&#10;                    if (MetadataManager.isEntityNew(entity)) {&#10;                        em.persist(entity);&#10;                        savedEntity = entity;&#10;                    } else {&#10;                        savedEntity = em.merge(entity);&#10;                    }&#10;                    savedEntities.add(savedEntity);&#10;                }&#10;                em.flush();&#10;                return savedEntities;&#10;            });&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteInBatch(Iterable&lt;T&gt; entities) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities in batch&quot;, () -&gt; {&#10;            // Extract IDs and use QueryExecutor for batch delete&#10;            List&lt;ID&gt; ids = new ArrayList&lt;&gt;();&#10;            for (T entity : entities) {&#10;                @SuppressWarnings(&quot;unchecked&quot;)&#10;                ID id = (ID) MetadataManager.getIdValue(entity);&#10;                if (id != null) {&#10;                    ids.add(id);&#10;                }&#10;            }&#10;            &#10;            if (!ids.isEmpty()) {&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, ids));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllInBatch() {&#10;        ExceptionHandler.safeExecute(&quot;delete all entities in batch&quot;, () -&gt; {&#10;            // Use QueryExecutor for optimized bulk delete&#10;            String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName();&#10;            QueryExecutor.executeUpdate(jpql);&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids) {&#10;        ExceptionHandler.safeExecute(&quot;delete entities by IDs in batch&quot;, () -&gt; {&#10;            List&lt;ID&gt; idList = new ArrayList&lt;&gt;();&#10;            ids.forEach(idList::add);&#10;&#10;            if (!idList.isEmpty()) {&#10;                // Use QueryExecutor for batch delete&#10;                String jpql = &quot;DELETE FROM &quot; + entityClass.getSimpleName() + &quot; e WHERE e.id IN :ids&quot;;&#10;                QueryExecutor.executeUpdate(jpql, Map.of(&quot;ids&quot;, idList));&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getOne(ID id) {&#10;        return ExceptionHandler.safeExecute(&quot;get entity reference&quot;, () -&gt; {&#10;            EntityManager em = getEntityManager();&#10;            try {&#10;                return em.getReference(entityClass, id);&#10;            } finally {&#10;                EntityManagerProvider.closeEntityManager();&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public T getReferenceById(ID id) {&#10;        return getOne(id);&#10;    }&#10;&#10;    // Additional utility methods using QueryExecutor&#10;&#10;    /**&#10;     * Find entities with pagination using QueryExecutor&#10;     */&#10;    public List&lt;T&gt; findAll(int offset, int limit) {&#10;        return ExceptionHandler.safeExecute(&quot;find entities with pagination&quot;, () -&gt; {&#10;            String jpql = &quot;SELECT e FROM &quot; + entityClass.getSimpleName() + &quot; e&quot;;&#10;            return QueryExecutor.executePaginatedQuery(jpql, entityClass, null, offset, limit);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute custom JPQL query&#10;     */&#10;    public List&lt;T&gt; findByJpql(String jpql, Map&lt;String, Object&gt; parameters) {&#10;        return ExceptionHandler.safeExecute(&quot;execute custom JPQL query&quot;, () -&gt; {&#10;            return QueryExecutor.executeQuery(jpql, entityClass, parameters);&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Execute custom native SQL query&#10;     */&#10;    public List&lt;T&gt; findByNativeQuery(String sql, Map&lt;String, Object&gt; parameters) {&#10;        return ExceptionHandler.safeExecute(&quot;execute custom native query&quot;, () -&gt; {&#10;            return QueryExecutor.executeNativeQuery(sql, entityClass, parameters);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/JpaRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/JpaRepository.java" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;&#10;/**&#10; * JPA Repository interface similar to Spring Data JPA&#10; * Extends base Repository with additional JPA-specific methods&#10; */&#10;public interface JpaRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; {&#10;    &#10;    /**&#10;     * Flush changes to database&#10;     */&#10;    void flush();&#10;    &#10;    /**&#10;     * Save and flush entity&#10;     */&#10;    T saveAndFlush(T entity);&#10;    &#10;    /**&#10;     * Save all and flush entities&#10;     */&#10;    List&lt;T&gt; saveAllAndFlush(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete entities in batch&#10;     */&#10;    void deleteInBatch(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete all entities in batch&#10;     */&#10;    void deleteAllInBatch();&#10;    &#10;    /**&#10;     * Delete all entities in batch by IDs&#10;     */&#10;    void deleteAllByIdInBatch(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Get reference to entity (lazy loading)&#10;     */&#10;    T getOne(ID id);&#10;    &#10;    /**&#10;     * Get reference to entity (lazy loading) - JPA 3.0 style&#10;     */&#10;    T getReferenceById(ID id);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repositories.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repositories.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import jakarta.persistence.EntityManager;&#10;&#10;import java.io.Serializable;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Repository factory that creates JPA repositories automatically&#10; * Works exactly like Spring Data JPA - just call Repositories.of(EntityClass.class)&#10; */&#10;public class Repositories {&#10;&#10;    private static final Map&lt;Class&lt;?&gt;, JpaRepository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Get repository for entity class - creates it automatically if needed&#10;     * Usage: UserRepository userRepo = Repositories.of(User.class);&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;T, ID extends Serializable&gt; JpaRepository&lt;T, ID&gt; of(Class&lt;T&gt; entityClass) {&#10;        return (JpaRepository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass,&#10;            clazz -&gt; new SimpleJpaRepository&lt;&gt;((Class&lt;T&gt;) clazz));&#10;    }&#10;&#10;    /**&#10;     * Clear repository cache&#10;     */&#10;    public static void clearCache() {&#10;        repositoryCache.clear();&#10;    }&#10;&#10;    /**&#10;     * Simple JPA Repository implementation&#10;     */&#10;    private static class SimpleJpaRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;&#10;        public SimpleJpaRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;&#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import jakarta.persistence.EntityManager;&#10;&#10;import java.io.Serializable;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Repository factory that creates JPA repositories automatically&#10; * Works exactly like Spring Data JPA - just call Repositories.of(EntityClass.class)&#10; * Now uses core EntityManagerProvider for better performance&#10; */&#10;public class Repositories {&#10;    &#10;    private static final Map&lt;Class&lt;?&gt;, JpaRepository&lt;?, ?&gt;&gt; repositoryCache = new ConcurrentHashMap&lt;&gt;();&#10;    &#10;    /**&#10;     * Get repository for entity class - creates it automatically if needed&#10;     * Usage: UserRepository userRepo = Repositories.of(User.class);&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public static &lt;T, ID extends Serializable&gt; JpaRepository&lt;T, ID&gt; of(Class&lt;T&gt; entityClass) {&#10;        return (JpaRepository&lt;T, ID&gt;) repositoryCache.computeIfAbsent(entityClass, &#10;            clazz -&gt; new SimpleJpaRepository&lt;&gt;((Class&lt;T&gt;) clazz));&#10;    }&#10;    &#10;    /**&#10;     * Clear repository cache&#10;     */&#10;    public static void clearCache() {&#10;        repositoryCache.clear();&#10;    }&#10;    &#10;    /**&#10;     * Simple JPA Repository implementation using core EntityManagerProvider&#10;     */&#10;    private static class SimpleJpaRepository&lt;T, ID extends Serializable&gt; extends AbstractRepository&lt;T, ID&gt; {&#10;        &#10;        public SimpleJpaRepository(Class&lt;T&gt; entityClass) {&#10;            super(entityClass);&#10;        }&#10;        &#10;        @Override&#10;        protected EntityManager getEntityManager() {&#10;            return EntityManagerProvider.getEntityManager();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/repository/Repository.java" />
              <option name="originalContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Generic Repository interface for basic CRUD operations&#10; * @param &lt;T&gt; Entity type&#10; * @param &lt;ID&gt; Primary key type&#10; */&#10;public interface Repository&lt;T, ID extends Serializable&gt; {&#10;&#10;    /**&#10;     * Save an entity&#10;     */&#10;    T save(T entity);&#10;&#10;    /**&#10;     * Save multiple entities&#10;     */&#10;    List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    Optional&lt;T&gt; findById(ID id);&#10;&#10;    /**&#10;     * Find all entities&#10;     */&#10;    List&lt;T&gt; findAll();&#10;&#10;    /**&#10;     * Find all entities with pagination&#10;     */&#10;    List&lt;T&gt; findAll(int offset, int limit);&#10;&#10;    /**&#10;     * Find entities by attribute&#10;     */&#10;    List&lt;T&gt; findByAttribute(String attributeName, Object value);&#10;&#10;    /**&#10;     * Find entities by multiple criteria&#10;     */&#10;    List&lt;T&gt; findByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Find entities using native SQL query&#10;     */&#10;    List&lt;T&gt; findByNativeQuery(String sqlQuery, Object... params);&#10;&#10;    /**&#10;     * Find entities using JPQL query&#10;     */&#10;    List&lt;T&gt; findByQuery(String jpqlQuery, Object... params);&#10;&#10;    /**&#10;     * Count all entities&#10;     */&#10;    long count();&#10;&#10;    /**&#10;     * Count entities by criteria&#10;     */&#10;    long countByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    boolean existsById(ID id);&#10;&#10;    /**&#10;     * Check if entity exists by criteria&#10;     */&#10;    boolean existsByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Update entity&#10;     */&#10;    T update(T entity);&#10;&#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    void deleteById(ID id);&#10;&#10;    /**&#10;     * Delete entity&#10;     */&#10;    void delete(T entity);&#10;&#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll();&#10;&#10;    /**&#10;     * Delete entities by criteria&#10;     */&#10;    void deleteByCriteria(Map&lt;String, Object&gt; criteria);&#10;&#10;    /**&#10;     * Execute bulk update query&#10;     */&#10;    int executeUpdate(String jpqlQuery, Object... params);&#10;&#10;    /**&#10;     * Execute native update query&#10;     */&#10;    int executeNativeUpdate(String sqlQuery, Object... params);&#10;&#10;    /**&#10;     * Batch insert entities&#10;     */&#10;    void batchInsert(List&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Batch update entities&#10;     */&#10;    void batchUpdate(List&lt;T&gt; entities);&#10;&#10;    /**&#10;     * Get entity class&#10;     */&#10;    Class&lt;T&gt; getEntityClass();&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.repository;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Base repository interface similar to Spring Data JPA&#10; * Provides standard CRUD operations for entities&#10; */&#10;public interface Repository&lt;T, ID extends Serializable&gt; {&#10;    &#10;    /**&#10;     * Save an entity&#10;     */&#10;    T save(T entity);&#10;    &#10;    /**&#10;     * Save all entities&#10;     */&#10;    List&lt;T&gt; saveAll(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Find entity by ID&#10;     */&#10;    Optional&lt;T&gt; findById(ID id);&#10;    &#10;    /**&#10;     * Check if entity exists by ID&#10;     */&#10;    boolean existsById(ID id);&#10;    &#10;    /**&#10;     * Find all entities&#10;     */&#10;    List&lt;T&gt; findAll();&#10;    &#10;    /**&#10;     * Find all entities by IDs&#10;     */&#10;    List&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Count all entities&#10;     */&#10;    long count();&#10;    &#10;    /**&#10;     * Delete entity by ID&#10;     */&#10;    void deleteById(ID id);&#10;    &#10;    /**&#10;     * Delete entity&#10;     */&#10;    void delete(T entity);&#10;    &#10;    /**&#10;     * Delete all entities by IDs&#10;     */&#10;    void deleteAllById(Iterable&lt;ID&gt; ids);&#10;    &#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll(Iterable&lt;T&gt; entities);&#10;    &#10;    /**&#10;     * Delete all entities&#10;     */&#10;    void deleteAll();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/service/BackupService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/service/BackupService.java" />
              <option name="originalContent" value="package h2.orm.service;&#10;&#10;import h2.orm.core.EntityManagerProvider;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.*;&#10;import java.nio.file.*;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.zip.GZIPInputStream;&#10;import java.util.zip.GZIPOutputStream;&#10;&#10;/**&#10; * Database backup and restore service&#10; */&#10;public class BackupService {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(BackupService.class);&#10;&#10;    /**&#10;     * Create database backup&#10;     */&#10;    public void createBackup(String backupPath) {&#10;        try {&#10;            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyyMMdd_HHmmss&quot;));&#10;            String backupFile = backupPath + &quot;_&quot; + timestamp + &quot;.sql&quot;;&#10;&#10;            // For H2 database, use SCRIPT command&#10;            EntityManagerProvider.executeInTransaction(em -&gt; {&#10;                em.createNativeQuery(&quot;SCRIPT TO '&quot; + backupFile + &quot;'&quot;).executeUpdate();&#10;                logger.info(&quot;Database backup created: {}&quot;, backupFile);&#10;                return null;&#10;            });&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to create backup&quot;, e);&#10;            throw new RuntimeException(&quot;Backup creation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Restore database from backup&#10;     */&#10;    public void restoreBackup(String backupPath) {&#10;        try {&#10;            if (!Files.exists(Paths.get(backupPath))) {&#10;                throw new FileNotFoundException(&quot;Backup file not found: &quot; + backupPath);&#10;            }&#10;&#10;            // For H2 database, use RUNSCRIPT command&#10;            EntityManagerProvider.executeInTransaction(em -&gt; {&#10;                em.createNativeQuery(&quot;RUNSCRIPT FROM '&quot; + backupPath + &quot;'&quot;).executeUpdate();&#10;                logger.info(&quot;Database restored from backup: {}&quot;, backupPath);&#10;                return null;&#10;            });&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to restore backup&quot;, e);&#10;            throw new RuntimeException(&quot;Backup restoration failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Create compressed backup&#10;     */&#10;    public void createCompressedBackup(String backupPath) {&#10;        try {&#10;            String tempFile = backupPath + &quot;.tmp&quot;;&#10;            createBackup(tempFile);&#10;&#10;            // Compress the backup file&#10;            try (FileInputStream fis = new FileInputStream(tempFile);&#10;                 FileOutputStream fos = new FileOutputStream(backupPath + &quot;.gz&quot;);&#10;                 GZIPOutputStream gzos = new GZIPOutputStream(fos)) {&#10;&#10;                byte[] buffer = new byte[1024];&#10;                int len;&#10;                while ((len = fis.read(buffer)) != -1) {&#10;                    gzos.write(buffer, 0, len);&#10;                }&#10;            }&#10;&#10;            // Delete temporary file&#10;            Files.deleteIfExists(Paths.get(tempFile));&#10;            logger.info(&quot;Compressed backup created: {}.gz&quot;, backupPath);&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to create compressed backup&quot;, e);&#10;            throw new RuntimeException(&quot;Compressed backup creation failed&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Restore from compressed backup&#10;     */&#10;    public void restoreCompressedBackup(String compressedBackupPath) {&#10;        try {&#10;            String tempFile = compressedBackupPath.replace(&quot;.gz&quot;, &quot;.tmp&quot;);&#10;&#10;            // Decompress the backup file&#10;            try (FileInputStream fis = new FileInputStream(compressedBackupPath);&#10;                 GZIPInputStream gzis = new GZIPInputStream(fis);&#10;                 FileOutputStream fos = new FileOutputStream(tempFile)) {&#10;&#10;                byte[] buffer = new byte[1024];&#10;                int len;&#10;                while ((len = gzis.read(buffer)) != -1) {&#10;                    fos.write(buffer, 0, len);&#10;                }&#10;            }&#10;&#10;            // Restore from decompressed file&#10;            restoreBackup(tempFile);&#10;&#10;            // Clean up&#10;            Files.deleteIfExists(Paths.get(tempFile));&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to restore compressed backup&quot;, e);&#10;            throw new RuntimeException(&quot;Compressed backup restoration failed&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package h2.orm.service;&#10;&#10;import h2.orm.core.TransactionManager;&#10;import h2.orm.core.EntityManagerProvider;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.*;&#10;import java.nio.file.*;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.zip.GZIPInputStream;&#10;import java.util.zip.GZIPOutputStream;&#10;&#10;/**&#10; * Database backup and restore service&#10; * Now uses core TransactionManager and QueryExecutor for better reliability&#10; */&#10;public class BackupService {&#10;    &#10;    private static final Logger logger = LoggerFactory.getLogger(BackupService.class);&#10;    &#10;    /**&#10;     * Create database backup using core components&#10;     */&#10;    public void createBackup(String backupPath) {&#10;        try {&#10;            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyyMMdd_HHmmss&quot;));&#10;            String backupFile = backupPath + &quot;_&quot; + timestamp + &quot;.sql&quot;;&#10;            &#10;            // Use TransactionManager for safe backup operation&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.createNativeQuery(&quot;SCRIPT TO '&quot; + backupFile + &quot;'&quot;).executeUpdate();&#10;                logger.info(&quot;Database backup created: {}&quot;, backupFile);&#10;                return null;&#10;            });&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to create backup&quot;, e);&#10;            throw new RuntimeException(&quot;Backup creation failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Restore database from backup using core components&#10;     */&#10;    public void restoreBackup(String backupPath) {&#10;        try {&#10;            if (!Files.exists(Paths.get(backupPath))) {&#10;                throw new FileNotFoundException(&quot;Backup file not found: &quot; + backupPath);&#10;            }&#10;            &#10;            // Use TransactionManager for safe restore operation&#10;            TransactionManager.executeInTransaction(em -&gt; {&#10;                em.createNativeQuery(&quot;RUNSCRIPT FROM '&quot; + backupPath + &quot;'&quot;).executeUpdate();&#10;                logger.info(&quot;Database restored from backup: {}&quot;, backupPath);&#10;                return null;&#10;            });&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to restore backup&quot;, e);&#10;            throw new RuntimeException(&quot;Backup restoration failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Create compressed backup with improved performance&#10;     */&#10;    public void createCompressedBackup(String backupPath) {&#10;        try {&#10;            String tempFile = backupPath + &quot;.tmp&quot;;&#10;            createBackup(tempFile);&#10;            &#10;            // Compress the backup file&#10;            try (FileInputStream fis = new FileInputStream(tempFile);&#10;                 FileOutputStream fos = new FileOutputStream(backupPath + &quot;.gz&quot;);&#10;                 GZIPOutputStream gzos = new GZIPOutputStream(fos)) {&#10;                &#10;                byte[] buffer = new byte[8192]; // Increased buffer size for better performance&#10;                int len;&#10;                while ((len = fis.read(buffer)) != -1) {&#10;                    gzos.write(buffer, 0, len);&#10;                }&#10;            }&#10;            &#10;            // Delete temporary file&#10;            Files.deleteIfExists(Paths.get(tempFile));&#10;            logger.info(&quot;Compressed backup created: {}.gz&quot;, backupPath);&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to create compressed backup&quot;, e);&#10;            throw new RuntimeException(&quot;Compressed backup creation failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Restore from compressed backup&#10;     */&#10;    public void restoreCompressedBackup(String compressedBackupPath) {&#10;        try {&#10;            String tempFile = compressedBackupPath.replace(&quot;.gz&quot;, &quot;.tmp&quot;);&#10;            &#10;            // Decompress the backup file&#10;            try (FileInputStream fis = new FileInputStream(compressedBackupPath);&#10;                 GZIPInputStream gzis = new GZIPInputStream(fis);&#10;                 FileOutputStream fos = new FileOutputStream(tempFile)) {&#10;                &#10;                byte[] buffer = new byte[8192]; // Increased buffer size&#10;                int len;&#10;                while ((len = gzis.read(buffer)) != -1) {&#10;                    fos.write(buffer, 0, len);&#10;                }&#10;            }&#10;            &#10;            // Restore from decompressed file&#10;            restoreBackup(tempFile);&#10;            &#10;            // Clean up&#10;            Files.deleteIfExists(Paths.get(tempFile));&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to restore compressed backup&quot;, e);&#10;            throw new RuntimeException(&quot;Compressed backup restoration failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Get backup file information&#10;     */&#10;    public BackupInfo getBackupInfo(String backupPath) {&#10;        try {&#10;            Path path = Paths.get(backupPath);&#10;            if (!Files.exists(path)) {&#10;                return null;&#10;            }&#10;            &#10;            BackupInfo info = new BackupInfo();&#10;            info.setFilePath(backupPath);&#10;            info.setFileSize(Files.size(path));&#10;            info.setCreationTime(Files.getLastModifiedTime(path).toInstant());&#10;            info.setCompressed(backupPath.endsWith(&quot;.gz&quot;));&#10;            &#10;            return info;&#10;            &#10;        } catch (Exception e) {&#10;            logger.warn(&quot;Failed to get backup info for: {}&quot;, backupPath, e);&#10;            return null;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Backup information holder&#10;     */&#10;    public static class BackupInfo {&#10;        private String filePath;&#10;        private long fileSize;&#10;        private java.time.Instant creationTime;&#10;        private boolean compressed;&#10;        &#10;        // Getters and setters&#10;        public String getFilePath() { return filePath; }&#10;        public void setFilePath(String filePath) { this.filePath = filePath; }&#10;        &#10;        public long getFileSize() { return fileSize; }&#10;        public void setFileSize(long fileSize) { this.fileSize = fileSize; }&#10;        &#10;        public java.time.Instant getCreationTime() { return creationTime; }&#10;        public void setCreationTime(java.time.Instant creationTime) { this.creationTime = creationTime; }&#10;        &#10;        public boolean isCompressed() { return compressed; }&#10;        public void setCompressed(boolean compressed) { this.compressed = compressed; }&#10;        &#10;        @Override&#10;        public String toString() {&#10;            return &quot;BackupInfo{&quot; +&#10;                    &quot;filePath='&quot; + filePath + '\'' +&#10;                    &quot;, fileSize=&quot; + fileSize +&#10;                    &quot;, creationTime=&quot; + creationTime +&#10;                    &quot;, compressed=&quot; + compressed +&#10;                    '}';&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/h2/orm/service/ExportService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/h2/orm/service/ExportService.java" />
              <option name="updatedContent" value="package h2.orm.service;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.fasterxml.jackson.databind.SerializationFeature;&#10;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;&#10;import org.apache.poi.ss.usermodel.*;&#10;import org.apache.poi.xssf.usermodel.XSSFWorkbook;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.FileOutputStream;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.lang.reflect.Field;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;/**&#10; * Export service for converting data to various formats (CSV, Excel, JSON)&#10; */&#10;public class ExportService {&#10;    &#10;    private static final Logger logger = LoggerFactory.getLogger(ExportService.class);&#10;    private final ObjectMapper objectMapper;&#10;    &#10;    public ExportService() {&#10;        this.objectMapper = new ObjectMapper();&#10;        this.objectMapper.registerModule(new JavaTimeModule());&#10;        this.objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);&#10;        this.objectMapper.enable(SerializationFeature.INDENT_OUTPUT);&#10;    }&#10;    &#10;    /**&#10;     * Export data to CSV file&#10;     */&#10;    public &lt;T&gt; void exportToCsv(List&lt;T&gt; data, String filePath) {&#10;        if (data == null || data.isEmpty()) {&#10;            logger.warn(&quot;No data to export to CSV&quot;);&#10;            return;&#10;        }&#10;        &#10;        try (FileWriter writer = new FileWriter(filePath)) {&#10;            Class&lt;?&gt; clazz = data.get(0).getClass();&#10;            Field[] fields = clazz.getDeclaredFields();&#10;            &#10;            // Write header&#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                if (i &gt; 0) writer.append(&quot;,&quot;);&#10;                writer.append(fields[i].getName());&#10;            }&#10;            writer.append(&quot;\n&quot;);&#10;            &#10;            // Write data&#10;            for (T item : data) {&#10;                for (int i = 0; i &lt; fields.length; i++) {&#10;                    if (i &gt; 0) writer.append(&quot;,&quot;);&#10;                    &#10;                    fields[i].setAccessible(true);&#10;                    Object value = fields[i].get(item);&#10;                    String stringValue = value != null ? value.toString() : &quot;&quot;;&#10;                    &#10;                    // Escape commas and quotes in CSV&#10;                    if (stringValue.contains(&quot;,&quot;) || stringValue.contains(&quot;\&quot;&quot;)) {&#10;                        stringValue = &quot;\&quot;&quot; + stringValue.replace(&quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;) + &quot;\&quot;&quot;;&#10;                    }&#10;                    &#10;                    writer.append(stringValue);&#10;                }&#10;                writer.append(&quot;\n&quot;);&#10;            }&#10;            &#10;            logger.info(&quot;Data exported to CSV: {} ({} records)&quot;, filePath, data.size());&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to export to CSV&quot;, e);&#10;            throw new RuntimeException(&quot;CSV export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export data to Excel file&#10;     */&#10;    public &lt;T&gt; void exportToExcel(List&lt;T&gt; data, String filePath) {&#10;        if (data == null || data.isEmpty()) {&#10;            logger.warn(&quot;No data to export to Excel&quot;);&#10;            return;&#10;        }&#10;        &#10;        try (Workbook workbook = new XSSFWorkbook()) {&#10;            Sheet sheet = workbook.createSheet(&quot;Data&quot;);&#10;            &#10;            Class&lt;?&gt; clazz = data.get(0).getClass();&#10;            Field[] fields = clazz.getDeclaredFields();&#10;            &#10;            // Create header row&#10;            Row headerRow = sheet.createRow(0);&#10;            CellStyle headerStyle = workbook.createCellStyle();&#10;            Font headerFont = workbook.createFont();&#10;            headerFont.setBold(true);&#10;            headerStyle.setFont(headerFont);&#10;            &#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                Cell cell = headerRow.createCell(i);&#10;                cell.setCellValue(fields[i].getName());&#10;                cell.setCellStyle(headerStyle);&#10;            }&#10;            &#10;            // Create data rows&#10;            for (int rowIndex = 0; rowIndex &lt; data.size(); rowIndex++) {&#10;                Row row = sheet.createRow(rowIndex + 1);&#10;                T item = data.get(rowIndex);&#10;                &#10;                for (int colIndex = 0; colIndex &lt; fields.length; colIndex++) {&#10;                    Cell cell = row.createCell(colIndex);&#10;                    fields[colIndex].setAccessible(true);&#10;                    Object value = fields[colIndex].get(item);&#10;                    &#10;                    if (value != null) {&#10;                        if (value instanceof Number) {&#10;                            cell.setCellValue(((Number) value).doubleValue());&#10;                        } else if (value instanceof Boolean) {&#10;                            cell.setCellValue((Boolean) value);&#10;                        } else if (value instanceof LocalDate) {&#10;                            cell.setCellValue(value.toString());&#10;                        } else if (value instanceof LocalDateTime) {&#10;                            cell.setCellValue(value.toString());&#10;                        } else {&#10;                            cell.setCellValue(value.toString());&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            &#10;            // Auto-size columns&#10;            for (int i = 0; i &lt; fields.length; i++) {&#10;                sheet.autoSizeColumn(i);&#10;            }&#10;            &#10;            // Write to file&#10;            try (FileOutputStream fileOut = new FileOutputStream(filePath)) {&#10;                workbook.write(fileOut);&#10;            }&#10;            &#10;            logger.info(&quot;Data exported to Excel: {} ({} records)&quot;, filePath, data.size());&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to export to Excel&quot;, e);&#10;            throw new RuntimeException(&quot;Excel export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export data to JSON file&#10;     */&#10;    public &lt;T&gt; void exportToJson(List&lt;T&gt; data, String filePath) {&#10;        try {&#10;            objectMapper.writeValue(new java.io.File(filePath), data);&#10;            logger.info(&quot;Data exported to JSON: {} ({} records)&quot;, filePath, data != null ? data.size() : 0);&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Failed to export to JSON&quot;, e);&#10;            throw new RuntimeException(&quot;JSON export failed&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Export single object to JSON file&#10;     */&#10;    public &lt;T&gt; void exportToJson(T object, String filePath) {&#10;        try {&#10;            objectMapper.writeValue(new java.io.File(filePath), object);&#10;            logger.info(&quot;Object exported to JSON: {}&quot;, filePath);&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Failed to export to JSON&quot;, e);&#10;            throw new RuntimeException(&quot;JSON export failed&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/META-INF/persistence.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/META-INF/persistence.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;&#10;             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;             xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/persistence&#10;                http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&quot;&#10;             version=&quot;2.0&quot;&gt;&#10;&#10;    &lt;!-- H2 Database Configuration --&gt;&#10;    &lt;persistence-unit name=&quot;h2-persistence-unit&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;&#10;        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;&#10;        &lt;properties&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.driver&quot; value=&quot;org.h2.Driver&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.url&quot; value=&quot;jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.user&quot; value=&quot;sa&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.password&quot; value=&quot;&quot;/&gt;&#10;&#10;            &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.H2Dialect&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create-drop&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;false&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;&#10;&#10;            &lt;!-- Connection Pool --&gt;&#10;            &lt;property name=&quot;hibernate.connection.provider_class&quot; value=&quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hikari.minimumIdle&quot; value=&quot;5&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hikari.maximumPoolSize&quot; value=&quot;20&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hikari.idleTimeout&quot; value=&quot;300000&quot;/&gt;&#10;        &lt;/properties&gt;&#10;    &lt;/persistence-unit&gt;&#10;&#10;    &lt;!-- SQLite Database Configuration --&gt;&#10;    &lt;persistence-unit name=&quot;sqlite-persistence-unit&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;&#10;        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;&#10;        &lt;properties&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.driver&quot; value=&quot;org.sqlite.JDBC&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.url&quot; value=&quot;jdbc:sqlite:memory:myDb&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.user&quot; value=&quot;&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.password&quot; value=&quot;&quot;/&gt;&#10;&#10;            &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.community.dialect.SQLiteDialect&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create-drop&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;false&quot;/&gt;&#10;&#10;            &lt;!-- Connection Pool --&gt;&#10;            &lt;property name=&quot;hibernate.connection.provider_class&quot; value=&quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hikari.minimumIdle&quot; value=&quot;1&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hikari.maximumPoolSize&quot; value=&quot;5&quot;/&gt;&#10;        &lt;/properties&gt;&#10;    &lt;/persistence-unit&gt;&#10;&#10;    &lt;!-- MySQL Database Configuration --&gt;&#10;    &lt;persistence-unit name=&quot;mysql-persistence-unit&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;&#10;        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;&#10;        &lt;properties&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.url&quot; value=&quot;jdbc:mysql://localhost:3306/myapp&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.user&quot; value=&quot;root&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.password&quot; value=&quot;password&quot;/&gt;&#10;&#10;            &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;false&quot;/&gt;&#10;&#10;            &lt;!-- Connection Pool --&gt;&#10;            &lt;property name=&quot;hibernate.connection.provider_class&quot; value=&quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hikari.minimumIdle&quot; value=&quot;5&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hikari.maximumPoolSize&quot; value=&quot;20&quot;/&gt;&#10;        &lt;/properties&gt;&#10;    &lt;/persistence-unit&gt;&#10;&#10;    &lt;!-- PostgreSQL Database Configuration --&gt;&#10;    &lt;persistence-unit name=&quot;postgresql-persistence-unit&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;&#10;        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;&#10;        &lt;properties&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.driver&quot; value=&quot;org.postgresql.Driver&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.url&quot; value=&quot;jdbc:postgresql://localhost:5432/myapp&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.user&quot; value=&quot;postgres&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.password&quot; value=&quot;password&quot;/&gt;&#10;&#10;            &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.PostgreSQLDialect&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;false&quot;/&gt;&#10;&#10;            &lt;!-- Connection Pool --&gt;&#10;            &lt;property name=&quot;hibernate.connection.provider_class&quot; value=&quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hikari.minimumIdle&quot; value=&quot;5&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.hikari.maximumPoolSize&quot; value=&quot;20&quot;/&gt;&#10;        &lt;/properties&gt;&#10;    &lt;/persistence-unit&gt;&#10;&#10;&lt;/persistence&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#13;&#10;&lt;persistence xmlns=&quot;https://jakarta.ee/xml/ns/persistence&quot;&#13;&#10;             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#13;&#10;             xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/persistence&#13;&#10;             https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd&quot;&#13;&#10;             version=&quot;3.0&quot;&gt;&#13;&#10;&#13;&#10;    &lt;!-- H2 Database Configuration --&gt;&#13;&#10;    &lt;persistence-unit name=&quot;h2-orm-pu&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;&#13;&#10;        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;&#13;&#10;        &#13;&#10;        &lt;!-- Automatically discover all entities in the classpath --&gt;&#13;&#10;        &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;&#13;&#10;        &#13;&#10;        &lt;properties&gt;&#13;&#10;            &lt;!-- Default properties - can be overridden programmatically --&gt;&#13;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.driver&quot; value=&quot;org.h2.Driver&quot;/&gt;&#13;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.url&quot; value=&quot;jdbc:h2:mem:h2orm;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false&quot;/&gt;&#13;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.user&quot; value=&quot;sa&quot;/&gt;&#13;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.password&quot; value=&quot;&quot;/&gt;&#13;&#10;            &#13;&#10;            &lt;!-- Hibernate properties --&gt;&#13;&#10;            &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.H2Dialect&quot;/&gt;&#13;&#10;            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;&#13;&#10;            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;false&quot;/&gt;&#13;&#10;            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;false&quot;/&gt;&#13;&#10;            &#13;&#10;            &lt;!-- Connection pool --&gt;&#13;&#10;            &lt;property name=&quot;hibernate.connection.provider_class&quot; value=&quot;org.hibernate.hikaricp.internal.HikariCPConnectionProvider&quot;/&gt;&#13;&#10;            &lt;property name=&quot;hibernate.hikari.maximumPoolSize&quot; value=&quot;10&quot;/&gt;&#13;&#10;            &lt;property name=&quot;hibernate.hikari.minimumIdle&quot; value=&quot;5&quot;/&gt;&#13;&#10;            &#13;&#10;            &lt;!-- Performance optimizations --&gt;&#13;&#10;            &lt;property name=&quot;hibernate.jdbc.batch_size&quot; value=&quot;20&quot;/&gt;&#13;&#10;            &lt;property name=&quot;hibernate.order_inserts&quot; value=&quot;true&quot;/&gt;&#13;&#10;            &lt;property name=&quot;hibernate.order_updates&quot; value=&quot;true&quot;/&gt;&#13;&#10;            &lt;property name=&quot;hibernate.jdbc.batch_versioned_data&quot; value=&quot;true&quot;/&gt;&#13;&#10;            &#13;&#10;            &lt;!-- Additional settings --&gt;&#13;&#10;            &lt;property name=&quot;hibernate.connection.autocommit&quot; value=&quot;false&quot;/&gt;&#13;&#10;            &lt;property name=&quot;hibernate.jdbc.lob.non_contextual_creation&quot; value=&quot;true&quot;/&gt;&#13;&#10;            &lt;property name=&quot;hibernate.temp.use_jdbc_metadata_defaults&quot; value=&quot;false&quot;/&gt;&#13;&#10;        &lt;/properties&gt;&#13;&#10;    &lt;/persistence-unit&gt;&#13;&#10;&lt;/persistence&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/h2-orm-config.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/h2-orm-config.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&#10;&lt;properties&gt;&#10;    &lt;comment&gt;H2-ORM XML Configuration&lt;/comment&gt;&#10;    &#10;    &lt;!-- Database Settings --&gt;&#10;    &lt;entry key=&quot;h2orm.database.type&quot;&gt;h2&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.database.mode&quot;&gt;file&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.database.path&quot;&gt;./data/h2orm&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.database.username&quot;&gt;sa&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.database.password&quot;&gt;&lt;/entry&gt;&#10;    &#10;    &lt;!-- Connection Pool Settings --&gt;&#10;    &lt;entry key=&quot;h2orm.pool.size&quot;&gt;10&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.pool.timeout&quot;&gt;30000&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.pool.idle.timeout&quot;&gt;600000&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.pool.max.lifetime&quot;&gt;1800000&lt;/entry&gt;&#10;    &#10;    &lt;!-- JPA/Hibernate Settings --&gt;&#10;    &lt;entry key=&quot;h2orm.jpa.ddl.auto&quot;&gt;update&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.jpa.show.sql&quot;&gt;false&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.jpa.format.sql&quot;&gt;false&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.jpa.batch.size&quot;&gt;20&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.jpa.cache.use.second.level&quot;&gt;true&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.jpa.cache.use.query&quot;&gt;true&lt;/entry&gt;&#10;    &#10;    &lt;!-- Export Settings --&gt;&#10;    &lt;entry key=&quot;h2orm.export.csv.delimiter&quot;&gt;,&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.export.excel.sheet.name&quot;&gt;Data&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.export.json.pretty.print&quot;&gt;true&lt;/entry&gt;&#10;    &#10;    &lt;!-- Backup Settings --&gt;&#10;    &lt;entry key=&quot;h2orm.backup.auto.enabled&quot;&gt;false&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.backup.interval.hours&quot;&gt;24&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.backup.retention.days&quot;&gt;7&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.backup.compression&quot;&gt;true&lt;/entry&gt;&#10;    &#10;    &lt;!-- Monitoring Settings --&gt;&#10;    &lt;entry key=&quot;h2orm.monitoring.enabled&quot;&gt;true&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.monitoring.query.log.enabled&quot;&gt;false&lt;/entry&gt;&#10;    &lt;entry key=&quot;h2orm.monitoring.slow.query.threshold.ms&quot;&gt;1000&lt;/entry&gt;&#10;&lt;/properties&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/h2-orm.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/h2-orm.properties" />
              <option name="updatedContent" value="# H2-ORM Default Configuration&#10;# Database Settings&#10;h2orm.database.type=h2&#10;h2orm.database.mode=file&#10;h2orm.database.path=./data/h2orm&#10;h2orm.database.username=sa&#10;h2orm.database.password=&#10;&#10;# For other databases, uncomment and configure:&#10;# h2orm.database.host=localhost&#10;# h2orm.database.port=3306&#10;# h2orm.database.name=myapp&#10;&#10;# Connection Pool Settings&#10;h2orm.pool.size=10&#10;h2orm.pool.timeout=30000&#10;h2orm.pool.idle.timeout=600000&#10;h2orm.pool.max.lifetime=1800000&#10;&#10;# JPA/Hibernate Settings&#10;h2orm.jpa.ddl.auto=update&#10;h2orm.jpa.show.sql=false&#10;h2orm.jpa.format.sql=false&#10;h2orm.jpa.batch.size=20&#10;h2orm.jpa.cache.use.second.level=true&#10;h2orm.jpa.cache.use.query=true&#10;&#10;# Export Settings&#10;h2orm.export.csv.delimiter=,&#10;h2orm.export.excel.sheet.name=Data&#10;h2orm.export.json.pretty.print=true&#10;&#10;# Backup Settings&#10;h2orm.backup.auto.enabled=false&#10;h2orm.backup.interval.hours=24&#10;h2orm.backup.retention.days=7&#10;h2orm.backup.compression=true&#10;&#10;# Monitoring Settings&#10;h2orm.monitoring.enabled=true&#10;h2orm.monitoring.query.log.enabled=false&#10;h2orm.monitoring.slow.query.threshold.ms=1000" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>